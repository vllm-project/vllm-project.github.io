<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROCM_AITER_FA Request Flow Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            padding: 10px;
            min-height: 100vh;
            overflow-x: auto;
            color: #333;
        }

        .container {
            max-width: 1380px;
            margin: 0 auto;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .left-panel {
            flex: 0 0 540px;
        }

        .right-panel {
            flex: 0 0 800px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 20px;
            padding: 20px;
            margin-top: 0px;
        }

        .panel-layout {
            display: flex;
            flex-direction: column;
            gap: 0px;
        }

        .control-column {
            width: 100%;
        }

        .info-column {
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            margin-bottom: 0;
        }

        .control-btn {
            padding: 8px 16px;
            font-size: 0.85em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            white-space: nowrap;
        }

        .control-btn.start {
            background: #667eea;
        }

        .control-btn.pause {
            background: #ffa726;
        }

        .control-btn.reset {
            background: #6c757d;
        }

        .control-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .iteration-select-wrapper {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
        }

        .iteration-select-label {
            color: #495057;
            font-size: 0.85em;
            font-weight: 600;
            white-space: nowrap;
        }

        .iteration-select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ced4da;
            background: white;
            color: #495057;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .iteration-select:hover:not(:disabled) {
            border-color: #667eea;
        }

        .iteration-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f8f9fa;
        }

        .keyboard-hint {
            color: #6c757d;
            font-size: 0.7em;
            font-style: italic;
            margin-left: auto;
        }

        /* Timeline Visualization */
        .timeline-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 0px;
            border: 1px solid #e0e0e0;
            overflow-x: auto;
            position: relative;  /* For absolute positioning of highlight rectangle */
        }

        .timeline-grid {
            display: grid;
            grid-template-columns: 80px 1px repeat(7, 1fr) 60px;
            gap: 2px;
            font-size: 0.7em;
            min-width: 740px;
        }

        .timeline-time-axis {
            text-align: center;
            font-weight: 400;
            color: #6c757d;
            padding: 0px 2px;
            font-size: 0.9em;
            position: relative;
            min-height: 18px;
        }

        .timeline-step-label {
            text-align: center;
            font-weight: 600;
            color: #495057;
            padding: 4px 2px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .timeline-request-label {
            font-weight: 600;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            color: white;
            font-size: 0.85em;
            min-height: 20px;
        }

        .timeline-cell {
            padding: 4px 2px;
            text-align: center;
            border-radius: 4px;
            font-weight: 500;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
            font-size: 0.85em;
            position: relative;
        }

        .timeline-cell.empty {
            background: transparent;
        }

        .timeline-cell.dots {
            background: #f8f9fa;
            color: #6c757d;
            font-weight: bold;
            font-size: 1.2em;
        }

        .arrival-marker {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2em;
            color: #495057;
            line-height: 1;
        }

        .arrival-marker-early {
            left: 30%;
        }

        .arrival-marker-late {
            left: 70%;
        }

        .arrival-label {
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            font-weight: bold;
            line-height: 1;
        }

        .arrival-label-early {
            left: 30%;
        }

        .arrival-label-late {
            left: 70%;
        }

        /* Request color classes */
        .request-1-color { background: #26d0ce; }
        .request-2-color { background: #1abc9c; }
        .request-3-color { background: #16a085; }
        .request-4-color { background: #138d75; }
        .request-5-color { background: #117a65; }

        .request-1-text { color: #26d0ce; }
        .request-2-text { color: #1abc9c; }
        .request-3-text { color: #16a085; }
        .request-4-text { color: #138d75; }
        .request-5-text { color: #117a65; }

        /* Timeline cell stage types */
        .timeline-cell.active {
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.8);
            transform: scale(1.05);
            transition: all 0.3s ease;
        }

        /* Timeline highlight rectangle */
        .timeline-highlight-rect {
            position: absolute;
            border: 3px solid #dc3545;  /* Red border */
            background: none;  /* No background */
            border-radius: 8px;
            pointer-events: none;  /* Don't block mouse events */
            z-index: 10;
            transition: all 0.3s ease;  /* Smooth movement */
        }

        .timeline-highlight-rect.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .time-axis-arrow {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            padding: 0px 0;
            margin-bottom: 0px;
            margin-top: -2px;
            height: 10px;
        }

        .time-axis-arrow::before {
            content: '';
            flex: 1;
            height: 3px;
            background: #495057;
            margin-left: 80px;
            margin-right: 0px;
        }

        .time-axis-arrow::after {
            content: '';
            width: 0;
            height: 0;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 10px solid #495057;
            margin-left: 0px;
            margin-right: 0px;
        }

        .time-label {
            font-size: 0.75em;
            color: #495057;
            font-weight: 600;
            margin-left: 5px;
            margin-right: 55px;
            white-space: nowrap;
            order: 3;
        }


        .info-section {
            background: #ffffff;
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #e0e0e0;
        }

        .info-title {
            color: #495057;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 6px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 3px;
        }

        .info-row {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 10px;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: start;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .info-value {
            color: #212529;
            font-weight: normal;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            word-wrap: break-word;
            text-align: left;
        }

        .info-value.text {
            word-wrap: break-word;
            text-align: left;
        }

        .info-value.highlight {
            font-weight: bold;
        }

        /* Requests Table Styles */
        .requests-table {
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow-x: auto;
            font-size: 0.75em;
        }

        .table-header {
            display: grid;
            grid-template-columns: 80px repeat(5, 1fr);
            gap: 4px;
            padding: 6px 4px;
            background: #e7f0ff;
            border-radius: 6px;
            font-weight: bold;
            color: #495057;
        }

        .table-row {
            display: grid;
            grid-template-columns: 80px repeat(5, 1fr);
            gap: 4px;
            padding: 6px 4px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            align-items: center;
        }

        .table-row:hover {
            background: #f0f2f5;
        }

        .header-cell {
            font-size: 0.85em;
            text-align: center;
            color: #667eea;
            font-weight: bold;
        }

        .header-cell.field-label {
            text-align: left;
            padding-left: 4px;
        }

        .cell {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #212529;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .cell.field-label {
            font-weight: bold;
            color: #6c757d;
            text-align: left;
            padding-left: 4px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            white-space: normal;
            word-wrap: break-word;
        }

        .cell.highlight {
            font-weight: bold;
            transition: font-weight 0.3s ease;
        }

        .cell.status {
            font-weight: bold;
            font-size: 0.85em;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            color: #212529;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Flow Layout */
        .flow-diagram {
            position: relative;
            width: 100%;
            height: 800px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 20px;
            padding: 20px;
            padding-top: 80px;
        }

        /* Static Modules */
        .module {
            position: absolute;
            background: linear-gradient(135deg, #e3e8f5 0%, #d4dcf0 100%);
            border: 2px solid #a8b5d8;
            border-radius: 12px;
            padding: 20px 15px;
            color: #212529;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .module:hover {
            border-color: #667eea;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .module-title {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            color: #495057;
        }

        .module-content {
            font-size: 0.75em;
            color: #6c757d;
            line-height: 1.4;
        }

        .module-content ul {
            list-style: none;
            padding-left: 0;
        }

        .module-content li {
            padding: 2px 0;
            padding-left: 12px;
            position: relative;
        }

        .module-content li:before {
            content: "▸";
            position: absolute;
            left: 0;
            color: #667eea;
            font-size: 0.8em;
        }

        /* Module Positions */
        #entrypoint {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            padding: 10px 15px;
        }

        #scheduler {
            top: 105px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            padding: 10px 15px;
        }

        #modelrunner {
            top: 160px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 270px;
        }

        #attention {
            top: 435px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 270px;
        }

        #output {
            top: 710px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            padding: 10px 15px;
        }

        /* Sub-step boxes inside model runner */
        .substep-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            width: 470px;
        }

        .substep-box {
            padding: 6px 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.65em;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            color: #495057;
            transition: all 0.3s ease;
            line-height: 1.3;
        }

        .substep-box.active {
            background: rgba(102, 126, 234, 0.25);
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.4);
            transform: scale(1.05);
        }

        /* Visual circle for input tokens */
        .input-bar-container {
            position: relative;
            width: 35px;
            height: 35px;
            z-index: 70;
        }

        .input-bar {
            width: 35px;
            height: 35px;
            background: #667eea;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            position: relative;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: white;
        }

        /* QKV bars - stacked vertically */
        .qkv-bars-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 0px;
            opacity: 0;
            transition: all 0.8s ease;
            z-index: 60;
        }

        .qkv-bars-container.show {
            opacity: 1;
        }

        .qkv-single-bar {
            width: 470px;
            height: 25px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .qkv-single-bar.q {
            background: #ff6b9d;
        }

        .qkv-single-bar.k {
            background: #ffa726;
        }

        .qkv-single-bar.v {
            background: #66bb6a;
        }

        /* Processing label below Model Runner */
        .processing-label {
            position: absolute;
            top: 434px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #667eea;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .processing-label.show {
            opacity: 1;
        }

        /* Path boxes inside attention module */
        /* Classification substep box in attention backend */
        .classification-substep {
            padding: 6px 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.867em;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            color: #495057;
            transition: all 0.3s ease;
            line-height: 1.3;
            margin-top: 8px;
            width: 470px;
        }

        .classification-substep.active {
            background: rgba(102, 126, 234, 0.25);
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.4);
            transform: scale(1.05);
        }

        .path-container {
            display: flex;
            gap: 8px;
            margin-top: 95px;
        }

        .path-box {
            flex: 1;
            padding: 30px 6px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 1.0em;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .path-box.prefill {
            background: rgba(155, 89, 182, 0.15);
            border-color: #9b59b6;
            color: #7d3c98;
        }

        .path-box.extend {
            background: rgba(39, 174, 96, 0.15);
            border-color: #27ae60;
            color: #1e8449;
        }

        .path-box.decode {
            background: rgba(230, 126, 34, 0.15);
            border-color: #e67e22;
            color: #ca6f1e;
        }

        .path-box.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
            border-width: 3px;
        }

        /* Intermediate Data Boxes */
        .data-box {
            position: absolute;
            background: rgba(102, 126, 234, 0.95);
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 10px 14px;
            color: #ffffff;
            font-size: 0.75em;
            font-family: 'Courier New', monospace;
            z-index: 50;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.5s ease;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .data-box.show {
            opacity: 1;
            transform: scale(1);
        }

        .data-box .data-label {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .data-box .data-value {
            color: #e3e8f5;
            font-size: 0.95em;
        }

        /* Query start loc arrow indicator */
        .query-start-arrow {
            position: absolute;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 60;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .query-start-arrow.show {
            opacity: 1;
        }

        .query-start-arrow-head {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 10px solid #000000;
            margin-bottom: -1px;
        }

        .query-start-arrow-line {
            width: 2px;
            height: 10px;
            background: #000000;
        }

        .query-start-label {
            background: transparent;
            color: #000000;
            padding: 0;
            border-radius: 0;
            font-size: 0.8em;
            font-weight: bold;
            white-space: nowrap;
            margin-top: 5px;
        }

        /* QKV visual representation */
        .qkv-visual {
            display: flex;
            gap: 8px;
            margin-top: 5px;
            align-items: center;
        }

        .qkv-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .qkv-label {
            font-weight: bold;
            font-size: 0.85em;
            color: #ffffff;
        }

        .qkv-bar {
            width: 30px;
            height: 50px;
            border-radius: 4px;
            border: 2px solid #ffffff;
            position: relative;
            overflow: hidden;
        }

        .qkv-bar.q {
            background: linear-gradient(180deg, #ff6b9d 0%, #c44569 100%);
        }

        .qkv-bar.k {
            background: linear-gradient(180deg, #ffa726 0%, #fb8c00 100%);
        }

        .qkv-bar.v {
            background: linear-gradient(180deg, #66bb6a 0%, #43a047 100%);
        }

        .qkv-dimension {
            font-size: 0.7em;
            color: #ffffff;
            margin-top: 2px;
        }

        /* Classification Box */
        .classification-box {
            position: absolute;
            background: #ffffff;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 12px 16px;
            z-index: 50;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.5s ease;
            min-width: 300px;
        }

        .classification-box.show {
            opacity: 1;
            transform: scale(1);
        }

        .classification-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 0.85em;
            text-align: center;
        }

        .classification-options {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .classification-option {
            flex: 1;
            padding: 6px 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 0.7em;
            border: 2px solid transparent;
            opacity: 0.3;
            transition: all 0.3s ease;
        }

        .classification-option.prefill {
            background: rgba(155, 89, 182, 0.15);
            border-color: #9b59b6;
            color: #7d3c98;
        }

        .classification-option.extend {
            background: rgba(39, 174, 96, 0.15);
            border-color: #27ae60;
            color: #1e8449;
        }

        .classification-option.decode {
            background: rgba(230, 126, 34, 0.15);
            border-color: #e67e22;
            color: #ca6f1e;
        }

        .classification-option.selected {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
            border-width: 3px;
        }

        /* Moving Request Token */
        .request-token {
            position: absolute;
            padding: 10px 18px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.85em;
            color: white;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: none;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 450px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .request-token.text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .request-token.tokens {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .request-token.processing {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .request-token.output {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .request-token.show {
            display: block;
        }

        /* Test Request Squares */
        .test-request-square {
            position: absolute;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75em;
            color: white;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.8s ease;
            z-index: 100;
        }

        #testR1 { background: #26d0ce; } /* Light Teal */
        #testR2 { background: #1abc9c; } /* Medium Teal */
        #testR3 { background: #16a085; } /* Darker Teal */
        #testR4 { background: #138d75; } /* Even Darker */
        #testR5 { background: #117a65; } /* Darkest Teal */

        /* Completion message */
        .completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            padding: 40px 60px;
            border-radius: 20px;
            color: white;
            font-size: 2em;
            font-weight: bold;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            z-index: 200;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .completion-message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Animation -->
        <div class="left-panel">
            <div class="flow-diagram">
            <!-- Static Modules -->
            <div class="module" id="entrypoint">
                <div class="module-title">Entry Point</div>
            </div>

            <div class="module" id="scheduler">
                <div class="module-title">Scheduler</div>
            </div>

            <div class="module" id="modelrunner">
                <div class="module-title">Model Runner</div>
                <div class="substep-container">
                    <div class="substep-box" id="substep1">
                        Prepare Inputs
                    </div>
                    <div class="substep-box" id="substep2">
                        Compute query_start_loc
                    </div>
                    <div class="substep-box" id="substep3">
                        QKV Projection
                    </div>
                    <div class="substep-box" id="substep4">
                        Reorder Batch
                    </div>
                </div>
            </div>

            <!-- Processing label below Model Runner -->
            <!-- Input circle - dynamically positioned -->
            <div class="input-bar-container" id="inputBarContainer" style="position: absolute; width: 50px; height: 50px; opacity: 0; transform: translate(-50%, -50%);">
                <div class="input-bar" id="inputBar"></div>
            </div>

            <!-- Remaining tokens circle - stays on right side of scheduler -->
            <div class="input-bar-container" id="remainingTokensContainer" style="position: absolute; width: 50px; height: 50px; opacity: 0; transform: translate(-50%, -50%);">
                <div class="input-bar" id="remainingTokensBar"></div>
            </div>

            <!-- QKV bars - Old static version removed, now created dynamically -->

            <div class="module" id="attention">
                <div class="module-title">ROCM_AITER_FA Backend</div>
                <div class="module-content">
                    <div class="classification-substep" id="classificationSubstep">
                        Classify Request Type
                    </div>
                    <div class="path-container">
                        <div class="path-box prefill" id="prefillPath">
                            <div>PREFILL PATH</div>
                        </div>
                        <div class="path-box extend" id="extendPath">
                            <div>EXTEND PATH</div>
                        </div>
                        <div class="path-box decode" id="decodePath">
                            <div>DECODE PATH</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="module" id="output">
                <div class="module-title">Output & Loop</div>
            </div>

            <!-- Query Start Loc Arrow Indicator -->
            <div class="query-start-arrow" id="queryStartArrow" style="position: absolute;">
                <div class="query-start-arrow-head"></div>
                <div class="query-start-arrow-line"></div>
                <div class="query-start-label" id="queryStartLabel">query_start_loc: [0]</div>
            </div>

            <!-- Sampling Box (kept at Output) -->
            <div class="data-box" id="samplingBox" style="top: 768px; left: 50%; transform: translateX(-50%);">
                <div class="data-label">Sampling Check:</div>
                <div class="data-value" id="samplingData">-</div>
            </div>

            <!-- Classification Box - Removed, not used in multi-request animation -->

            <!-- Moving Request Token -->
            <div class="request-token" id="requestToken"></div>

            <!-- Test: Multiple Request Squares -->
            <div class="test-request-square" id="testR1" style="opacity: 0;">R1</div>
            <div class="test-request-square" id="testR2" style="opacity: 0;">R2</div>
            <div class="test-request-square" id="testR3" style="opacity: 0;">R3</div>
            <div class="test-request-square" id="testR4" style="opacity: 0;">R4</div>
            <div class="test-request-square" id="testR5" style="opacity: 0;">R5</div>

            <!-- Completion Message -->
            <div class="completion-message" id="completionMessage">
                ✅ Generation Complete!<br>
                <div style="font-size: 0.6em; margin-top: 10px;">"Hallucinations significantly decreased"</div>
            </div>
        </div>
        </div>

        <!-- Right Panel: Info -->
        <div class="right-panel">
            <div class="panel-layout">
                <!-- Left: Controls Column -->
                <div class="control-column">
                    <div class="controls">
                        <div class="iteration-select-wrapper">
                            <label for="startIterationSelect" class="iteration-select-label">Start from:</label>
                            <select id="startIterationSelect" class="iteration-select">
                                <option value="1" selected>Iteration 1</option>
                                <option value="2">Iteration 2</option>
                                <option value="3">Iteration 3</option>
                                <option value="4">Iteration 4</option>
                                <option value="5">Iteration 5</option>
                                <option value="6">Iteration 6</option>
                                <option value="7">Iteration 7</option>
                            </select>
                        </div>
                        <button class="control-btn start" id="startBtn" onclick="startAnimation()">▶️ Start</button>
                        <button class="control-btn pause" id="pauseBtn" onclick="togglePause()" disabled>⏸️ Pause</button>
                    </div>
                    <div class="keyboard-hint">Press spacebar to pause/resume</div>
                </div>

                <!-- Timeline Visualization -->
                <div class="timeline-container">
                    <div class="timeline-grid">
                        <!-- Time Axis Row (Top) -->
                        <div class="timeline-time-axis"></div>
                        <div class="timeline-time-axis">
                            <div class="arrival-label request-1-text">R1</div>
                            <div class="arrival-marker">▼</div>
                        </div>
                        <div class="timeline-time-axis">
                            <div class="arrival-label arrival-label-late request-2-text">R2</div>
                            <div class="arrival-marker arrival-marker-late">▼</div>
                        </div>
                        <div class="timeline-time-axis">
                            <div class="arrival-label arrival-label-early request-3-text">R3</div>
                            <div class="arrival-marker arrival-marker-early">▼</div>
                            <div class="arrival-label arrival-label-late request-4-text">R4</div>
                            <div class="arrival-marker arrival-marker-late">▼</div>
                        </div>
                        <div class="timeline-time-axis">
                            <div class="arrival-label request-5-text">R5</div>
                            <div class="arrival-marker">▼</div>
                        </div>
                        <div class="timeline-time-axis"></div>
                        <div class="timeline-time-axis"></div>
                        <div class="timeline-time-axis"></div>
                        <div class="timeline-time-axis"></div>
                        <div class="timeline-time-axis"></div>

                        <!-- Time Axis Arrow -->
                        <div class="time-axis-arrow"><span class="time-label">Time</span></div>

                        <!-- Request 1 Row -->
                        <div class="timeline-request-label request-1-color">R1</div>
                        <div class="timeline-cell empty" data-request="1" data-step="0"></div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="1" data-stage="prefill" id="timeline-r1-s1">P</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="2" data-stage="decode" id="timeline-r1-s2">D</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="3" data-stage="decode" id="timeline-r1-s3">D</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="4" data-stage="decode" id="timeline-r1-s4">D</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="5" data-stage="decode" id="timeline-r1-s5">D</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="6" data-stage="decode" id="timeline-r1-s6">D</div>
                        <div class="timeline-cell request-1-color" data-request="1" data-step="7" data-stage="decode" id="timeline-r1-s7">D</div>
                        <div class="timeline-cell dots">...</div>

                        <!-- Request 2 Row -->
                        <div class="timeline-request-label request-2-color">R2</div>
                        <div class="timeline-cell empty" data-request="2" data-step="0"></div>
                        <div class="timeline-cell empty" data-request="2" data-step="1"></div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="2" data-stage="prefill" id="timeline-r2-s2">P</div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="3" data-stage="decode" id="timeline-r2-s3">D</div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="4" data-stage="decode" id="timeline-r2-s4">D</div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="5" data-stage="decode" id="timeline-r2-s5">D</div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="6" data-stage="decode" id="timeline-r2-s6">D</div>
                        <div class="timeline-cell request-2-color" data-request="2" data-step="7" data-stage="decode" id="timeline-r2-s7">D</div>
                        <div class="timeline-cell dots">...</div>

                        <!-- Request 3 Row -->
                        <div class="timeline-request-label request-3-color">R3</div>
                        <div class="timeline-cell empty" data-request="3" data-step="0"></div>
                        <div class="timeline-cell empty" data-request="3" data-step="1"></div>
                        <div class="timeline-cell empty" data-request="3" data-step="2"></div>
                        <div class="timeline-cell request-3-color" data-request="3" data-step="3" data-stage="prefill" id="timeline-r3-s3">P</div>
                        <div class="timeline-cell request-3-color" data-request="3" data-step="4" data-stage="extend" id="timeline-r3-s4">E</div>
                        <div class="timeline-cell request-3-color" data-request="3" data-step="5" data-stage="extend" id="timeline-r3-s5">E</div>
                        <div class="timeline-cell request-3-color" data-request="3" data-step="6" data-stage="decode" id="timeline-r3-s6">D</div>
                        <div class="timeline-cell request-3-color" data-request="3" data-step="7" data-stage="decode" id="timeline-r3-s7">D</div>
                        <div class="timeline-cell dots">...</div>

                        <!-- Request 4 Row -->
                        <div class="timeline-request-label request-4-color">R4</div>
                        <div class="timeline-cell empty" data-request="4" data-step="0"></div>
                        <div class="timeline-cell empty" data-request="4" data-step="1"></div>
                        <div class="timeline-cell empty" data-request="4" data-step="2"></div>
                        <div class="timeline-cell request-4-color" data-request="4" data-step="3" data-stage="prefill" id="timeline-r4-s3">P</div>
                        <div class="timeline-cell request-4-color" data-request="4" data-step="4" data-stage="decode" id="timeline-r4-s4">D</div>
                        <div class="timeline-cell request-4-color" data-request="4" data-step="5" data-stage="decode" id="timeline-r4-s5">D</div>
                        <div class="timeline-cell request-4-color" data-request="4" data-step="6" data-stage="decode" id="timeline-r4-s6">D</div>
                        <div class="timeline-cell request-4-color" data-request="4" data-step="7" data-stage="decode" id="timeline-r4-s7">D</div>
                        <div class="timeline-cell dots">...</div>

                        <!-- Request 5 Row -->
                        <div class="timeline-request-label request-5-color">R5</div>
                        <div class="timeline-cell empty" data-request="5" data-step="0"></div>
                        <div class="timeline-cell empty" data-request="5" data-step="1"></div>
                        <div class="timeline-cell empty" data-request="5" data-step="2"></div>
                        <div class="timeline-cell empty" data-request="5" data-step="3"></div>
                        <div class="timeline-cell request-5-color" data-request="5" data-step="4" data-stage="prefill" id="timeline-r5-s4">P</div>
                        <div class="timeline-cell request-5-color" data-request="5" data-step="5" data-stage="extend" id="timeline-r5-s5">E</div>
                        <div class="timeline-cell request-5-color" data-request="5" data-step="6" data-stage="decode" id="timeline-r5-s6">D</div>
                        <div class="timeline-cell request-5-color" data-request="5" data-step="7" data-stage="decode" id="timeline-r5-s7">D</div>
                        <div class="timeline-cell dots">...</div>

                        <!-- Step Labels Row (Bottom) -->
                        <div class="timeline-step-label"></div>
                        <div class="timeline-step-label"></div>
                        <div class="timeline-step-label">Step 1</div>
                        <div class="timeline-step-label">Step 2</div>
                        <div class="timeline-step-label">Step 3</div>
                        <div class="timeline-step-label">Step 4</div>
                        <div class="timeline-step-label">Step 5</div>
                        <div class="timeline-step-label">Step 6</div>
                        <div class="timeline-step-label">Step 7</div>
                        <div class="timeline-step-label">...</div>
                    </div>

                    <!-- Timeline Highlight Rectangle -->
                    <div id="timelineHighlightRect" class="timeline-highlight-rect hidden"></div>
                </div>

                <!-- Right: Info Column -->
                <div class="info-column">
                    <div class="info-section">
                <div class="info-title" id="iterationStepTitle">Iteration step: -</div>
                <div class="requests-table">
                    <div class="table-header">
                        <div class="header-cell field-label"></div>
                        <div class="header-cell">R1</div>
                        <div class="header-cell">R2</div>
                        <div class="header-cell">R3</div>
                        <div class="header-cell">R4</div>
                        <div class="header-cell">R5</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Input</div>
                        <div class="cell" id="r1-input">-</div>
                        <div class="cell" id="r2-input">-</div>
                        <div class="cell" id="r3-input">-</div>
                        <div class="cell" id="r4-input">-</div>
                        <div class="cell" id="r5-input">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Output</div>
                        <div class="cell" id="r1-output">-</div>
                        <div class="cell" id="r2-output">-</div>
                        <div class="cell" id="r3-output">-</div>
                        <div class="cell" id="r4-output">-</div>
                        <div class="cell" id="r5-output">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Starts</div>
                        <div class="cell" id="r1-start-iter">-</div>
                        <div class="cell" id="r2-start-iter">-</div>
                        <div class="cell" id="r3-start-iter">-</div>
                        <div class="cell" id="r4-start-iter">-</div>
                        <div class="cell" id="r5-start-iter">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Path</div>
                        <div class="cell" id="r1-path">-</div>
                        <div class="cell" id="r2-path">-</div>
                        <div class="cell" id="r3-path">-</div>
                        <div class="cell" id="r4-path">-</div>
                        <div class="cell" id="r5-path">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Path History</div>
                        <div class="cell" id="r1-path-history">-</div>
                        <div class="cell" id="r2-path-history">-</div>
                        <div class="cell" id="r3-path-history">-</div>
                        <div class="cell" id="r4-path-history">-</div>
                        <div class="cell" id="r5-path-history">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Prefill Token Threshold</div>
                        <div class="cell" id="r1-token-budget">100</div>
                        <div class="cell" id="r2-token-budget">100</div>
                        <div class="cell" id="r3-token-budget">100</div>
                        <div class="cell" id="r4-token-budget">100</div>
                        <div class="cell" id="r5-token-budget">100</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Prompt Tokens</div>
                        <div class="cell" id="r1-prompt-tokens">-</div>
                        <div class="cell" id="r2-prompt-tokens">-</div>
                        <div class="cell" id="r3-prompt-tokens">-</div>
                        <div class="cell" id="r4-prompt-tokens">-</div>
                        <div class="cell" id="r5-prompt-tokens">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Remaining Tokens</div>
                        <div class="cell" id="r1-remaining-tokens">-</div>
                        <div class="cell" id="r2-remaining-tokens">-</div>
                        <div class="cell" id="r3-remaining-tokens">-</div>
                        <div class="cell" id="r4-remaining-tokens">-</div>
                        <div class="cell" id="r5-remaining-tokens">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Scheduled Tokens</div>
                        <div class="cell" id="r1-scheduled-tokens">-</div>
                        <div class="cell" id="r2-scheduled-tokens">-</div>
                        <div class="cell" id="r3-scheduled-tokens">-</div>
                        <div class="cell" id="r4-scheduled-tokens">-</div>
                        <div class="cell" id="r5-scheduled-tokens">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Computed Tokens</div>
                        <div class="cell" id="r1-computed-tokens">-</div>
                        <div class="cell" id="r2-computed-tokens">-</div>
                        <div class="cell" id="r3-computed-tokens">-</div>
                        <div class="cell" id="r4-computed-tokens">-</div>
                        <div class="cell" id="r5-computed-tokens">-</div>
                    </div>

                    <div class="table-row">
                        <div class="cell field-label">Output Tokens</div>
                        <div class="cell" id="r1-output-tokens">-</div>
                        <div class="cell" id="r2-output-tokens">-</div>
                        <div class="cell" id="r3-output-tokens">-</div>
                        <div class="cell" id="r4-output-tokens">-</div>
                        <div class="cell" id="r5-output-tokens">-</div>
                    </div>
                    </div> <!-- Close requests-table -->
                </div> <!-- Close info-section -->
                </div> <!-- Close info-column -->
            </div> <!-- Close panel-layout -->
        </div> <!-- Close right-panel -->
    </div> <!-- Close container -->

    <script>
        let iteration = 0;
        let isRunning = false;
        let isPaused = false;
        let pausePromiseResolve = null;
        const maxIterations = 7;

        // Animation timing configuration
        // Adjust these values to change animation speed for different iterations
        const TIMING = {
            // Iteration 1 (Prefill) - slower for introduction
            iter1: {
                loop: 500,              // Loop animation timing (not used in iter1)
                scheduler: 500,         // Wait at scheduler (not used in iter1)
                schedulerInfo: 800,     // After updating scheduler info
                moveToModel: 800,       // Moving circle to Model Runner
                barTransform: 800,      // Circle to horizontal bar transformation
                queryArrow: 1000,       // query_start_loc arrow display
                beforeQKV: 500,         // Before QKV projection
                qkvTransform: 800,      // QKV transformation sleeps
                afterQKV: 500,          // After QKV substep clear
                moveToAttention: 800,   // Moving to attention backend
                classification: 500,    // Classification substep highlight
                colorChange: 500,       // QKV bar color change
                pathBox: 600,           // Path box highlight
                afterPathBox: 400,      // After removing path box highlight
                hideQKV: 500,           // After hiding QKV bars
                beforeOutput: 400,      // Before moving to output
                moveToOutput: 600,      // Moving to output box
                sampledToken: 500,      // Sampled token transformation
                sampling: 500           // Sampling check
            },
            // Iterations 2+ (Decode) - faster for repeated animations
            iter2plus: {
                loop: 600,              // Loop animation timing
                scheduler: 400,         // Wait at scheduler
                schedulerInfo: 400,     // After updating scheduler info
                moveToModel: 400,       // Moving circle to Model Runner
                barTransform: 400,      // Circle to horizontal bar transformation
                queryArrow: 400,        // query_start_loc arrow display
                beforeQKV: 400,         // Before QKV projection
                qkvTransform: 400,      // QKV transformation sleeps
                afterQKV: 400,          // After QKV substep clear
                moveToAttention: 400,   // Moving to attention backend
                classification: 400,    // Classification substep highlight
                colorChange: 400,       // QKV bar color change
                pathBox: 400,           // Path box highlight
                afterPathBox: 400,      // After removing path box highlight
                hideQKV: 400,           // After hiding QKV bars
                beforeOutput: 400,      // Before moving to output
                moveToOutput: 400,      // Moving to output box
                sampledToken: 400,      // Sampled token transformation
                sampling: 400           // Sampling check
            }
        };

        // Helper function to get timing value based on iteration
        function getTiming(index, key) {
            // Use slow timing for iteration 1 (Prefill) and iteration 2 (first Extend)
            // Use fast timing for iteration 3+ (second Extend and all Decode)
            const config = (index === 0 || index === 1) ? TIMING.iter1 : TIMING.iter2plus;
            return config[key];
        }

        // Helper function to get transition time string
        function getTransition(index, key) {
            return getTiming(index, key) / 1000 + 's';
        }

        // Helper function to highlight a value when it changes
        function highlightValue(elementId) {
            const element = document.getElementById(elementId);
            element.classList.add('highlight');
            setTimeout(() => {
                element.classList.remove('highlight');
            }, 800);
        }

        // ============================================================================
        // REQUEST ARRIVAL TIMING AND PATH SEQUENCES FOR ANIMATION
        // ============================================================================
        // IMPORTANT: Requests that arrive at the entry point in the middle of an
        // iteration will only start being processed by the scheduler in the NEXT iteration.
        //
        // REQUEST ARRIVAL TIMES:
        // - R1 arrives at the beginning of iteration 1
        // - R2 arrives at the middle of iteration 1
        // - R3 arrives at the middle of iteration 2
        // - R4 arrives at the middle of iteration 2, later than R3
        // - R5 arrives at the middle of iteration 3
        //
        // PATH SEQUENCES BY ITERATION (P=Prefill, E=Extend, D=Decode):
        // Note: R3 and R5 have longer prompt tokens (280 and 130), so they will have
        // Extend paths in the demo.
        //
        // Iteration 1:
        //   R1: P
        //
        // Iteration 2:
        //   R1: P D
        //   R2: P
        //
        // Iteration 3:
        //   R1: P D D
        //   R2: P D
        //   R3: P
        //   R4: P
        //
        // Iteration 4:
        //   R1: P D D D
        //   R2: P D D
        //   R3: P E
        //   R4: P D
        //
        // Iteration 5:
        //   R1: P D D D D
        //   R2: P D D D
        //   R3: P E E
        //   R4: P D D
        //   R5: P
        //
        // Iteration 6:
        //   R1: P D D D D D
        //   R2: P D D D D
        //   R3: P E E D
        //   R4: P D D D
        //   R5: P E
        //
        // Iteration 7:
        //   R1: P D D D D D D
        //   R2: P D D D D D
        //   R3: P E E D D
        //   R4: P D D D D
        //   R5: P E D
        //
        // COLOR SCHEME FOR REQUESTS:
        // All 5 requests will use the same color family (Teal/Cyan) with gradient
        // from light to dark to distinguish between them visually:
        //   R1: #26d0ce (Light Teal)    - Lightest shade
        //   R2: #1abc9c (Medium Teal)   -
        //   R3: #16a085 (Darker Teal)   -
        //   R4: #138d75 (Even Darker)   -
        //   R5: #117a65 (Darkest Teal)  - Darkest shade
        //
        // Note: Teal/Cyan family was chosen because it's unique and hasn't been
        // prominently used in the existing animation. Current colors in use:
        // - Purple (#9b59b6): Prefill path
        // - Orange (#e67e22): Decode path
        // - Green (#27ae60): Extend path
        // - Blue (#667eea): General UI, primary color
        // - Pink/Red (#ff6b9d, #e74c3c): QKV-Q, errors
        // ============================================================================

        // ============================================================================
        // CONFIGURATION OBJECTS - Centralized data for maintainability
        // ============================================================================

        // Request configurations
        const REQUESTS_CONFIG = [
            {
                id: 1,
                color: '#26d0ce',
                borderColor: '#1fb3b0',
                promptTokens: 4,
                input: 'Prompt engineering tips?',
                outputWords: ['Effective', 'prompt', 'engineering', 'for', 'large', 'language...'],
                arriveIteration: 1,
                arriveDelay: 0 // Arrives at start
            },
            {
                id: 2,
                color: '#1abc9c',
                borderColor: '#16a085',
                promptTokens: 60,
                input: 'I\'ve been experimenting with fine-tuning LLMs for my company\'s customer service application. We want the model to handle technical support queries...',
                outputWords: ['The', 'foundation', 'of', 'successful', 'domain...'],
                arriveIteration: 1,
                arriveDelay: 500 // Arrives during R1's QKV transformation
            },
            {
                id: 3,
                color: '#16a085',
                borderColor: '#138d75',
                promptTokens: 280,
                input: 'Our evaluation of the latest large language model across 12 benchmarks shows significant improvements in reasoning capabilities compared to previous generations...',
                outputWords: ['Hallucinations', 'significantly...'],
                arriveIteration: 2,
                arriveDelay: 200 // Arrives while R1/R2 move to Model Runner
            },
            {
                id: 4,
                color: '#138d75',
                borderColor: '#117a65',
                promptTokens: 30,
                input: 'Our team is debating whether to use a proprietary LLM API or deploy an open-source model for our healthcare application...',
                outputWords: ['Proprietary', 'vs.', 'Open-Source', 'LLMs...'],
                arriveIteration: 2,
                arriveDelay: 200 // Arrives during QKV movement to attention
            },
            {
                id: 5,
                color: '#117a65',
                borderColor: '#0e6655',
                promptTokens: 130,
                input: 'We\'ve just completed an 18-month study on LLM implementation in educational settings across 42 high schools and 7 universities...',
                outputWords: ['Our', 'comprehensive...'],
                arriveIteration: 3,
                arriveDelay: 0 // Arrives during QKV transformation
            }
        ];

        const PREFILL_TOKEN_THRESHOLD = 100;

        // Position configurations
        const POSITIONS = {
            entryLeft: 180,
            spacing: 75,
            startTop: 10,
            getRequestLeft: (index) => 180 + (index * 75)
        };

        // Iteration schedule - defines what each request does per iteration
        const ITERATION_SCHEDULE = [
            { // Iteration 1
                number: 1,
                requests: [
                    { id: 1, path: 'prefill', scheduledTokens: 4, computedTokens: 4, remainingTokens: 0 }
                ]
            },
            { // Iteration 2
                number: 2,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 5, remainingTokens: 0, outputTokens: 1 },
                    { id: 2, path: 'prefill', scheduledTokens: 60, computedTokens: 60, remainingTokens: 0 }
                ]
            },
            { // Iteration 3
                number: 3,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 6, remainingTokens: 0, outputTokens: 2 },
                    { id: 2, path: 'decode', scheduledTokens: 1, computedTokens: 61, remainingTokens: 0, outputTokens: 1 },
                    { id: 3, path: 'prefill', scheduledTokens: 100, computedTokens: 100, remainingTokens: 180, split: true },
                    { id: 4, path: 'prefill', scheduledTokens: 30, computedTokens: 30, remainingTokens: 0 }
                ]
            },
            { // Iteration 4
                number: 4,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 7, remainingTokens: 0, outputTokens: 3 },
                    { id: 2, path: 'decode', scheduledTokens: 1, computedTokens: 62, remainingTokens: 0, outputTokens: 2 },
                    { id: 3, path: 'extend', scheduledTokens: 100, computedTokens: 200, remainingTokens: 80, split: true },
                    { id: 4, path: 'decode', scheduledTokens: 1, computedTokens: 31, remainingTokens: 0, outputTokens: 1 },
                    { id: 5, path: 'prefill', scheduledTokens: 100, computedTokens: 100, remainingTokens: 30, split: true }
                ]
            },
            { // Iteration 5
                number: 5,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 8, remainingTokens: 0, outputTokens: 4 },
                    { id: 2, path: 'decode', scheduledTokens: 1, computedTokens: 63, remainingTokens: 0, outputTokens: 3 },
                    { id: 3, path: 'extend', scheduledTokens: 80, computedTokens: 280, remainingTokens: 0 },
                    { id: 4, path: 'decode', scheduledTokens: 1, computedTokens: 32, remainingTokens: 0, outputTokens: 2 },
                    { id: 5, path: 'extend', scheduledTokens: 30, computedTokens: 130, remainingTokens: 0 }
                ]
            },
            { // Iteration 6
                number: 6,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 9, remainingTokens: 0, outputTokens: 5 },
                    { id: 2, path: 'decode', scheduledTokens: 1, computedTokens: 64, remainingTokens: 0, outputTokens: 4 },
                    { id: 3, path: 'decode', scheduledTokens: 1, computedTokens: 281, remainingTokens: 0, outputTokens: 1 },
                    { id: 4, path: 'decode', scheduledTokens: 1, computedTokens: 33, remainingTokens: 0, outputTokens: 3 },
                    { id: 5, path: 'decode', scheduledTokens: 1, computedTokens: 131, remainingTokens: 0, outputTokens: 1 }
                ]
            },
            { // Iteration 7
                number: 7,
                requests: [
                    { id: 1, path: 'decode', scheduledTokens: 1, computedTokens: 10, remainingTokens: 0, outputTokens: 6 },
                    { id: 2, path: 'decode', scheduledTokens: 1, computedTokens: 65, remainingTokens: 0, outputTokens: 5 },
                    { id: 3, path: 'decode', scheduledTokens: 1, computedTokens: 282, remainingTokens: 0, outputTokens: 2 },
                    { id: 4, path: 'decode', scheduledTokens: 1, computedTokens: 34, remainingTokens: 0, outputTokens: 4 },
                    { id: 5, path: 'decode', scheduledTokens: 1, computedTokens: 132, remainingTokens: 0, outputTokens: 2 }
                ]
            }
        ];

        // Track request state across iterations
        const requestState = {};
        REQUESTS_CONFIG.forEach(req => {
            requestState[req.id] = {
                startIteration: null,
                pathHistory: [],
                outputWordIndex: 0,
                circle: null,
                square: null,
                currentTokens: 0
            };
        });

        // Old requestsData array removed - now using REQUESTS_CONFIG above

        /**
         * Clean up all dynamically created animation elements
         * Reusable function called both by startAnimation and resetAnimation
         */
        function cleanupAnimationElements() {
            // Reset optional elements with safety checks
            const requestToken = document.getElementById('requestToken');
            if (requestToken) {
                requestToken.classList.remove('show');
                requestToken.textContent = '';
            }

            const completionMessage = document.getElementById('completionMessage');
            if (completionMessage) completionMessage.classList.remove('show');

            const samplingBox = document.getElementById('samplingBox');
            if (samplingBox) samplingBox.classList.remove('show');

            const queryStartArrow = document.getElementById('queryStartArrow');
            if (queryStartArrow) queryStartArrow.classList.remove('show');

            const inputBarContainer = document.getElementById('inputBarContainer');
            if (inputBarContainer) inputBarContainer.style.opacity = '0';

            const inputBar = document.getElementById('inputBar');
            if (inputBar) {
                inputBar.style.width = '50px';
                inputBar.style.height = '50px';
                inputBar.style.borderRadius = '50%';
                inputBar.style.fontSize = '1.2em';
                inputBar.style.opacity = '1';
            }

            const classificationSubstep = document.getElementById('classificationSubstep');
            if (classificationSubstep) classificationSubstep.classList.remove('active');

            // Reset classification options
            document.querySelectorAll('.classification-option').forEach(opt => {
                opt.classList.remove('selected');
            });

            // Reset path highlights
            document.querySelectorAll('.path-box').forEach(box => {
                box.classList.remove('active');
            });

            // Reset substep box highlights
            document.querySelectorAll('.substep-box').forEach(box => {
                box.classList.remove('active');
            });

            // Remove all output tokens
            document.querySelectorAll('.output-token').forEach(token => {
                token.remove();
            });

            // Remove all dynamically created elements more thoroughly
            const flowDiagram = document.querySelector('.flow-diagram');
            if (flowDiagram) {
                // First, forcefully remove any dynamically created elements with position: absolute
                const allDivs = Array.from(flowDiagram.querySelectorAll('div'));
                allDivs.forEach(div => {
                    const isPositionAbsolute = window.getComputedStyle(div).position === 'absolute';
                    // Remove any absolute positioned divs that are direct children of flowDiagram
                    if (isPositionAbsolute && div.parentElement === flowDiagram) {
                        const staticIds = ['entrypoint', 'scheduler', 'modelrunner', 'attention', 'output',
                                         'prefillPath', 'extendPath', 'decodePath',
                                         'inputData', 'kvCacheData', 'outputData',
                                         'testR1', 'testR2', 'testR3', 'testR4', 'testR5',
                                         'completionMessage'];
                        if (!div.id || !staticIds.includes(div.id)) {
                            div.remove();
                        }
                    }
                });

                // Then do the general cleanup
                const children = Array.from(flowDiagram.children);
                const staticIds = [
                    'entrypoint', 'scheduler', 'modelrunner', 'attention', 'output',
                    'prefillPath', 'extendPath', 'decodePath',
                    'inputData', 'kvCacheData', 'outputData',
                    'testR1', 'testR2', 'testR3', 'testR4', 'testR5',
                    'completionMessage'
                ];

                children.forEach(elem => {
                    // Keep if it has an ID in the static list
                    if (elem.id && staticIds.includes(elem.id)) {
                        return;
                    }

                    // Keep if it has one of the keep classes
                    const keepClasses = ['module', 'path-box', 'data-box', 'test-request-square', 'completion-message'];
                    const hasKeepClass = keepClasses.some(cls => elem.classList.contains(cls));

                    if (!hasKeepClass) {
                        elem.remove();
                    }
                });
            }

            // Also reset test request squares to initial state
            const testSquares = ['testR1', 'testR2', 'testR3', 'testR4', 'testR5'];
            testSquares.forEach(id => {
                const square = document.getElementById(id);
                if (square) {
                    square.style.opacity = '0';
                    square.style.transition = 'none';
                }
            });

            // Reset iteration step title
            document.getElementById('iterationStepTitle').textContent = 'Iteration step: -';

            // Reset info panel for all requests (R1-R5)
            for (let i = 1; i <= 5; i++) {
                document.getElementById(`r${i}-input`).textContent = '-';
                document.getElementById(`r${i}-output`).textContent = '-';
                document.getElementById(`r${i}-start-iter`).textContent = '-';
                document.getElementById(`r${i}-path`).textContent = '-';
                document.getElementById(`r${i}-path-history`).textContent = '-';
                document.getElementById(`r${i}-prompt-tokens`).textContent = '-';
                document.getElementById(`r${i}-remaining-tokens`).textContent = '-';
                document.getElementById(`r${i}-scheduled-tokens`).textContent = '-';
                document.getElementById(`r${i}-computed-tokens`).textContent = '-';
                document.getElementById(`r${i}-output-tokens`).textContent = '-';
            }
        }

        function resetAnimation() {
            iteration = 0;
            isRunning = false;
            isPaused = false;
            pausePromiseResolve = null;

            // Hide timeline highlight on reset
            hideTimelineHighlight();

            // Reset buttons
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const startIterationSelect = document.getElementById('startIterationSelect');
            if (startBtn) startBtn.disabled = false;
            if (pauseBtn) {
                pauseBtn.disabled = true;
                pauseBtn.textContent = '⏸️ Pause';
            }
            if (startIterationSelect) startIterationSelect.disabled = false;

            // Clean up all animation elements
            cleanupAnimationElements();

            // Auto-start animation after reset with a small delay
            // This ensures all parallel animations have fully stopped before restarting
            setTimeout(() => {
                startAnimation();
            }, 100);
        }

        let cumulativeOutput = [];
        let pathHistory = [];

        // ============================================================================
        // REUSABLE ANIMATION HELPER FUNCTIONS
        // ============================================================================

        // Update info panel for a request
        function updateInfoPanel(requestId, updates) {
            const prefix = `r${requestId}`;
            Object.keys(updates).forEach(key => {
                const elementId = `${prefix}-${key}`;
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = updates[key];
                    highlightValue(elementId);
                }
            });
        }

        // Create a request square at entry point
        function createRequestSquare(requestConfig, flowDiagram, flowRect, entryTop) {
            const square = document.createElement('div');
            square.style.position = 'absolute';
            square.style.width = '35px';
            square.style.height = '35px';
            square.style.background = requestConfig.color;
            square.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            square.style.borderRadius = '6px';
            square.style.display = 'flex';
            square.style.alignItems = 'center';
            square.style.justifyContent = 'center';
            square.style.fontWeight = 'bold';
            square.style.color = 'white';
            square.style.fontSize = '0.85em';
            square.textContent = `R${requestConfig.id}`;
            square.style.zIndex = '50';

            const left = POSITIONS.getRequestLeft(requestConfig.id - 1);
            square.style.left = left + 'px';
            square.style.top = POSITIONS.startTop + 'px';
            square.style.transform = 'translate(-50%, 0)';

            flowDiagram.appendChild(square);

            // Update info panel
            updateInfoPanel(requestConfig.id, { input: requestConfig.input });

            return { square, left };
        }

        // Transform square into token circle
        function createTokenCircle(requestConfig, left, top, flowDiagram) {
            const circle = document.createElement('div');
            circle.style.position = 'absolute';
            circle.style.width = '35px';
            circle.style.height = '35px';
            circle.style.background = requestConfig.color;
            circle.style.borderRadius = '50%';
            circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            circle.style.display = 'flex';
            circle.style.alignItems = 'center';
            circle.style.justifyContent = 'center';
            circle.style.fontSize = '1.2em';
            circle.style.fontWeight = 'bold';
            circle.style.color = 'white';
            circle.style.zIndex = '70';
            circle.textContent = requestConfig.promptTokens.toString();
            circle.style.left = left + 'px';
            circle.style.top = top + 'px';
            circle.style.transform = 'translate(-50%, 0)';
            circle.style.opacity = '0';

            flowDiagram.appendChild(circle);

            return circle;
        }

        // Cross-fade from square to circle
        async function crossFadeToCircle(square, circle) {
            square.style.transition = 'opacity 0.5s ease';
            square.style.opacity = '0';
            circle.style.transition = 'opacity 0.5s ease';
            circle.style.opacity = '1';

            await sleep(500);
            square.remove();
        }

        // Get module position
        function getModulePosition(moduleId, flowRect) {
            const module = document.getElementById(moduleId);
            const rect = module.getBoundingClientRect();
            return {
                left: rect.left - flowRect.left + rect.width / 2,
                top: rect.top - flowRect.top + rect.height / 2
            };
        }

        // Move element to position
        function moveElementTo(element, left, top, transition = '0.8s') {
            element.style.transition = `all ${transition} ease`;
            element.style.left = left + 'px';
            element.style.top = top + 'px';
        }

        // Get path box color
        function getPathColor(path) {
            const colors = {
                'prefill': '#764ba2',
                'extend': '#667eea',
                'decode': '#f093fb'
            };
            return colors[path] || '#667eea';
        }

        // Get path box element
        function getPathBoxElement(path) {
            const pathIds = {
                'prefill': 'prefillPath',
                'extend': 'extendPath',
                'decode': 'decodePath'
            };
            return document.getElementById(pathIds[path]);
        }

        // ============================================
        // TIMELINE HIGHLIGHT FUNCTIONS (Phase 2)
        // ============================================

        /**
         * Calculate the bounding box for a step column in the timeline
         * @param {number} step - The step number (1-7)
         * @returns {object|null} - { left, top, width, height } or null if not found
         */
        function getStepColumnBounds(step) {
            // Get the timeline container for calculating relative positions
            const container = document.querySelector('.timeline-container');
            if (!container) {
                console.error('Timeline container not found');
                return null;
            }

            const containerRect = container.getBoundingClientRect();

            // Find any cell from this step column to get x-position and width
            const cell = document.querySelector(`[data-step="${step}"]:not(.empty)`);
            if (!cell) {
                console.error(`No cell found for step ${step}`);
                return null;
            }

            const cellRect = cell.getBoundingClientRect();

            // Find the first and last request rows to calculate height span
            // We have 5 requests (R1-R5), need to span all of them
            const firstCell = document.querySelector('[data-request="1"][data-step="' + step + '"]');
            const lastCell = document.querySelector('[data-request="5"][data-step="' + step + '"]');

            if (!firstCell || !lastCell) {
                console.error(`Could not find first or last cell for step ${step}`);
                return null;
            }

            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();

            // Calculate bounds relative to container
            // Add some padding (5px) above and below for visual spacing
            const padding = 5;
            const gridGap = 2; // Timeline grid has gap: 2px

            return {
                left: cellRect.left - containerRect.left - gridGap / 2,
                top: firstRect.top - containerRect.top - padding,
                width: cellRect.width + gridGap,
                height: lastRect.bottom - firstRect.top + (padding * 2)
            };
        }

        // ============================================
        // TIMELINE HIGHLIGHT FUNCTIONS (Phase 3)
        // ============================================

        // Global variable to track current highlighted step
        let currentHighlightStep = null;

        /**
         * Show timeline highlight rectangle on a specific step
         * @param {number} step - The step number (1-7) to highlight
         */
        function showTimelineHighlight(step) {
            const rect = document.getElementById('timelineHighlightRect');
            if (!rect) {
                console.error('Timeline highlight rectangle not found');
                return;
            }

            const bounds = getStepColumnBounds(step);
            if (!bounds) {
                console.warn(`Cannot show highlight for step ${step} - bounds not found`);
                hideTimelineHighlight();
                return;
            }

            // Position and size the rectangle
            rect.style.left = bounds.left + 'px';
            rect.style.top = bounds.top + 'px';
            rect.style.width = bounds.width + 'px';
            rect.style.height = bounds.height + 'px';

            // Show the rectangle (CSS transition will animate if moving)
            rect.classList.remove('hidden');

            // Track current step for resize handling
            currentHighlightStep = step;
        }

        /**
         * Hide the timeline highlight rectangle
         */
        function hideTimelineHighlight() {
            const rect = document.getElementById('timelineHighlightRect');
            if (rect) {
                rect.classList.add('hidden');
                currentHighlightStep = null;
            }
        }

        /**
         * Move timeline highlight to a new step (smooth transition via CSS)
         * @param {number} step - The step number (1-7) to move to
         */
        function moveTimelineHighlight(step) {
            // Just call show - CSS transition handles smooth movement
            showTimelineHighlight(step);
        }

        // Update path history
        function updatePathHistory(requestId, path) {
            const pathLetter = path.charAt(0).toUpperCase();
            const state = requestState[requestId];
            state.pathHistory.push(pathLetter);
            updateInfoPanel(requestId, { 'path-history': state.pathHistory.join('') });
        }

        // Get output text for request
        function getOutputText(requestId, wordIndex) {
            const config = REQUESTS_CONFIG.find(r => r.id === requestId);
            if (!config) return '';
            return config.outputWords.slice(0, wordIndex + 1).join(' ');
        }

        // Get request config by ID
        function getRequestConfig(id) {
            return REQUESTS_CONFIG.find(r => r.id === id);
        }

        // ============================================================================
        // ADVANCED ANIMATION HELPER FUNCTIONS
        // ============================================================================

        // Animate request arrival: square appears, slides to entry, transforms to circle
        async function animateRequestArrival(requestId, flowDiagram, flowRect) {
            const config = getRequestConfig(requestId);
            const testSquare = document.getElementById(`testR${requestId}`);

            // Get positions
            const entryModule = document.getElementById('entrypoint');
            const entryRect = entryModule.getBoundingClientRect();
            const entryLeft = POSITIONS.getRequestLeft(requestId - 1);
            const entryTop = entryRect.top - flowRect.top + entryRect.height / 2 - 20;

            // Position square at top
            testSquare.style.transition = 'none';
            testSquare.style.left = entryLeft + 'px';
            testSquare.style.top = POSITIONS.startTop + 'px';
            testSquare.style.transform = 'translate(-50%, 0)';
            testSquare.style.opacity = '1';

            // Update info panel
            updateInfoPanel(requestId, { 'input': config.input });

            await sleep(500);

            // Slide down to entry point
            testSquare.style.transition = 'top 1.5s ease';
            testSquare.style.top = entryTop + 'px';

            await sleep(1500);

            // Create token circle
            const circle = createTokenCircle(config, entryLeft, entryTop, flowDiagram);

            // Cross-fade
            await crossFadeToCircle(testSquare, circle);

            return { circle, entryLeft };
        }

        // Move token circle from entry to scheduler and update info
        async function moveToSchedulerAndInit(requestId, circle, left, flowRect, iterNumber) {
            const config = getRequestConfig(requestId);
            const schedulerPos = getModulePosition('scheduler', flowRect);
            const schedulerTop = schedulerPos.top;

            await sleep(500);

            // Move to scheduler
            circle.style.transition = 'top 0.8s ease';
            circle.style.left = left + 'px';
            circle.style.top = schedulerTop + 'px';

            await sleep(800);

            // Initialize info panel at scheduler
            updateInfoPanel(requestId, {
                'start-iter': `Iter ${iterNumber}`,
                'prompt-tokens': config.promptTokens.toString(),
                'remaining-tokens': config.promptTokens.toString(),
                'scheduled-tokens': '0',
                'output-tokens': '0'
            });

            await sleep(500);

            return circle;
        }

        // Move circle to below Model Runner substep4 (Reorder Batch)
        async function moveToBelowModelRunner(circle, flowRect) {
            const substep4 = document.getElementById('substep4');
            const substep4Rect = substep4.getBoundingClientRect();
            const reorderBatchBottom = substep4Rect.bottom - flowRect.top;
            const gap = 5;
            const circleRadius = 35 / 2;
            const circleTopPosition = reorderBatchBottom + gap + circleRadius - 20;

            await sleep(500);

            circle.style.transition = 'top 0.8s ease';
            circle.style.top = circleTopPosition + 'px';

            await sleep(800);
        }

        // Highlight a substep box
        async function highlightSubstep(substepId, duration = 500) {
            const substep = document.getElementById(substepId);
            if (substep) {
                substep.classList.add('active');
                await sleep(duration);
            }
        }

        // Clear substep highlight
        function clearSubstepHighlight(substepId) {
            const substep = document.getElementById(substepId);
            if (substep) {
                substep.classList.remove('active');
            }
        }

        // Transform circle into horizontal bar
        async function transformCircleToBar(circle, width = '470px', height = '25px') {
            circle.style.transition = 'all 0.6s ease';
            circle.style.left = '50%';
            circle.style.transform = 'translateX(-50%)';
            circle.style.width = width;
            circle.style.height = height;
            circle.style.borderRadius = '4px';
            circle.style.fontSize = '0.9em';

            await sleep(600);
        }

        // Get position below a substep box
        function getPositionBelowSubstep(substepId, flowRect) {
            const substep = document.getElementById(substepId);
            const substepRect = substep.getBoundingClientRect();
            const bottom = substepRect.bottom - flowRect.top;
            const gap = 5;
            const radius = 35 / 2;
            return bottom + gap + radius - 20;
        }

        // Create and append QKV bars to a container
        function createQKVBars(container, segmentColors, segmentWidths) {
            const rows = ['Q', 'K', 'V'];

            rows.forEach(rowName => {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '0';
                row.style.height = '25px';

                segmentColors.forEach((color, idx) => {
                    const segment = document.createElement('div');
                    segment.style.background = color;
                    segment.style.width = segmentWidths[idx] + 'px';
                    segment.style.height = '100%';
                    segment.style.display = 'flex';
                    segment.style.alignItems = 'center';
                    segment.style.justifyContent = 'center';
                    segment.style.color = 'white';
                    segment.style.fontSize = '0.75em';
                    segment.style.fontWeight = 'bold';

                    if (idx === 0) segment.style.borderTopLeftRadius = '4px';
                    if (idx === 0) segment.style.borderBottomLeftRadius = '4px';
                    if (idx === segmentColors.length - 1) segment.style.borderTopRightRadius = '4px';
                    if (idx === segmentColors.length - 1) segment.style.borderBottomRightRadius = '4px';

                    row.appendChild(segment);
                });

                container.appendChild(row);
            });
        }

        // Highlight path box
        async function highlightPathBox(path, duration = 600) {
            const pathBox = getPathBoxElement(path);
            if (pathBox) {
                pathBox.classList.add('active');
                await sleep(duration);
                pathBox.classList.remove('active');
            }
        }

        // Get iteration config by number
        function getIterationConfig(iterNumber) {
            return ITERATION_SCHEDULE.find(iter => iter.number === iterNumber);
        }

        // Initialize request at scheduler (first time arriving)
        function initializeRequestAtScheduler(requestId, iterNumber) {
            const config = getRequestConfig(requestId);
            const state = requestState[requestId];

            if (state.startIteration === null) {
                state.startIteration = iterNumber;
                updateInfoPanel(requestId, {
                    'start-iter': `Iter ${iterNumber}`,
                    'prompt-tokens': config.promptTokens.toString(),
                    'computed-tokens': '0',
                    'remaining-tokens': config.promptTokens.toString(),
                    'scheduled-tokens': '0',
                    'output-tokens': '0'
                });
            }
        }

        // Update info panel for iteration
        function updateIterationInfo(iterNumber, requestUpdates) {
            document.getElementById('iterationStepTitle').textContent = `Iteration step: ${iterNumber}`;

            requestUpdates.forEach(update => {
                const { id, ...fields } = update;
                updateInfoPanel(id, fields);
            });
        }

        // ============================================================================
        // ITERATION INITIALIZATION FUNCTIONS
        // ============================================================================

        // OLD: Initialize visual state for starting from a specific iteration
        // This function is currently not used but kept for future refactoring
        async function initializeForIteration_UNUSED(iterNumber, sharedVars) {
            const flowDiagram = document.querySelector('.flow-diagram');
            const flowRect = flowDiagram.getBoundingClientRect();
            const schedulerModule = document.getElementById('scheduler');
            const schedulerRect = schedulerModule.getBoundingClientRect();

            // For Iteration 2: Set up state as if Iteration 1 completed
            if (iterNumber === 2) {
                // R1 has completed prefill in iteration 1
                // R2 arrived during iteration 1 and is waiting at scheduler

                // Create R1 as qkvBarsContainer (the result of iteration 1)
                const r1Config = getRequestConfig(1);
                const r1Container = document.createElement('div');
                r1Container.style.position = 'absolute';
                r1Container.style.width = '35px';
                r1Container.style.height = '35px';
                r1Container.style.background = r1Config.color;
                r1Container.style.borderRadius = '50%';
                r1Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                r1Container.style.display = 'flex';
                r1Container.style.alignItems = 'center';
                r1Container.style.justifyContent = 'center';
                r1Container.style.fontSize = '1.2em';
                r1Container.style.fontWeight = 'bold';
                r1Container.style.color = 'white';
                r1Container.style.zIndex = '70';
                r1Container.textContent = '1'; // 1 output token
                r1Container.style.left = POSITIONS.getRequestLeft(0) + 'px';
                r1Container.style.top = (schedulerRect.top - flowRect.top + schedulerRect.height / 2 - 20) + 'px';
                r1Container.style.transform = 'translate(-50%, 0)';
                flowDiagram.appendChild(r1Container);
                requestState[1].circle = r1Container;
                // Set as qkvBarsContainer for iteration 2 code
                sharedVars.qkvBarsContainer = r1Container;

                // Create R2 circle at scheduler
                const r2Config = getRequestConfig(2);
                const r2CircleElem = document.createElement('div');
                r2CircleElem.style.position = 'absolute';
                r2CircleElem.style.width = '35px';
                r2CircleElem.style.height = '35px';
                r2CircleElem.style.background = r2Config.color;
                r2CircleElem.style.borderRadius = '50%';
                r2CircleElem.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2CircleElem.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                r2CircleElem.style.display = 'flex';
                r2CircleElem.style.alignItems = 'center';
                r2CircleElem.style.justifyContent = 'center';
                r2CircleElem.style.fontSize = '1.2em';
                r2CircleElem.style.fontWeight = 'bold';
                r2CircleElem.style.color = 'white';
                r2CircleElem.style.zIndex = '70';
                r2CircleElem.textContent = r2Config.promptTokens.toString();
                r2CircleElem.style.left = POSITIONS.getRequestLeft(1) + 'px';
                r2CircleElem.style.top = (schedulerRect.top - flowRect.top + schedulerRect.height / 2 - 20) + 'px';
                r2CircleElem.style.transform = 'translate(-50%, 0)';
                flowDiagram.appendChild(r2CircleElem);
                requestState[2].circle = r2CircleElem;
                // Set as r2Circle for iteration 2 code
                sharedVars.r2Circle = r2CircleElem;

                // Set info panel for R1
                requestState[1].startIteration = 1;
                requestState[1].pathHistory = ['P'];
                requestState[1].outputWordIndex = 1;
                requestState[1].currentTokens = 5; // 4 prompt + 1 output
                updateInfoPanel(1, {
                    'input': r1Config.input,
                    'output': r1Config.outputWords[0], // First word
                    'start-iter': 'Iter 1',
                    'path': 'Prefill',
                    'path-history': 'P',
                    'prompt-tokens': '4',
                    'computed-tokens': '5',
                    'remaining-tokens': '0',
                    'scheduled-tokens': '0',
                    'output-tokens': '1'
                });

                // Set info panel for R2
                requestState[2].startIteration = 1;
                requestState[2].pathHistory = [];
                requestState[2].outputWordIndex = 0;
                requestState[2].currentTokens = 0;
                updateInfoPanel(2, {
                    'input': r2Config.input,
                    'output': '-',
                    'start-iter': 'Iter 1',
                    'path': '-',
                    'path-history': '-',
                    'prompt-tokens': r2Config.promptTokens.toString(),
                    'computed-tokens': '0',
                    'remaining-tokens': r2Config.promptTokens.toString(),
                    'scheduled-tokens': '0',
                    'output-tokens': '0'
                });
            }
        }

        // ============================================================================
        // State Management for Iteration Wrapping
        // ============================================================================

        /**
         * Initialize the animation state object that will be passed between iterations
         * @returns {Object} Complete state object with all shared data
         */
        function initializeAnimationState() {
            const flowDiagram = document.querySelector('.flow-diagram');
            const flowRect = flowDiagram.getBoundingClientRect();

            const entryModule = document.getElementById('entrypoint');
            const entryRect = entryModule.getBoundingClientRect();
            const entryLeft = 180;
            const entryTop = entryRect.top - flowRect.top + entryRect.height / 2 - 20;
            const startTop = 10;

            const schedulerModule = document.getElementById('scheduler');
            const schedulerRect = schedulerModule.getBoundingClientRect();
            const schedulerTop = schedulerRect.top - flowRect.top + schedulerRect.height / 2 - 20;

            return {
                // DOM elements that persist across iterations
                flowDiagram,
                flowRect,

                // Common layout values
                layout: {
                    entryLeft,
                    entryTop,
                    startTop,
                    schedulerTop,
                    spacing: 75
                },

                // Request circle references (key = request ID)
                circles: {
                    1: null,  // R1 circle/container
                    2: null,  // R2 circle
                    3: null,  // R3 circle
                    4: null,  // R4 circle
                    5: null   // R5 circle
                },

                // Special containers used across iterations
                containers: {
                    qkvBarsContainer: null,  // R1's container in later iterations
                    r1Container: null,
                    r2Container: null
                },

                // Substep references (cached for performance)
                substeps: {
                    substep1: document.getElementById('substep1'),
                    substep2: document.getElementById('substep2'),
                    substep3: document.getElementById('substep3'),
                    substep4: document.getElementById('substep4')
                },

                // Module references
                modules: {
                    scheduler: schedulerModule,
                    attention: document.getElementById('attention'),
                    classificationSubstep: document.getElementById('classificationSubstep')
                },

                // Path boxes
                pathBoxes: {
                    prefill: getPathBoxElement('prefill'),
                    extend: getPathBoxElement('extend'),
                    decode: getPathBoxElement('decode')
                }
            };
        }

        /**
         * Initialize visual state for iteration 2
         * Creates R1 and R2 circles with appropriate info panel states
         */
        async function initForIteration2(state) {
            const flowDiagram = state.flowDiagram;
            const flowRect = state.flowRect;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;

            // Create R1 as qkvBarsContainer (circle with "1")
            const r1Config = getRequestConfig(1);
            const r1Container = document.createElement('div');
            r1Container.style.position = 'absolute';
            r1Container.style.width = '35px';
            r1Container.style.height = '35px';
            r1Container.style.background = r1Config.color;
            r1Container.style.borderRadius = '50%';
            r1Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r1Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r1Container.style.display = 'flex';
            r1Container.style.alignItems = 'center';
            r1Container.style.justifyContent = 'center';
            r1Container.style.fontSize = '1.2em';
            r1Container.style.fontWeight = 'bold';
            r1Container.style.color = 'white';
            r1Container.style.zIndex = '100';
            r1Container.style.left = entryLeft + 'px';
            r1Container.style.top = schedulerTop + 'px';
            r1Container.style.transform = 'translate(-50%, 0)';
            r1Container.textContent = '1';

            flowDiagram.appendChild(r1Container);
            state.circles[1] = r1Container;
            state.containers.qkvBarsContainer = r1Container;

            // Set R1 info panel state (completed iteration 1)
            requestState[1].startIteration = 1;
            requestState[1].pathHistory = ['P'];
            requestState[1].outputWordIndex = 1;
            requestState[1].currentTokens = 5;
            updateInfoPanel(1, {
                'input': r1Config.input,
                'output': r1Config.outputWords[0],
                'start-iter': 'Iter 1',
                'path': 'Prefill',
                'path-history': 'P',
                'prompt-tokens': '4',
                'computed-tokens': '5',
                'remaining-tokens': '0',
                'scheduled-tokens': '0',
                'output-tokens': '1'
            });

            // Create R2 circle at scheduler
            const r2Config = getRequestConfig(2);
            const r2CircleElem = document.createElement('div');
            r2CircleElem.style.position = 'absolute';
            r2CircleElem.style.width = '35px';
            r2CircleElem.style.height = '35px';
            r2CircleElem.style.background = r2Config.color;
            r2CircleElem.style.borderRadius = '50%';
            r2CircleElem.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r2CircleElem.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r2CircleElem.style.display = 'flex';
            r2CircleElem.style.alignItems = 'center';
            r2CircleElem.style.justifyContent = 'center';
            r2CircleElem.style.fontSize = '1.2em';
            r2CircleElem.style.fontWeight = 'bold';
            r2CircleElem.style.color = 'white';
            r2CircleElem.style.zIndex = '100';
            r2CircleElem.style.left = (entryLeft + state.layout.spacing) + 'px';
            r2CircleElem.style.top = schedulerTop + 'px';
            r2CircleElem.style.transform = 'translate(-50%, 0)';
            r2CircleElem.textContent = r2Config.promptTokens.toString();

            flowDiagram.appendChild(r2CircleElem);
            state.circles[2] = r2CircleElem;

            // Set R2 info panel state (arrived at scheduler)
            requestState[2].startIteration = 1;
            requestState[2].pathHistory = [];
            requestState[2].outputWordIndex = 0;
            requestState[2].currentTokens = 0;
            updateInfoPanel(2, {
                'input': r2Config.input,
                'output': '-',
                'start-iter': '-',
                'path': '-',
                'path-history': '-',
                'prompt-tokens': r2Config.promptTokens.toString(),
                'computed-tokens': '0',
                'remaining-tokens': r2Config.promptTokens.toString(),
                'scheduled-tokens': '0',
                'output-tokens': '0'
            });
        }

        /**
         * Initialize visual state for iteration 3
         * Creates R1, R2 circles from iteration 2, and R3, R4 circles at scheduler
         */
        async function initForIteration3(state) {
            const flowDiagram = state.flowDiagram;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;
            const spacing = 75;

            // Create R1 circle (from iteration 2 output)
            const r1Config = getRequestConfig(1);
            const r1Container = document.createElement('div');
            r1Container.style.position = 'absolute';
            r1Container.style.width = '35px';
            r1Container.style.height = '35px';
            r1Container.style.background = r1Config.color;
            r1Container.style.borderRadius = '50%';
            r1Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r1Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r1Container.style.display = 'flex';
            r1Container.style.alignItems = 'center';
            r1Container.style.justifyContent = 'center';
            r1Container.style.fontSize = '1.2em';
            r1Container.style.fontWeight = 'bold';
            r1Container.style.color = 'white';
            r1Container.style.zIndex = '100';
            r1Container.style.left = entryLeft + 'px';
            r1Container.style.top = schedulerTop + 'px';
            r1Container.style.transform = 'translate(-50%, 0)';
            r1Container.textContent = '1';
            flowDiagram.appendChild(r1Container);
            state.containers.r1Container_iter2 = r1Container;

            // Create R2 circle (from iteration 2 output)
            const r2Config = getRequestConfig(2);
            const r2Container = document.createElement('div');
            r2Container.style.position = 'absolute';
            r2Container.style.width = '35px';
            r2Container.style.height = '35px';
            r2Container.style.background = r2Config.color;
            r2Container.style.borderRadius = '50%';
            r2Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r2Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r2Container.style.display = 'flex';
            r2Container.style.alignItems = 'center';
            r2Container.style.justifyContent = 'center';
            r2Container.style.fontSize = '1.2em';
            r2Container.style.fontWeight = 'bold';
            r2Container.style.color = 'white';
            r2Container.style.zIndex = '100';
            r2Container.style.left = (entryLeft + spacing) + 'px';
            r2Container.style.top = schedulerTop + 'px';
            r2Container.style.transform = 'translate(-50%, 0)';
            r2Container.textContent = '1';
            flowDiagram.appendChild(r2Container);
            state.containers.r2Container_iter2 = r2Container;

            // Create R3 circle at scheduler
            const r3Config = getRequestConfig(3);
            const r3Circle = document.createElement('div');
            r3Circle.style.position = 'absolute';
            r3Circle.style.width = '35px';
            r3Circle.style.height = '35px';
            r3Circle.style.background = r3Config.color;
            r3Circle.style.borderRadius = '50%';
            r3Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r3Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r3Circle.style.display = 'flex';
            r3Circle.style.alignItems = 'center';
            r3Circle.style.justifyContent = 'center';
            r3Circle.style.fontSize = '1.2em';
            r3Circle.style.fontWeight = 'bold';
            r3Circle.style.color = 'white';
            r3Circle.style.zIndex = '100';
            r3Circle.style.left = (entryLeft + spacing * 2) + 'px';
            r3Circle.style.top = schedulerTop + 'px';
            r3Circle.style.transform = 'translate(-50%, 0)';
            r3Circle.textContent = r3Config.promptTokens.toString();
            flowDiagram.appendChild(r3Circle);
            state.circles[3] = r3Circle;

            // Create R4 circle at scheduler
            const r4Config = getRequestConfig(4);
            const r4Circle = document.createElement('div');
            r4Circle.style.position = 'absolute';
            r4Circle.style.width = '35px';
            r4Circle.style.height = '35px';
            r4Circle.style.background = r4Config.color;
            r4Circle.style.borderRadius = '50%';
            r4Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r4Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r4Circle.style.display = 'flex';
            r4Circle.style.alignItems = 'center';
            r4Circle.style.justifyContent = 'center';
            r4Circle.style.fontSize = '1.2em';
            r4Circle.style.fontWeight = 'bold';
            r4Circle.style.color = 'white';
            r4Circle.style.zIndex = '100';
            r4Circle.style.left = (entryLeft + spacing * 3) + 'px';
            r4Circle.style.top = schedulerTop + 'px';
            r4Circle.style.transform = 'translate(-50%, 0)';
            r4Circle.textContent = r4Config.promptTokens.toString();
            flowDiagram.appendChild(r4Circle);
            state.circles[4] = r4Circle;

            // Set info panel states (after iteration 2 completes)
            updateInfoPanel(1, {
                'input': r1Config.input,
                'output': r1Config.outputWords.slice(0, 2).join(' '),
                'start-iter': 'Iter 1',
                'path': 'Decode',
                'path-history': 'PD',
                'prompt-tokens': '4',
                'computed-tokens': '6',
                'remaining-tokens': '0',
                'scheduled-tokens': '0',
                'output-tokens': '2'
            });

            updateInfoPanel(2, {
                'input': r2Config.input,
                'output': r2Config.outputWords[0],
                'start-iter': 'Iter 2',
                'path': 'Prefill',
                'path-history': 'P',
                'prompt-tokens': '60',
                'computed-tokens': '61',
                'remaining-tokens': '0',
                'scheduled-tokens': '0',
                'output-tokens': '1'
            });

            updateInfoPanel(3, {
                'input': r3Config.input,
                'output': '-',
                'start-iter': '-',
                'path': '-',
                'path-history': '-',
                'prompt-tokens': '280',
                'computed-tokens': '0',
                'remaining-tokens': '280',
                'scheduled-tokens': '0',
                'output-tokens': '0'
            });

            updateInfoPanel(4, {
                'input': r4Config.input,
                'output': '-',
                'start-iter': '-',
                'path': '-',
                'path-history': '-',
                'prompt-tokens': '30',
                'computed-tokens': '0',
                'remaining-tokens': '30',
                'scheduled-tokens': '0',
                'output-tokens': '0'
            });
        }

        /**
         * Initialize visual state for iteration 4
         * Creates R1-R4 square tokens, R5 circle, and R3 remaining circle at scheduler
         */
        async function initForIteration4(state) {
            const flowDiagram = state.flowDiagram;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;
            const spacing = 75;

            // Create R1-R4 square tokens at scheduler (these came from iteration 3)
            const squareSize = 30;
            for (let i = 1; i <= 4; i++) {
                const rConfig = getRequestConfig(i);
                const squareToken = document.createElement('div');
                squareToken.style.position = 'absolute';
                squareToken.style.width = squareSize + 'px';
                squareToken.style.height = squareSize + 'px';
                squareToken.style.background = rConfig.color;
                squareToken.style.borderRadius = '4px';
                squareToken.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                squareToken.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
                squareToken.style.display = 'flex';
                squareToken.style.alignItems = 'center';
                squareToken.style.justifyContent = 'center';
                squareToken.style.fontSize = '0.9em';
                squareToken.style.fontWeight = 'bold';
                squareToken.style.color = 'white';
                squareToken.style.zIndex = '100';
                squareToken.style.left = (entryLeft + (i - 1) * spacing) + 'px';
                squareToken.style.top = schedulerTop + 'px';
                squareToken.style.transform = 'translate(-50%, 0)';
                squareToken.textContent = '1';
                flowDiagram.appendChild(squareToken);
                state.containers[`r${i}Container`] = squareToken;
            }

            // Create R5 circle at scheduler
            const r5Config = getRequestConfig(5);
            const r5Circle = document.createElement('div');
            r5Circle.style.position = 'absolute';
            r5Circle.style.width = '35px';
            r5Circle.style.height = '35px';
            r5Circle.style.background = r5Config.color;
            r5Circle.style.borderRadius = '50%';
            r5Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            r5Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r5Circle.style.display = 'flex';
            r5Circle.style.alignItems = 'center';
            r5Circle.style.justifyContent = 'center';
            r5Circle.style.fontSize = '1.2em';
            r5Circle.style.fontWeight = 'bold';
            r5Circle.style.color = 'white';
            r5Circle.style.zIndex = '100';
            r5Circle.style.left = (entryLeft + 4 * spacing) + 'px';
            r5Circle.style.top = schedulerTop + 'px';
            r5Circle.style.transform = 'translate(-50%, 0)';
            r5Circle.textContent = '130';
            flowDiagram.appendChild(r5Circle);
            state.circles[5] = r5Circle;

            // Create R3 remaining circle (grey) at scheduler
            const r3RemainingCircle = document.createElement('div');
            r3RemainingCircle.style.position = 'absolute';
            r3RemainingCircle.style.width = '35px';
            r3RemainingCircle.style.height = '35px';
            r3RemainingCircle.style.background = '#555';
            r3RemainingCircle.style.borderRadius = '50%';
            r3RemainingCircle.style.border = '2px solid rgba(255, 255, 255, 0.5)';
            r3RemainingCircle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r3RemainingCircle.style.display = 'flex';
            r3RemainingCircle.style.alignItems = 'center';
            r3RemainingCircle.style.justifyContent = 'center';
            r3RemainingCircle.style.fontSize = '1.0em';
            r3RemainingCircle.style.fontWeight = 'bold';
            r3RemainingCircle.style.color = 'white';
            r3RemainingCircle.style.zIndex = '99';
            r3RemainingCircle.style.left = (entryLeft + 5 * spacing) + 'px';
            r3RemainingCircle.style.top = schedulerTop + 'px';
            r3RemainingCircle.style.transform = 'translate(-50%, 0)';
            r3RemainingCircle.textContent = '180';
            flowDiagram.appendChild(r3RemainingCircle);
            state.containers.r3RemainingCircle = r3RemainingCircle;

            // Set info panel states for R1-R4 (completed decode)
            for (let i = 1; i <= 4; i++) {
                const rConfig = getRequestConfig(i);
                updateInfoPanel(i, {
                    'input': rConfig.input,
                    'output': rConfig.outputWords.slice(0, 3).join(' '),
                    'start-iter': `Iter ${i}`,
                    'path': 'Decode',
                    'path-history': i === 1 ? 'PD' : (i === 2 ? 'PED' : 'PD'),
                    'prompt-tokens': rConfig.promptTokens.toString(),
                    'computed-tokens': (rConfig.promptTokens + 3).toString(),
                    'remaining-tokens': '0',
                    'scheduled-tokens': '0',
                    'output-tokens': '3'
                });
            }

            // Set info panel state for R5 (just arrived) - reuse r5Config from above
            updateInfoPanel(5, {
                'input': r5Config.input,
                'output': '-',
                'start-iter': '-',
                'path': '-',
                'path-history': '-',
                'prompt-tokens': '130',
                'computed-tokens': '0',
                'remaining-tokens': '130',
                'scheduled-tokens': '0',
                'output-tokens': '0'
            });
        }

        /**
         * Initialize visual state for iteration 5
         * Creates R1-R5 circle tokens, R3 remaining circle (80), and R5 remaining circle (30) at scheduler
         */
        async function initForIteration5(state) {
            const flowDiagram = state.flowDiagram;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;
            const spacing = 75;

            // Create R1-R5 circle tokens at scheduler
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const circleToken = document.createElement('div');
                circleToken.style.position = 'absolute';
                circleToken.style.width = '35px';
                circleToken.style.height = '35px';
                circleToken.style.background = rConfig.color;
                circleToken.style.borderRadius = '50%';
                circleToken.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                circleToken.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                circleToken.style.display = 'flex';
                circleToken.style.alignItems = 'center';
                circleToken.style.justifyContent = 'center';
                circleToken.style.fontSize = '1.2em';
                circleToken.style.fontWeight = 'bold';
                circleToken.style.color = 'white';
                circleToken.style.zIndex = '100';
                circleToken.style.left = (entryLeft + (i - 1) * spacing) + 'px';
                circleToken.style.top = schedulerTop + 'px';
                circleToken.style.transform = 'translate(-50%, 0)';
                circleToken.textContent = '1';
                flowDiagram.appendChild(circleToken);
                state.containers[`r${i}SquareToken_iter4`] = circleToken;
            }

            // Create R3 remaining circle (grey, 80 tokens) at scheduler
            const r3RemainingCircle = document.createElement('div');
            r3RemainingCircle.style.position = 'absolute';
            r3RemainingCircle.style.width = '35px';
            r3RemainingCircle.style.height = '35px';
            r3RemainingCircle.style.background = '#555';
            r3RemainingCircle.style.borderRadius = '50%';
            r3RemainingCircle.style.border = '2px solid rgba(255, 255, 255, 0.5)';
            r3RemainingCircle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r3RemainingCircle.style.display = 'flex';
            r3RemainingCircle.style.alignItems = 'center';
            r3RemainingCircle.style.justifyContent = 'center';
            r3RemainingCircle.style.fontSize = '1.0em';
            r3RemainingCircle.style.fontWeight = 'bold';
            r3RemainingCircle.style.color = 'white';
            r3RemainingCircle.style.zIndex = '99';
            r3RemainingCircle.style.left = (entryLeft + 5 * spacing) + 'px';
            r3RemainingCircle.style.top = schedulerTop + 'px';
            r3RemainingCircle.style.transform = 'translate(-50%, 0)';
            r3RemainingCircle.textContent = '80';
            flowDiagram.appendChild(r3RemainingCircle);
            state.containers.r3RemainingCircle = r3RemainingCircle;

            // Create R5 remaining circle (grey, 30 tokens) at scheduler
            const r5RemainingCircle = document.createElement('div');
            r5RemainingCircle.style.position = 'absolute';
            r5RemainingCircle.style.width = '35px';
            r5RemainingCircle.style.height = '35px';
            r5RemainingCircle.style.background = '#555';
            r5RemainingCircle.style.borderRadius = '50%';
            r5RemainingCircle.style.border = '2px solid rgba(255, 255, 255, 0.5)';
            r5RemainingCircle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
            r5RemainingCircle.style.display = 'flex';
            r5RemainingCircle.style.alignItems = 'center';
            r5RemainingCircle.style.justifyContent = 'center';
            r5RemainingCircle.style.fontSize = '1.0em';
            r5RemainingCircle.style.fontWeight = 'bold';
            r5RemainingCircle.style.color = 'white';
            r5RemainingCircle.style.zIndex = '99';
            r5RemainingCircle.style.left = (entryLeft + 6 * spacing) + 'px';
            r5RemainingCircle.style.top = schedulerTop + 'px';
            r5RemainingCircle.style.transform = 'translate(-50%, 0)';
            r5RemainingCircle.textContent = '30';
            flowDiagram.appendChild(r5RemainingCircle);
            state.containers.r5RemainingCircle = r5RemainingCircle;

            // Set info panel states for all 5 requests (iteration 4 completed)
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const outputTokens = i <= 2 ? 4 : (i === 3 ? 2 : (i === 4 ? 4 : 1));
                updateInfoPanel(i, {
                    'input': rConfig.input,
                    'output': rConfig.outputWords.slice(0, outputTokens).join(' '),
                    'start-iter': `Iter ${i}`,
                    'path': i <= 4 ? 'Decode' : 'Prefill',
                    'path-history': i === 1 ? 'PDD' : (i === 2 ? 'PEDD' : (i === 3 ? 'PDP' : (i === 4 ? 'PDD' : 'P'))),
                    'prompt-tokens': rConfig.promptTokens.toString(),
                    'computed-tokens': (rConfig.promptTokens + outputTokens).toString(),
                    'remaining-tokens': i === 3 ? '80' : (i === 5 ? '30' : '0'),
                    'scheduled-tokens': '0',
                    'output-tokens': outputTokens.toString()
                });
            }
        }

        /**
         * Initialize visual state for iteration 6
         * Creates R1-R5 circle tokens at scheduler
         */
        async function initForIteration6(state) {
            const flowDiagram = state.flowDiagram;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;
            const spacing = 75;

            // Create R1-R5 circle tokens at scheduler
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const circleToken = document.createElement('div');
                circleToken.style.position = 'absolute';
                circleToken.style.width = '35px';
                circleToken.style.height = '35px';
                circleToken.style.background = rConfig.color;
                circleToken.style.borderRadius = '50%';
                circleToken.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                circleToken.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                circleToken.style.display = 'flex';
                circleToken.style.alignItems = 'center';
                circleToken.style.justifyContent = 'center';
                circleToken.style.fontSize = '1.2em';
                circleToken.style.fontWeight = 'bold';
                circleToken.style.color = 'white';
                circleToken.style.zIndex = '100';
                circleToken.style.left = (entryLeft + (i - 1) * spacing) + 'px';
                circleToken.style.top = schedulerTop + 'px';
                circleToken.style.transform = 'translate(-50%, 0)';
                circleToken.textContent = '1';
                flowDiagram.appendChild(circleToken);
                state.containers[`r${i}SquareToken_iter5`] = circleToken;
            }

            // Set info panel states for all 5 requests (iteration 5 completed)
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const outputTokens = i === 1 ? 5 : (i === 2 ? 5 : (i === 3 ? 3 : (i === 4 ? 5 : 2)));
                updateInfoPanel(i, {
                    'input': rConfig.input,
                    'output': rConfig.outputWords.slice(0, outputTokens).join(' '),
                    'start-iter': `Iter ${i}`,
                    'path': 'Decode',
                    'path-history': i === 1 ? 'PDDD' : (i === 2 ? 'PEDDD' : (i === 3 ? 'PDPD' : (i === 4 ? 'PDDD' : 'PED'))),
                    'prompt-tokens': rConfig.promptTokens.toString(),
                    'computed-tokens': (rConfig.promptTokens + outputTokens).toString(),
                    'remaining-tokens': '0',
                    'scheduled-tokens': '0',
                    'output-tokens': outputTokens.toString()
                });
            }
        }

        /**
         * Initialize visual state for iteration 7
         * Creates R1-R5 circle tokens at scheduler
         */
        async function initForIteration7(state) {
            const flowDiagram = state.flowDiagram;
            const schedulerTop = state.layout.schedulerTop;
            const entryLeft = state.layout.entryLeft;
            const spacing = 75;

            // Create R1-R5 circle tokens at scheduler
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const circleToken = document.createElement('div');
                circleToken.style.position = 'absolute';
                circleToken.style.width = '35px';
                circleToken.style.height = '35px';
                circleToken.style.background = rConfig.color;
                circleToken.style.borderRadius = '50%';
                circleToken.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                circleToken.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                circleToken.style.display = 'flex';
                circleToken.style.alignItems = 'center';
                circleToken.style.justifyContent = 'center';
                circleToken.style.fontSize = '1.2em';
                circleToken.style.fontWeight = 'bold';
                circleToken.style.color = 'white';
                circleToken.style.zIndex = '100';
                circleToken.style.left = (entryLeft + (i - 1) * spacing) + 'px';
                circleToken.style.top = schedulerTop + 'px';
                circleToken.style.transform = 'translate(-50%, 0)';
                circleToken.textContent = '1';
                flowDiagram.appendChild(circleToken);
                state.containers[`r${i}SquareToken_iter6`] = circleToken;
            }

            // Set info panel states for all 5 requests (iteration 6 completed)
            for (let i = 1; i <= 5; i++) {
                const rConfig = getRequestConfig(i);
                const outputTokens = i === 1 ? 6 : (i === 2 ? 6 : (i === 3 ? 4 : (i === 4 ? 6 : 3)));
                updateInfoPanel(i, {
                    'input': rConfig.input,
                    'output': rConfig.outputWords.slice(0, outputTokens).join(' '),
                    'start-iter': `Iter ${i}`,
                    'path': 'Decode',
                    'path-history': i === 1 ? 'PDDDD' : (i === 2 ? 'PEDDDD' : (i === 3 ? 'PDPDD' : (i === 4 ? 'PDDDD' : 'PEDD'))),
                    'prompt-tokens': rConfig.promptTokens.toString(),
                    'computed-tokens': (rConfig.promptTokens + outputTokens).toString(),
                    'remaining-tokens': '0',
                    'scheduled-tokens': '0',
                    'output-tokens': outputTokens.toString()
                });
            }
        }

        /**
         * Initialize visual state based on which iteration we're starting from
         */
        async function initializeVisualStateForIteration(iterNumber, state) {
            switch(iterNumber) {
                case 1:
                    // No initialization needed - starting from scratch
                    break;

                case 2:
                    await initForIteration2(state);
                    break;

                case 3:
                    await initForIteration3(state);
                    break;

                case 4:
                    await initForIteration4(state);
                    break;

                case 5:
                    await initForIteration5(state);
                    break;

                case 6:
                    await initForIteration6(state);
                    break;

                case 7:
                    await initForIteration7(state);
                    break;
            }
        }

        // ============================================================================
        // Iteration Functions - Each iteration wrapped in its own function
        // ============================================================================

        /**
         * Run Iteration 1: R1 prefill stage - processes 4 prompt tokens
         * @param {Object} state - Animation state object
         * OUTPUTS: state.circles[1], state.circles[2], state.containers.qkvBarsContainer
         */
        async function runIteration1(state) {
            // Show timeline highlight for iteration 1
            showTimelineHighlight(1);

            // Extract from state
            const flowDiagram = state.flowDiagram;
            const flowRect = state.flowRect;
            const entryLeft = state.layout.entryLeft;
            const entryTop = state.layout.entryTop;
            const startTop = state.layout.startTop;
            const schedulerTop = state.layout.schedulerTop;

            // Local variables that will be assigned to state at the end
            let qkvBarsContainer = null;
            let r2Circle = null;

            // ========== ITERATION 1 CODE STARTS ==========
            // This is the complete iteration 1 code from lines 2311-2794
            // Only minimal changes: variable declarations for qkvBarsContainer and r2Circle

            // Update iteration step title using helper
            const iter1Config = getIterationConfig(1);
            document.getElementById('iterationStepTitle').textContent = 'Iteration step: 1';
            const r1Square = document.getElementById('testR1');

            // Position R1 at the top
            r1Square.style.transition = 'none';
            r1Square.style.left = entryLeft + 'px';
            r1Square.style.top = startTop + 'px';
            r1Square.style.transform = 'translate(-50%, 0)';
            r1Square.style.opacity = '1';

            // Update R1 input text when R1 arrives
            updateInfoPanel(1, { 'input': getRequestConfig(1).input });

            await sleep(100);

            // Move R1 down to entry point (same style as R2/R3/R4)
            r1Square.style.transition = 'top 1.5s ease';
            r1Square.style.top = entryTop + 'px';

            await sleep(1500);

            // Create token circle for R1
            const tokenCircle = createTokenCircle(getRequestConfig(1), entryLeft, entryTop, flowDiagram);

            // Note: createTokenCircle already sets initial position and appends to flowDiagram
            // The following lines are redundant but kept for clarity/safety
            tokenCircle.style.left = entryLeft + 'px';
            tokenCircle.style.top = entryTop + 'px';
            tokenCircle.style.transform = 'translate(-50%, 0)'; // Same transform as R1 square
            tokenCircle.style.opacity = '0';

            // Cross-fade: R1 square fades out, token circle fades in at the same position
            r1Square.style.transition = 'opacity 0.5s ease';
            r1Square.style.opacity = '0';
            tokenCircle.style.transition = 'opacity 0.5s ease';
            tokenCircle.style.opacity = '1';

            await sleep(500);

            // Remove R1 square
            r1Square.remove();

            // Step 4: Move token circle down to scheduler (maintaining horizontal position)
            // schedulerModule, schedulerRect, schedulerTop already declared above

            await sleep(500);

            // Move straight down to scheduler (maintain same horizontal position as R1)
            tokenCircle.style.transition = 'top 0.8s ease';
            tokenCircle.style.left = entryLeft + 'px'; // Keep same horizontal position as R1
            tokenCircle.style.top = schedulerTop + 'px';

            await sleep(800);

            // Update info panel when R1 reaches scheduler
            updateInfoPanel(1, { 'start-iter': 'Iter 1' });

            updateInfoPanel(1, { 'prompt-tokens': '4' });

            updateInfoPanel(1, { 'remaining-tokens': '0' });

            updateInfoPanel(1, { 'scheduled-tokens': '4' });

            updateInfoPanel(1, { 'output-tokens': '0' });

            await sleep(500);

            // Step 5: Move token circle down to below Reorder Batch substep box
            const substep4 = document.getElementById('substep4');
            const substep4Rect = substep4.getBoundingClientRect();

            // Calculate position where top of circle is below bottom of Reorder Batch substep box
            const reorderBatchBottom = substep4Rect.bottom - flowRect.top;
            const gap = 5; // 5px gap between box bottom and circle top
            const circleRadius = 35 / 2; // Half of circle height (35px)

            // Position the circle so its top edge (not center) is at the gap distance below the box
            const circleTopPosition = reorderBatchBottom + gap + circleRadius - 20; // Add radius to position by center

            await sleep(500);

            // Move token circle straight down, maintaining current horizontal position (from R1's entryLeft)
            tokenCircle.style.transition = 'top 0.8s ease';
            // Keep same horizontal position as R1 - don't change left position
            tokenCircle.style.top = circleTopPosition + 'px';

            await sleep(800);

            // Step 6: Highlight Prepare inputs substep box
            const substep1 = document.getElementById('substep1');
            substep1.classList.add('active');

            await sleep(500);

            // Step 7: Transform token circle into horizontal input bar
            tokenCircle.style.transition = 'all 0.6s ease';
            tokenCircle.style.left = '50%'; // Center horizontally to match substep boxes
            tokenCircle.style.transform = 'translateX(-50%)'; // Center transform
            tokenCircle.style.width = '470px';
            tokenCircle.style.height = '25px';
            tokenCircle.style.borderRadius = '4px';
            tokenCircle.style.fontSize = '0.9em';
            tokenCircle.textContent = 'input_ids array; position_ids array';

            await sleep(600);

            // Remove substep highlight
            substep1.classList.remove('active');

            // Step 8: Compute query_start_loc - Highlight substep 2 and show arrow
            const substep2 = document.getElementById('substep2');
            substep2.classList.add('active');

            await sleep(500);

            // Show query_start_loc arrow pointing to the start of the horizontal bar
            const tokenCircleRect = tokenCircle.getBoundingClientRect();
            const barLeftEdge = tokenCircleRect.left - flowRect.left;
            const barHeight = 25;

            // Create arrow with same style as iteration 2
            const queryStartArrow_iter1 = document.createElement('div');
            queryStartArrow_iter1.style.position = 'absolute';
            queryStartArrow_iter1.style.display = 'flex';
            queryStartArrow_iter1.style.flexDirection = 'column';
            queryStartArrow_iter1.style.alignItems = 'center';
            queryStartArrow_iter1.style.zIndex = '100';
            queryStartArrow_iter1.innerHTML = `
                <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                <div style="font-size: 0.75em; color: #000000; font-weight: bold;">0</div>
            `;

            // Position arrow below the horizontal bar at the left edge
            // Add 2px offset to account for the left border
            queryStartArrow_iter1.style.left = (barLeftEdge + 2) + 'px';
            queryStartArrow_iter1.style.top = (circleTopPosition + barHeight + 5) + 'px';

            flowDiagram.appendChild(queryStartArrow_iter1);

            await sleep(1000);

            // Remove arrow and remove substep highlight
            queryStartArrow_iter1.remove();
            substep2.classList.remove('active');

            await sleep(300);

            // Step 9: Transform input bar and arrow into QKV horizontal bar
            // Highlight substep 3 (QKV Projection)
            substep3.classList.add('active');

            await sleep(500);

            // === PARALLEL ANIMATIONS START ===
            // While R1 transforms to QKV bars, R2 arrives at entry point

            // r2Circle already declared at top of function

            // Start R2 animation (runs in parallel with R1's QKV transformation)
            const r2Promise = (async () => {
                // Wait for R1's input bar transformation and query_start_loc to complete
                // So R2 starts appearing when R1 begins QKV transformation
                // This is approximately: substep1 (800ms) + queryArrow display (1000ms) + substep2 clear (500ms) = 2300ms
                // But we already waited for some of this, so we wait for the remaining time
                // We're at the point after query arrow is hidden, so wait for beforeQKV delay
                await sleep(500); // Wait for beforeQKV timing

                // Create R2 square at top (same size as R1)
                const r2Square = document.createElement('div');
                r2Square.style.position = 'absolute';
                r2Square.style.width = '35px';  // Same as R1
                r2Square.style.height = '35px'; // Same as R1
                r2Square.style.background = getRequestConfig(2).color; // R2 color (Medium Teal)
                r2Square.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2Square.style.borderRadius = '6px';
                r2Square.style.display = 'flex';
                r2Square.style.alignItems = 'center';
                r2Square.style.justifyContent = 'center';
                r2Square.style.fontWeight = 'bold';
                r2Square.style.color = 'white';
                r2Square.style.fontSize = '0.85em'; // Slightly smaller font to fit
                r2Square.textContent = 'R2';
                r2Square.style.zIndex = '50';

                // Position R2 at top (same vertical position as R1, but different horizontal)
                const r2Left = 255; // entryLeft (180) + spacing (75)
                r2Square.style.left = r2Left + 'px';
                r2Square.style.top = startTop + 'px'; // Same startTop as R1 (10)
                r2Square.style.transform = 'translate(-50%, 0)';

                flowDiagram.appendChild(r2Square);

                // Update R2 input text when R2 arrives
                document.getElementById('r2-input').textContent = 'I\'ve been experimenting with fine-tuning LLMs...';
                highlightValue('r2-input');

                await sleep(100);

                // Move R2 down to entry point
                r2Square.style.transition = 'top 1.5s ease';
                r2Square.style.top = entryTop + 'px';

                await sleep(1500);

                // Transform R2 square into token circle at entry point
                r2Circle = document.createElement('div');
                r2Circle.style.position = 'absolute';
                r2Circle.style.width = '35px';
                r2Circle.style.height = '35px';
                r2Circle.style.background = getRequestConfig(2).color; // R2 color
                r2Circle.style.borderRadius = '50%';
                r2Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                r2Circle.style.display = 'flex';
                r2Circle.style.alignItems = 'center';
                r2Circle.style.justifyContent = 'center';
                r2Circle.style.fontSize = '1.2em';
                r2Circle.style.fontWeight = 'bold';
                r2Circle.style.color = 'white';
                r2Circle.style.zIndex = '70';
                r2Circle.textContent = getRequestConfig(2).promptTokens.toString(); // R2 tokens
                r2Circle.style.left = r2Left + 'px';
                r2Circle.style.top = entryTop + 'px';
                r2Circle.style.transform = 'translate(-50%, 0)'; // Same as R1 - top edge at entryTop
                r2Circle.style.opacity = '0';

                flowDiagram.appendChild(r2Circle);

                // Cross-fade: R2 square fades out, circle fades in
                r2Square.style.transition = 'opacity 0.5s ease';
                r2Square.style.opacity = '0';
                r2Circle.style.transition = 'opacity 0.5s ease';
                r2Circle.style.opacity = '1';

                await sleep(500);

                // Remove R2 square
                r2Square.remove();

                await sleep(500);

                // Move R2 circle down to scheduler (same horizontal position)
                r2Circle.style.transition = 'top 0.8s ease';
                r2Circle.style.top = schedulerTop + 'px';

                await sleep(800);

                // Update R2 info panel when R2 reaches scheduler (iteration 1)
                // Note: "Starts" should only be updated when R2 exits scheduler (in iteration 2)
                updateInfoPanel(2, { 'prompt-tokens': '60' });

                updateInfoPanel(2, { 'computed-tokens': '0' });

                updateInfoPanel(2, { 'remaining-tokens': '60' });

                updateInfoPanel(2, { 'scheduled-tokens': '0' });

                updateInfoPanel(2, { 'output-tokens': '0' });

                // R2 circle stays at scheduler for now
                // TODO: When R2 moves to Model Runner, position it below Reorder Batch substep (substep4)
            })();

            // R1 transforms to QKV bars (runs in parallel with R2 animation above)
            tokenCircle.style.transition = 'all 0.6s ease';
            tokenCircle.style.left = '50%'; // Center horizontally to match substep boxes
            tokenCircle.style.transform = 'translateX(-50%)'; // Center transform
            tokenCircle.style.width = '470px'; // Match substep box width
            tokenCircle.style.height = 'auto'; // Auto height for stacked bars
            tokenCircle.style.borderRadius = '0px';
            tokenCircle.style.background = 'transparent'; // Transparent background
            tokenCircle.style.border = 'none';
            tokenCircle.style.fontSize = '0.8em';
            tokenCircle.style.fontWeight = 'bold';
            tokenCircle.style.display = 'flex';
            tokenCircle.style.flexDirection = 'column';
            tokenCircle.style.gap = '0px';
            tokenCircle.style.padding = '0';

            // Create three horizontal bars stacked vertically with R1's color
            tokenCircle.innerHTML = `
                <div style="width: 470px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9em; margin-bottom: 2px;">Q</div>
                <div style="width: 470px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9em; margin-bottom: 2px;">K</div>
                <div style="width: 470px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9em;">V</div>
            `;

            await sleep(600);

            // R1 and R2 animations continue in parallel
            // R1 proceeds immediately while R2 continues independently

            // === PARALLEL ANIMATIONS END ===

            // Remove substep highlight
            substep3.classList.remove('active');

            await sleep(500);

            // Step 6: Move R1's QKV bars to ROCM_AITER_FA Backend (Attention module)
            // Position below the classification substep box
            const attentionModule = document.getElementById('attention');
            const attentionRect = attentionModule.getBoundingClientRect();
            const classificationSubstep = document.getElementById('classificationSubstep');
            const classificationRect = classificationSubstep.getBoundingClientRect();

            // Calculate position below classification substep
            const classificationBottom = classificationRect.bottom - flowRect.top;
            const qkvGap = 5; // Gap between classification substep and QKV bars
            const qkvTargetTop = classificationBottom + qkvGap;

            // Get the three QKV bar elements (they're inside tokenCircle which has the three divs)
            qkvBarsContainer = tokenCircle; // tokenCircle now contains the three QKV bars (assign to existing variable)

            // Move QKV bars down to attention backend
            qkvBarsContainer.style.transition = 'all 0.8s ease';
            qkvBarsContainer.style.left = '50%'; // Center horizontally
            qkvBarsContainer.style.top = qkvTargetTop + 'px';
            qkvBarsContainer.style.transform = 'translateX(-50%)';

            await sleep(800);

            // Step 7: Highlight classification substep
            classificationSubstep.classList.add('active');
            await sleep(500);

            // Step 8: Change QKV bar colors to purple (Prefill path)
            const qBar = qkvBarsContainer.querySelector('div:nth-child(1)');
            const kBar = qkvBarsContainer.querySelector('div:nth-child(2)');
            const vBar = qkvBarsContainer.querySelector('div:nth-child(3)');

            const prefillColor = '#9b59b6'; // Purple for Prefill

            qBar.style.transition = 'background 0.5s ease';
            kBar.style.transition = 'background 0.5s ease';
            vBar.style.transition = 'background 0.5s ease';

            qBar.style.background = prefillColor;
            kBar.style.background = prefillColor;
            vBar.style.background = prefillColor;

            await sleep(500);

            // Update path info in panel
            updateInfoPanel(1, { 'path': 'Prefill' });

            // Remove classification highlight
            classificationSubstep.classList.remove('active');

            // Step 9: Shrink QKV bars and move to Prefill path box
            const prefillPathBox = document.getElementById('prefillPath');
            const prefillPathRect = prefillPathBox.getBoundingClientRect();

            // Calculate path box position - align top of QKV bars with top of path box
            const pathBoxLeft = prefillPathRect.left - flowRect.left + prefillPathRect.width / 2;
            const pathBoxTop = prefillPathRect.top - flowRect.top; // Top edge of path box
            const pathBoxWidth = prefillPathRect.width;

            // Shrink QKV bars width to match path box width and move to path box
            qBar.style.transition = 'all 0.6s ease';
            kBar.style.transition = 'all 0.6s ease';
            vBar.style.transition = 'all 0.6s ease';
            qkvBarsContainer.style.transition = 'all 0.6s ease';

            qBar.style.width = pathBoxWidth + 'px';
            kBar.style.width = pathBoxWidth + 'px';
            vBar.style.width = pathBoxWidth + 'px';

            qkvBarsContainer.style.left = pathBoxLeft + 'px';
            qkvBarsContainer.style.top = pathBoxTop + 'px'; // Align top edge
            qkvBarsContainer.style.transform = 'translateX(-50%)';
            qkvBarsContainer.style.background = 'transparent'; // Ensure transparent background
            qkvBarsContainer.style.border = 'none'; // Remove any border
            qkvBarsContainer.style.padding = '0'; // Remove padding
            qkvBarsContainer.style.boxShadow = 'none'; // Remove box shadow

            // Highlight the prefill path box
            prefillPathBox.classList.add('active');

            // Update computed tokens when entering prefill path
            updateInfoPanel(1, { 'computed-tokens': '4' });

            await sleep(600);

            // Remove path box highlight
            prefillPathBox.classList.remove('active');

            // Update path history
            updateInfoPanel(1, { 'path-history': 'P' });

            await sleep(400);

            // Step 10: Transform QKV bars into output token
            // Hide individual QKV bars
            qBar.style.opacity = '0';
            kBar.style.opacity = '0';
            vBar.style.opacity = '0';

            await sleep(500);

            // Transform the QKV bars container into a square output token
            qkvBarsContainer.style.flexDirection = 'row';  // Change from column to row
            qkvBarsContainer.style.gap = '0';
            qkvBarsContainer.style.borderRadius = '4px';  // Square corners
            qkvBarsContainer.style.padding = '12px';
            qkvBarsContainer.style.fontWeight = 'bold';
            qkvBarsContainer.style.fontSize = '0.9em';
            qkvBarsContainer.style.display = 'flex';
            qkvBarsContainer.style.alignItems = 'center';
            qkvBarsContainer.style.justifyContent = 'center';
            qkvBarsContainer.innerHTML = '';  // Empty text for prefill (no output)

            // Use R1's color (#26d0ce) for the output token
            qkvBarsContainer.style.background = getRequestConfig(1).color;
            qkvBarsContainer.style.border = '2px solid ' + getRequestConfig(1).borderColor;
            qkvBarsContainer.style.color = '#fff';
            qkvBarsContainer.style.width = '40px';  // Square dimensions
            qkvBarsContainer.style.height = '40px';

            await sleep(400);

            // Step 11: Move the square token to the output box, then show text "1"
            // Get output module position
            const outputModule = document.getElementById('output');
            const outputRect = outputModule.getBoundingClientRect();
            // Use same horizontal position as R1 token circle (entryLeft = 180)
            const outputLeft = entryLeft;
            const outputTop = outputRect.top - flowRect.top + 5; // Position near top of output box

            // Move downward to output box while maintaining same horizontal position as R1 token circle
            qkvBarsContainer.style.transition = 'all 0.8s ease';
            qkvBarsContainer.style.left = outputLeft + 'px';
            qkvBarsContainer.style.top = outputTop + 'px';
            qkvBarsContainer.style.transform = 'translate(-50%, 0)'; // Top edge alignment

            await sleep(800);

            // After arriving at output box, show "1" (representing 1 sampled token)
            qkvBarsContainer.innerHTML = '1';

            // Prefill stage: token is sampled but not yet computed
            // Output info panel remains at 0 and "-" (output only counts after decode computation in iteration 2)

            await sleep(500);

            // Step 12: Move the sampled token square back to scheduler
            const schedulerModule2 = document.getElementById('scheduler');
            const schedulerRect2 = schedulerModule2.getBoundingClientRect();
            const schedulerLeft2 = entryLeft; // Same horizontal position as R1
            const schedulerTop2 = schedulerRect2.top - flowRect.top + schedulerRect2.height / 2 - 20;

            qkvBarsContainer.style.transition = 'all 0.8s ease';
            qkvBarsContainer.style.left = schedulerLeft2 + 'px';
            qkvBarsContainer.style.top = schedulerTop2 + 'px';

            await sleep(800);

            // Step 13: Transform square back into token circle with "1" inside
            qkvBarsContainer.style.transition = 'all 0.5s ease';
            qkvBarsContainer.style.width = '35px';
            qkvBarsContainer.style.height = '35px';
            qkvBarsContainer.style.borderRadius = '50%'; // Make it circular
            qkvBarsContainer.style.padding = '0';
            qkvBarsContainer.style.fontSize = '1.2em';
            qkvBarsContainer.style.border = '2px solid rgba(255, 255, 255, 0.8)';
            qkvBarsContainer.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';

            await sleep(500);

            // ========== ITERATION 1 CODE ENDS ==========

            // Write outputs to state
            state.circles[1] = qkvBarsContainer;
            state.circles[2] = r2Circle;
            state.containers.qkvBarsContainer = qkvBarsContainer;
        }

/**
 * Run Iteration 2: R1 and R2 decode stage, R3 and R4 arrive
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout.entryLeft
 * - state.layout.entryTop
 * - state.layout.startTop
 * - state.layout.schedulerTop
 * - state.containers.qkvBarsContainer (R1+R2 QKV container from iter 1)
 * - state.circles[2] (r2Circle from iter 1)
 *
 * OUTPUTS (to state):
 * - state.circles[3] = r3Circle (at scheduler)
 * - state.circles[4] = r4Circle (at scheduler)
 * - Updates state.containers.qkvBarsContainer (now with R1+R2 decode output)
 * - state.containers.r1Container_iter2 = r1Container (R1 circle)
 * - state.containers.r2Container_iter2 = r2Container (R2 circle)
 */
async function runIteration2(state) {
    // Show timeline highlight for iteration 2
    showTimelineHighlight(2);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from iteration 1
    let qkvBarsContainer = state.containers.qkvBarsContainer;
    let r2Circle = state.circles[2];

    // Local variables that will be assigned to state at the end
    let r3Circle = null;
    let r4Circle = null;

    // ========== ITERATION 2 CODE STARTS ==========

                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 2';
    
                await sleep(500);
    
                // === PARALLEL ANIMATIONS START ===
                // While R1 and R2 move to Model Runner, R3 arrives at entry point

                // r3Circle already declared at function scope

                // Start R3 animation (runs in parallel)
                const r3Promise = (async () => {
                    // R3 arrives during iteration 2
                    await sleep(200); // Small delay before R3 appears
    
                    // Create R3 square at top
                    const r3Square = document.createElement('div');
                    r3Square.style.position = 'absolute';
                    r3Square.style.width = '35px';
                    r3Square.style.height = '35px';
                    r3Square.style.background = getRequestConfig(3).color; // R3 color (Darker Teal)
                    r3Square.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r3Square.style.borderRadius = '6px';
                    r3Square.style.display = 'flex';
                    r3Square.style.alignItems = 'center';
                    r3Square.style.justifyContent = 'center';
                    r3Square.style.fontWeight = 'bold';
                    r3Square.style.color = 'white';
                    r3Square.style.fontSize = '0.85em';
                    r3Square.textContent = 'R3';
                    r3Square.style.zIndex = '50';
    
                    // Position R3 at top (entryLeft + 2 * spacing)
                    const r3Left = 330; // entryLeft (180) + 2 * spacing (75) = 330
                    r3Square.style.left = r3Left + 'px';
                    r3Square.style.top = startTop + 'px';
                    r3Square.style.transform = 'translate(-50%, 0)';
    
                    flowDiagram.appendChild(r3Square);
    
                    // Update R3 input text when R3 arrives
                    updateInfoPanel(3, { 'input': getRequestConfig(3).input });
    
                    await sleep(100);
    
                    // Move R3 down to entry point
                    r3Square.style.transition = 'top 1.5s ease';
                    r3Square.style.top = entryTop + 'px';
    
                    await sleep(1500);
    
                    // Transform R3 square into token circle at entry point
                    r3Circle = document.createElement('div');
                    r3Circle.style.position = 'absolute';
                    r3Circle.style.width = '35px';
                    r3Circle.style.height = '35px';
                    r3Circle.style.background = getRequestConfig(3).color; // R3 color
                    r3Circle.style.borderRadius = '50%';
                    r3Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r3Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                    r3Circle.style.display = 'flex';
                    r3Circle.style.alignItems = 'center';
                    r3Circle.style.justifyContent = 'center';
                    r3Circle.style.fontSize = '1.2em';
                    r3Circle.style.fontWeight = 'bold';
                    r3Circle.style.color = 'white';
                    r3Circle.style.zIndex = '70';
                    r3Circle.textContent = getRequestConfig(3).promptTokens.toString(); // R3 tokens
                    r3Circle.style.left = r3Left + 'px';
                    r3Circle.style.top = entryTop + 'px';
                    r3Circle.style.transform = 'translate(-50%, 0)';
                    r3Circle.style.opacity = '0';
    
                    flowDiagram.appendChild(r3Circle);
    
                    // Cross-fade: R3 square fades out, circle fades in
                    r3Square.style.transition = 'opacity 0.5s ease';
                    r3Square.style.opacity = '0';
                    r3Circle.style.transition = 'opacity 0.5s ease';
                    r3Circle.style.opacity = '1';
    
                    await sleep(500);
    
                    // Remove R3 square
                    r3Square.remove();
    
                    await sleep(500);
    
                    // Move R3 circle down to scheduler (same horizontal position)
                    r3Circle.style.transition = 'top 0.8s ease';
                    r3Circle.style.top = schedulerTop + 'px';
    
                    await sleep(800);
    
                    // Update R3 info panel when R3 reaches scheduler (iteration 2)
                    // Note: "Starts" should only be updated when R3 exits scheduler (in iteration 3)
                    updateInfoPanel(3, { 'prompt-tokens': '280' });
    
                    updateInfoPanel(3, { 'computed-tokens': '0' });
    
                    updateInfoPanel(3, { 'remaining-tokens': '280' });
    
                    updateInfoPanel(3, { 'scheduled-tokens': '0' });
    
                    updateInfoPanel(3, { 'output-tokens': '0' });
    
                    // R3 circle stays at scheduler for now
                })();
    
                // Step 14: Move both R1 and R2 token circles down to below Reorder Batch substep
                const substep4_iter2 = document.getElementById('substep4');
                const substep4Rect_iter2 = substep4_iter2.getBoundingClientRect();
                const reorderBatchBottom_iter2 = substep4Rect_iter2.bottom - flowRect.top;
                const circleTopPosition_iter2 = reorderBatchBottom_iter2 + 5 + (35 / 2) - 20; // 5px gap, adjust for center
    
                // Move R1's token circle
                qkvBarsContainer.style.transition = 'all 0.8s ease';
                qkvBarsContainer.style.top = circleTopPosition_iter2 + 'px';
    
                // Move R2's token circle
                if (r2Circle) {
                    r2Circle.style.transition = 'all 0.8s ease';
                    r2Circle.style.top = circleTopPosition_iter2 + 'px';
                }
    
                await sleep(800);
    
                // Update R1 and R2 info panels for iteration 2
                // R1: Decode stage - processing the 1 sampled token
                updateInfoPanel(1, { 'prompt-tokens': '4' });
    
                updateInfoPanel(1, { 'remaining-tokens': '0' });
    
                updateInfoPanel(1, { 'scheduled-tokens': '1' });
    
                // R2: Now being scheduled in iteration 2
                updateInfoPanel(2, { 'start-iter': 'Iter 2' });
    
                updateInfoPanel(2, { 'remaining-tokens': '0' });
    
                updateInfoPanel(2, { 'scheduled-tokens': '60' });
    
                // === PARALLEL ANIMATIONS END ===
    
                await sleep(500);
    
                // Step 15: Transform R1 and R2 circles into a horizontal bar with two segments
                // Calculate segment widths based on token ratio
                const r1Tokens = 1; // R1 has 1 token in iteration 2
                const r2Tokens = 60; // R2 has 60 tokens
                const totalTokens = r1Tokens + r2Tokens; // 61 total
                const totalBarWidth = 470; // Same as substep box width
                const minSegmentWidth = 40; // Minimum width to show label
    
                // Calculate proportional widths
                let r1Width = (r1Tokens / totalTokens) * totalBarWidth;
                let r2Width = (r2Tokens / totalTokens) * totalBarWidth;
    
                // Ensure minimum width for labeling
                if (r1Width < minSegmentWidth) {
                    r1Width = minSegmentWidth;
                    r2Width = totalBarWidth - minSegmentWidth;
                }
                if (r2Width < minSegmentWidth) {
                    r2Width = minSegmentWidth;
                    r1Width = totalBarWidth - minSegmentWidth;
                }
    
                // Hide both circles
                qkvBarsContainer.style.transition = 'all 0.6s ease';
                qkvBarsContainer.style.opacity = '0';
                if (r2Circle) {
                    r2Circle.style.transition = 'all 0.6s ease';
                    r2Circle.style.opacity = '0';
                }
    
                await sleep(600);
    
                // Transform R1's container into the horizontal bar with two segments
                qkvBarsContainer.style.left = '50%'; // Center horizontally
                qkvBarsContainer.style.transform = 'translateX(-50%)';
                qkvBarsContainer.style.width = totalBarWidth + 'px';
                qkvBarsContainer.style.height = '25px';
                qkvBarsContainer.style.borderRadius = '4px';
                qkvBarsContainer.style.background = 'transparent';
                qkvBarsContainer.style.border = 'none';
                qkvBarsContainer.style.padding = '0';
                qkvBarsContainer.style.display = 'flex';
                qkvBarsContainer.style.flexDirection = 'row';
                qkvBarsContainer.style.gap = '0';
                qkvBarsContainer.style.fontSize = '0.9em';
                qkvBarsContainer.style.fontWeight = 'bold';
                qkvBarsContainer.style.boxShadow = 'none';
    
                // Create two segments: R1 and R2
                qkvBarsContainer.innerHTML = `
                    <div style="width: ${r1Width}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9em;">R1</div>
                    <div style="width: ${r2Width}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.9em;">R2</div>
                `;
    
                qkvBarsContainer.style.opacity = '1';
    
                await sleep(600);
    
                // Step 16: Show query_start_loc arrows for R1 and R2 segments
                // Get the horizontal bar position
                const barRect_iter2 = qkvBarsContainer.getBoundingClientRect();
                const barLeftEdge_iter2 = barRect_iter2.left - flowRect.left;
                const barTop_iter2 = barRect_iter2.top - flowRect.top;
                const barHeight_iter2 = 25;
    
                // Create first arrow for R1 segment (query_start_loc = 0, at left edge)
                const queryStartArrow1 = document.createElement('div');
                queryStartArrow1.style.position = 'absolute';
                queryStartArrow1.style.display = 'flex';
                queryStartArrow1.style.flexDirection = 'column';
                queryStartArrow1.style.alignItems = 'center';
                queryStartArrow1.style.zIndex = '100';
                queryStartArrow1.innerHTML = `
                    <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                    <div style="font-size: 0.75em; color: #000000; font-weight: bold;">0</div>
                `;
    
                // Position arrow at the left edge of the bar (start of R1)
                // Add 2px offset to account for the left border
                queryStartArrow1.style.left = (barLeftEdge_iter2 + 2) + 'px';
                queryStartArrow1.style.top = (barTop_iter2 + barHeight_iter2 - 5) + 'px';
    
                // Create second arrow for R2 segment (query_start_loc = 1, at R1/R2 boundary)
                const queryStartArrow2 = document.createElement('div');
                queryStartArrow2.style.position = 'absolute';
                queryStartArrow2.style.display = 'flex';
                queryStartArrow2.style.flexDirection = 'column';
                queryStartArrow2.style.alignItems = 'center';
                queryStartArrow2.style.zIndex = '100';
                queryStartArrow2.innerHTML = `
                    <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                    <div style="font-size: 0.75em; color: #000000; font-weight: bold;">1</div>
                `;
    
                // Position arrow at the boundary between R1 and R2 segments
                // Add 2px offset to account for the left border
                const r2StartOffset = r1Width; // R2 starts where R1 ends
                queryStartArrow2.style.left = (barLeftEdge_iter2 + r2StartOffset + 2) + 'px';
                queryStartArrow2.style.top = (barTop_iter2 + barHeight_iter2 - 5) + 'px';
    
                // Show both arrows together
                flowDiagram.appendChild(queryStartArrow1);
                flowDiagram.appendChild(queryStartArrow2);
    
                await sleep(2000);
    
                // Remove both arrows
                queryStartArrow1.remove();
                queryStartArrow2.remove();
    
                // Step 17: Transform horizontal bar into three QKV bars
                // Highlight substep 3 (QKV Projection)
                const substep3_iter2 = document.getElementById('substep3');
                substep3_iter2.classList.add('active');
    
                await sleep(500);
    
                // Hide the current horizontal bar
                qkvBarsContainer.style.opacity = '0';
    
                await sleep(300);
    
                // Transform into three QKV bars (Q, K, V), each with two segments for R1 and R2
                const qkvBarHeight = 25;
                const qkvBarSpacing = 0;
                const qkvBarWidth = 470; // Same as substep box width
    
                // Calculate segment widths (same as before)
                const r1Tokens_qkv = 1;
                const r2Tokens_qkv = 60;
                const totalTokens_qkv = r1Tokens_qkv + r2Tokens_qkv;
                const minSegmentWidth_qkv = 40;
    
                let r1Width_qkv = (r1Tokens_qkv / totalTokens_qkv) * qkvBarWidth;
                let r2Width_qkv = (r2Tokens_qkv / totalTokens_qkv) * qkvBarWidth;
    
                if (r1Width_qkv < minSegmentWidth_qkv) {
                    r1Width_qkv = minSegmentWidth_qkv;
                    r2Width_qkv = qkvBarWidth - minSegmentWidth_qkv;
                }
                if (r2Width_qkv < minSegmentWidth_qkv) {
                    r2Width_qkv = minSegmentWidth_qkv;
                    r1Width_qkv = qkvBarWidth - minSegmentWidth_qkv;
                }
    
                // Create three QKV bars with two segments each
                qkvBarsContainer.innerHTML = `
                    <div style="display: flex; margin-bottom: ${qkvBarSpacing}px;">
                        <div style="width: ${r1Width_qkv}px; height: ${qkvBarHeight}px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            Q<sub>R1</sub>
                        </div>
                        <div style="width: ${r2Width_qkv}px; height: ${qkvBarHeight}px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            Q<sub>R2</sub>
                        </div>
                    </div>
                    <div style="display: flex; margin-bottom: ${qkvBarSpacing}px;">
                        <div style="width: ${r1Width_qkv}px; height: ${qkvBarHeight}px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            K<sub>R1</sub>
                        </div>
                        <div style="width: ${r2Width_qkv}px; height: ${qkvBarHeight}px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            K<sub>R2</sub>
                        </div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_qkv}px; height: ${qkvBarHeight}px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            V<sub>R1</sub>
                        </div>
                        <div style="width: ${r2Width_qkv}px; height: ${qkvBarHeight}px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">
                            V<sub>R2</sub>
                        </div>
                    </div>
                `;
    
                // Update container styling for three bars
                qkvBarsContainer.style.width = qkvBarWidth + 'px';
                qkvBarsContainer.style.height = 'auto';
                qkvBarsContainer.style.display = 'block';
                qkvBarsContainer.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer.style.opacity = '1';
    
                await sleep(1500);
    
                // Remove substep highlight
                substep3_iter2.classList.remove('active');
    
                // Step 18: Move QKV bars to ROCM_AITER_FA Backend (Attention module)
                // Position below the classification substep box (same as iteration 1)
                const attentionModule_iter2 = document.getElementById('attention');
                const attentionRect_iter2 = attentionModule_iter2.getBoundingClientRect();
                const classificationSubstep_iter2 = document.getElementById('classificationSubstep');
                const classificationRect_iter2 = classificationSubstep_iter2.getBoundingClientRect();
    
                // Calculate position below classification substep
                const classificationBottom_iter2 = classificationRect_iter2.bottom - flowRect.top;
                const qkvGap_iter2 = 5; // Gap between classification substep and QKV bars
                const qkvTargetTop_iter2 = classificationBottom_iter2 + qkvGap_iter2;
    
                // === PARALLEL ANIMATIONS START ===
                // While QKV bars move to Attention module, R4 arrives at entry point

                // r4Circle already declared at function scope

                // Start R4 animation (runs in parallel with QKV movement)
                const r4Promise = (async () => {
                    // R4 arrives during iteration 2
                    await sleep(200); // Small delay before R4 appears
    
                    // Create R4 square at top
                    const r4Square = document.createElement('div');
                    r4Square.style.position = 'absolute';
                    r4Square.style.width = '35px';
                    r4Square.style.height = '35px';
                    r4Square.style.background = getRequestConfig(4).color; // R4 color (Even Darker Teal)
                    r4Square.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r4Square.style.borderRadius = '6px';
                    r4Square.style.display = 'flex';
                    r4Square.style.alignItems = 'center';
                    r4Square.style.justifyContent = 'center';
                    r4Square.style.fontWeight = 'bold';
                    r4Square.style.color = 'white';
                    r4Square.style.fontSize = '0.85em';
                    r4Square.textContent = 'R4';
                    r4Square.style.zIndex = '50';
    
                    // Position R4 at top (entryLeft + 3 * spacing)
                    const r4Left = 405; // entryLeft (180) + 3 * spacing (75) = 405
                    r4Square.style.left = r4Left + 'px';
                    r4Square.style.top = startTop + 'px';
                    r4Square.style.transform = 'translate(-50%, 0)';
    
                    flowDiagram.appendChild(r4Square);
    
                    // Update R4 input text when R4 arrives
                    updateInfoPanel(4, { 'input': getRequestConfig(4).input });
    
                    await sleep(100);
    
                    // Move R4 down to entry point
                    r4Square.style.transition = 'top 1.5s ease';
                    r4Square.style.top = entryTop + 'px';
    
                    await sleep(1500);
    
                    // Transform R4 square into token circle at entry point
                    r4Circle = document.createElement('div');
                    r4Circle.style.position = 'absolute';
                    r4Circle.style.width = '35px';
                    r4Circle.style.height = '35px';
                    r4Circle.style.background = getRequestConfig(4).color; // R4 color
                    r4Circle.style.borderRadius = '50%';
                    r4Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r4Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                    r4Circle.style.display = 'flex';
                    r4Circle.style.alignItems = 'center';
                    r4Circle.style.justifyContent = 'center';
                    r4Circle.style.fontSize = '1.2em';
                    r4Circle.style.fontWeight = 'bold';
                    r4Circle.style.color = 'white';
                    r4Circle.style.zIndex = '70';
                    r4Circle.textContent = getRequestConfig(4).promptTokens.toString(); // R4 tokens
                    r4Circle.style.left = r4Left + 'px';
                    r4Circle.style.top = entryTop + 'px';
                    r4Circle.style.transform = 'translate(-50%, 0)';
                    r4Circle.style.opacity = '0';
    
                    flowDiagram.appendChild(r4Circle);
    
                    // Cross-fade: R4 square fades out, circle fades in
                    r4Square.style.transition = 'opacity 0.5s ease';
                    r4Square.style.opacity = '0';
                    r4Circle.style.transition = 'opacity 0.5s ease';
                    r4Circle.style.opacity = '1';
    
                    await sleep(500);
    
                    // Remove R4 square
                    r4Square.remove();
    
                    await sleep(500);
    
                    // Move R4 circle down to scheduler (same horizontal position)
                    r4Circle.style.transition = 'top 0.8s ease';
                    r4Circle.style.top = schedulerTop + 'px';
    
                    await sleep(800);
    
                    // Update R4 info panel when R4 reaches scheduler (iteration 2)
                    // Note: "Starts" should only be updated when R4 exits scheduler (in iteration 3)
                    updateInfoPanel(4, { 'prompt-tokens': '30' });
    
                    updateInfoPanel(4, { 'computed-tokens': '0' });
    
                    updateInfoPanel(4, { 'remaining-tokens': '30' });
    
                    updateInfoPanel(4, { 'scheduled-tokens': '0' });
    
                    updateInfoPanel(4, { 'output-tokens': '0' });
    
                    // R4 circle stays at scheduler for now
                })();
    
                // QKV bars move to attention backend (runs in parallel with R4 animation above)
                qkvBarsContainer.style.transition = 'all 0.8s ease';
                qkvBarsContainer.style.left = '50%'; // Center horizontally
                qkvBarsContainer.style.top = qkvTargetTop_iter2 + 'px';
                qkvBarsContainer.style.transform = 'translateX(-50%)';
    
                await sleep(800);
    
                // Wait for R4 animation to complete
                await r4Promise;
                // === PARALLEL ANIMATIONS END ===
    
                // Step 19: Classify requests and color QKV bars accordingly
                // Highlight classification substep
                classificationSubstep_iter2.classList.add('active');
    
                await sleep(500);
    
                // Get all QKV bar segments (the divs inside the row divs)
                const rowDivs = qkvBarsContainer.children; // Get the 3 row divs
                const qBarSegments = [];
                for (let row of rowDivs) {
                    for (let segment of row.children) {
                        qBarSegments.push(segment);
                    }
                }
    
                // R1 is decode (orange), R2 is prefill (purple)
                // Each row has 2 segments: R1 and R2
                // Q row: segments 0 (R1) and 1 (R2)
                // K row: segments 2 (R1) and 3 (R2)
                // V row: segments 4 (R1) and 5 (R2)
    
                const decodeColor_iter2 = '#e67e22'; // Orange for decode
                const prefillColor_iter2 = '#9b59b6'; // Purple for prefill
    
                // Color R1 segments (indices 0, 2, 4) with decode orange
                if (qBarSegments[0]) {
                    qBarSegments[0].style.transition = 'background 0.5s ease';
                    qBarSegments[0].style.background = decodeColor_iter2;
                }
                if (qBarSegments[2]) {
                    qBarSegments[2].style.transition = 'background 0.5s ease';
                    qBarSegments[2].style.background = decodeColor_iter2;
                }
                if (qBarSegments[4]) {
                    qBarSegments[4].style.transition = 'background 0.5s ease';
                    qBarSegments[4].style.background = decodeColor_iter2;
                }
    
                // Color R2 segments (indices 1, 3, 5) with prefill purple
                if (qBarSegments[1]) {
                    qBarSegments[1].style.transition = 'background 0.5s ease';
                    qBarSegments[1].style.background = prefillColor_iter2;
                }
                if (qBarSegments[3]) {
                    qBarSegments[3].style.transition = 'background 0.5s ease';
                    qBarSegments[3].style.background = prefillColor_iter2;
                }
                if (qBarSegments[5]) {
                    qBarSegments[5].style.transition = 'background 0.5s ease';
                    qBarSegments[5].style.background = prefillColor_iter2;
                }
    
                await sleep(1000);
    
                // Remove classification highlight
                classificationSubstep_iter2.classList.remove('active');
    
                // Step 20: Move R1 QKV bars to decode path box
                // Get the decode path box (rightmost path box - orange/decode)
                const decodePathBox = document.getElementById('decodePath');
                if (!decodePathBox) {
                    console.error('decodePath element not found!');
                }
                const decodePathRect = decodePathBox.getBoundingClientRect();
    
                console.log('Decode path box position:', {
                    left: decodePathRect.left,
                    top: decodePathRect.top,
                    width: decodePathRect.width,
                    height: decodePathRect.height
                });
    
                // Calculate path box position - align top of QKV bars with top of path box
                const decodePathBoxLeft = decodePathRect.left - flowRect.left + decodePathRect.width / 2;
                const decodePathBoxTop = decodePathRect.top - flowRect.top;
                const decodePathBoxWidth = decodePathRect.width;
    
                console.log('Calculated position for R1 container:', {
                    left: decodePathBoxLeft,
                    top: decodePathBoxTop,
                    width: decodePathBoxWidth
                });
    
                // Get references to R1 segments (indices 0, 2, 4) and R2 segments (indices 1, 3, 5)
                const qR1 = qBarSegments[0];
                const kR1 = qBarSegments[2];
                const vR1 = qBarSegments[4];
                const qR2 = qBarSegments[1];
                const kR2 = qBarSegments[3];
                const vR2 = qBarSegments[5];
    
                // Get current positions and widths of R1 segments
                const qR1Rect = qR1.getBoundingClientRect();
                const kR1Rect = kR1.getBoundingClientRect();
                const vR1Rect = vR1.getBoundingClientRect();
    
                const qR1CurrentLeft = qR1Rect.left - flowRect.left;
                const qR1CurrentTop = qR1Rect.top - flowRect.top;
                const qR1CurrentWidth = qR1Rect.width;
    
                // Create a new container for R1 bars that will move independently
                const r1Container = document.createElement('div');
                r1Container.style.position = 'absolute';
                r1Container.style.left = qR1CurrentLeft + 'px'; // Start at R1 segment position
                r1Container.style.top = qR1CurrentTop + 'px';
                r1Container.style.width = qR1CurrentWidth + 'px'; // Start with R1 segment width
                r1Container.style.display = 'flex';
                r1Container.style.flexDirection = 'column';
                r1Container.style.gap = '0px';
                r1Container.style.zIndex = '100';
    
                // Clone R1 segments and add to new container
                const qR1Clone = qR1.cloneNode(true);
                const kR1Clone = kR1.cloneNode(true);
                const vR1Clone = vR1.cloneNode(true);
    
                // Set the cloned segments to full width of their container
                qR1Clone.style.width = '100%';
                kR1Clone.style.width = '100%';
                vR1Clone.style.width = '100%';
    
                r1Container.appendChild(qR1Clone);
                r1Container.appendChild(kR1Clone);
                r1Container.appendChild(vR1Clone);
    
                flowDiagram.appendChild(r1Container);
    
                // Hide original R1 segments
                qR1.style.opacity = '0';
                kR1.style.opacity = '0';
                vR1.style.opacity = '0';
    
                // Set transitions for the R1 container
                r1Container.style.transition = 'all 0.6s ease';
    
                await sleep(50); // Small delay to ensure elements are rendered
    
                // Move R1 container to decode path box and resize
                r1Container.style.left = (decodePathRect.left - flowRect.left) + 'px';
                r1Container.style.top = decodePathBoxTop + 'px';
                r1Container.style.width = decodePathBoxWidth + 'px';
    
                // Update border radius for standalone bars
                qR1Clone.style.borderRadius = '4px';
                kR1Clone.style.borderRadius = '4px';
                vR1Clone.style.borderRadius = '4px';
    
                // Highlight the decode path box
                decodePathBox.classList.add('active');
    
                // Update R1 computed tokens and output when entering decode path
                document.getElementById('r1-computed-tokens').textContent = '5'; // 4 + 1
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '1' });
    
                updateInfoPanel(1, { 'output': 'Effective' });
    
                await sleep(600);
    
                // Remove path box highlight
                decodePathBox.classList.remove('active');
    
                // Update R1 path and path history
                updateInfoPanel(1, { 'path': 'Decode' });
    
                updateInfoPanel(1, { 'path-history': 'P D' });
    
                await sleep(500);
    
                // Step 21: Move R2 QKV bars to prefill path box
                // Get the prefill path box (leftmost path box - purple/prefill)
                const prefillPathBox_iter2 = document.getElementById('prefillPath');
                const prefillPathRect_iter2 = prefillPathBox_iter2.getBoundingClientRect();
    
                const prefillPathBoxLeft_iter2 = prefillPathRect_iter2.left - flowRect.left;
                const prefillPathBoxTop_iter2 = prefillPathRect_iter2.top - flowRect.top;
                const prefillPathBoxWidth_iter2 = prefillPathRect_iter2.width;
    
                // Get current positions and widths of R2 segments
                const qR2Rect = qR2.getBoundingClientRect();
                const kR2Rect = kR2.getBoundingClientRect();
                const vR2Rect = vR2.getBoundingClientRect();
    
                const qR2CurrentLeft = qR2Rect.left - flowRect.left;
                const qR2CurrentTop = qR2Rect.top - flowRect.top;
                const qR2CurrentWidth = qR2Rect.width;
    
                // Create a new container for R2 bars that will move independently
                const r2Container = document.createElement('div');
                r2Container.style.position = 'absolute';
                r2Container.style.left = qR2CurrentLeft + 'px'; // Start at R2 segment position
                r2Container.style.top = qR2CurrentTop + 'px';
                r2Container.style.width = qR2CurrentWidth + 'px'; // Start with R2 segment width
                r2Container.style.display = 'flex';
                r2Container.style.flexDirection = 'column';
                r2Container.style.gap = '0px';
                r2Container.style.zIndex = '100';
    
                // Clone R2 segments and add to new container
                const qR2Clone = qR2.cloneNode(true);
                const kR2Clone = kR2.cloneNode(true);
                const vR2Clone = vR2.cloneNode(true);
    
                // Set the cloned segments to full width of their container
                qR2Clone.style.width = '100%';
                kR2Clone.style.width = '100%';
                vR2Clone.style.width = '100%';
    
                r2Container.appendChild(qR2Clone);
                r2Container.appendChild(kR2Clone);
                r2Container.appendChild(vR2Clone);
    
                flowDiagram.appendChild(r2Container);
    
                // Hide original R2 segments
                qR2.style.opacity = '0';
                kR2.style.opacity = '0';
                vR2.style.opacity = '0';
    
                // Set transitions for the R2 container
                r2Container.style.transition = 'all 0.6s ease';
    
                await sleep(50); // Small delay to ensure elements are rendered
    
                // Move R2 container to prefill path box and resize
                r2Container.style.left = prefillPathBoxLeft_iter2 + 'px';
                r2Container.style.top = prefillPathBoxTop_iter2 + 'px';
                r2Container.style.width = prefillPathBoxWidth_iter2 + 'px';
    
                // Update border radius for standalone bars
                qR2Clone.style.borderRadius = '4px';
                kR2Clone.style.borderRadius = '4px';
                vR2Clone.style.borderRadius = '4px';
    
                // Highlight the prefill path box
                prefillPathBox_iter2.classList.add('active');
    
                // Update R2 computed tokens when entering prefill path
                updateInfoPanel(2, { 'computed-tokens': '60' });
    
                await sleep(600);
    
                // Remove path box highlight
                prefillPathBox_iter2.classList.remove('active');
    
                // Update R2 path and path history
                updateInfoPanel(2, { 'path': 'Prefill' });
    
                updateInfoPanel(2, { 'path-history': 'P' });
    
                await sleep(500);
    
                // Step 22: Transform R1 and R2 bars into square output tokens (together)
                // Hide individual bars for both R1 and R2
                qR1Clone.style.opacity = '0';
                kR1Clone.style.opacity = '0';
                vR1Clone.style.opacity = '0';
                qR2Clone.style.opacity = '0';
                kR2Clone.style.opacity = '0';
                vR2Clone.style.opacity = '0';
    
                await sleep(500);
    
                // Transform R1 container into a square output token
                r1Container.style.flexDirection = 'row';
                r1Container.style.gap = '0';
                r1Container.style.borderRadius = '4px';
                r1Container.style.padding = '12px';
                r1Container.style.fontWeight = 'bold';
                r1Container.style.fontSize = '0.9em';
                r1Container.style.display = 'flex';
                r1Container.style.alignItems = 'center';
                r1Container.style.justifyContent = 'center';
                r1Container.innerHTML = '';  // Empty first, will add text after moving to output
                r1Container.style.background = getRequestConfig(1).color;
                r1Container.style.border = '2px solid ' + getRequestConfig(1).borderColor;
                r1Container.style.color = '#fff';
                r1Container.style.width = '40px';
                r1Container.style.height = '40px';
    
                // Transform R2 container into a square output token
                r2Container.style.flexDirection = 'row';
                r2Container.style.gap = '0';
                r2Container.style.borderRadius = '4px';
                r2Container.style.padding = '12px';
                r2Container.style.fontWeight = 'bold';
                r2Container.style.fontSize = '0.9em';
                r2Container.style.display = 'flex';
                r2Container.style.alignItems = 'center';
                r2Container.style.justifyContent = 'center';
                r2Container.innerHTML = '';  // Empty (R2 is prefill, no output yet)
                r2Container.style.background = getRequestConfig(2).color;
                r2Container.style.border = '2px solid ' + getRequestConfig(2).borderColor;
                r2Container.style.color = '#fff';
                r2Container.style.width = '40px';
                r2Container.style.height = '40px';
    
                await sleep(400);
    
                // Step 23: Move R1 and R2 square tokens to output box (together)
                const outputModule_iter2 = document.getElementById('output');
                const outputRect_iter2 = outputModule_iter2.getBoundingClientRect();
                const r1OutputLeft = entryLeft; // Same horizontal position as R1
                const r2OutputLeft = 255; // entryLeft (180) + spacing (75) = 255
                const outputTop_iter2 = outputRect_iter2.top - flowRect.top + 5;
    
                // Move both containers together
                r1Container.style.transition = 'all 0.8s ease';
                r1Container.style.left = r1OutputLeft + 'px';
                r1Container.style.top = outputTop_iter2 + 'px';
                r1Container.style.transform = 'translate(-50%, 0)';
    
                r2Container.style.transition = 'all 0.8s ease';
                r2Container.style.left = r2OutputLeft + 'px';
                r2Container.style.top = outputTop_iter2 + 'px';
                r2Container.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // After arriving at output box, both show "1" (sampled tokens)
                r1Container.innerHTML = '1';
                r2Container.innerHTML = '1';
    
                await sleep(500);
    
                // Step 24: Move both square tokens back to scheduler
                const schedulerModule_iter2 = document.getElementById('scheduler');
                const schedulerRect_iter2 = schedulerModule_iter2.getBoundingClientRect();
                const schedulerTop_iter2 = schedulerRect_iter2.top - flowRect.top + schedulerRect_iter2.height / 2 - 20;
    
                // Move R1 and R2 back to scheduler
                r1Container.style.transition = 'all 0.8s ease';
                r1Container.style.left = r1OutputLeft + 'px';
                r1Container.style.top = schedulerTop_iter2 + 'px';
                r1Container.style.transform = 'translate(-50%, 0)';
    
                r2Container.style.transition = 'all 0.8s ease';
                r2Container.style.left = r2OutputLeft + 'px';
                r2Container.style.top = schedulerTop_iter2 + 'px';
                r2Container.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // Step 25: Transform square tokens back to token circles
                // Transform R1 square to circle
                r1Container.style.transition = 'all 0.5s ease';
                r1Container.style.width = '35px';
                r1Container.style.height = '35px';
                r1Container.style.borderRadius = '50%';
                r1Container.style.padding = '0';
                r1Container.style.fontSize = '1.2em';
                r1Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                // Transform R2 square to circle
                r2Container.style.transition = 'all 0.5s ease';
                r2Container.style.width = '35px';
                r2Container.style.height = '35px';
                r2Container.style.borderRadius = '50%';
                r2Container.style.padding = '0';
                r2Container.style.fontSize = '1.2em';
                r2Container.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2Container.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                await sleep(500);
    

    // ========== ITERATION 2 CODE ENDS ==========

    // Write outputs to state
    state.circles[3] = r3Circle;
    state.circles[4] = r4Circle;
    state.containers.qkvBarsContainer = qkvBarsContainer;
    state.containers.r1Container_iter2 = r1Container;  // R1 circle from iteration 2
    state.containers.r2Container_iter2 = r2Container;  // R2 circle from iteration 2
}

/**
 * Run Iteration 3: R1/R2 decode, R3/R4 prefill, R5 arrives
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout (entryLeft, entryTop, startTop, schedulerTop)
 * - state.containers.qkvBarsContainer
 * - state.circles[2] (r2Circle)
 * - state.circles[3] (r3Circle)
 * - state.circles[4] (r4Circle)
 * - state.containers.r1Container_iter2 (R1 circle from iteration 2)
 * - state.containers.r2Container_iter2 (R2 circle from iteration 2)
 *
 * OUTPUTS (to state):
 * - state.circles[5] = r5Circle (at scheduler)
 * - state.containers.r1Container = r1Token_iter3 (output container)
 * - state.containers.r2Container = r2Token_iter3 (output container)
 * - state.containers.r3Container = r3Token_iter3 (output container)
 * - state.containers.r4Container = r4Token_iter3 (output container)
 * - state.containers.r3RemainingCircle = r3RemainingCircle (remaining tokens circle)
 */
async function runIteration3(state) {
    // Show timeline highlight for iteration 3
    showTimelineHighlight(3);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from previous iterations
    let qkvBarsContainer = state.containers.qkvBarsContainer;
    let r2Circle = state.circles[2];
    let r3Circle = state.circles[3];
    let r4Circle = state.circles[4];
    let r1Container_iter2 = state.containers.r1Container_iter2;  // R1 circle from iteration 2
    let r2Container_iter2 = state.containers.r2Container_iter2;  // R2 circle from iteration 2

    // Local variables that will be assigned to state at the end
    let r5Circle = null;
    let r1Token_iter3 = null;
    let r2Token_iter3 = null;
    let r3Token_iter3 = null;
    let r4Token_iter3 = null;
    let r3RemainingCircle = null;

    // ========== ITERATION 3 CODE STARTS ==========

                // ITERATION 3: R1 decode, R2 decode, R3 prefill, R4 prefill
                // ============================================================================
    
                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 3';
    
                await sleep(500);
    
                // ========== ITERATION 3: Split R3 token - scheduler can only schedule 100 tokens ==========
                // R3 currently has 280 tokens total, but scheduler can only schedule 100 at a time
                // Create a new circle showing the remaining 180 tokens
    
                // First, update R3 circle to show 100 (scheduled tokens)
                r3Circle.innerHTML = '100';
    
                await sleep(300);
    
                // Get R3 and R4 current positions to place 180 circle between them
                const r3Rect_beforeSplit = r3Circle.getBoundingClientRect();
                const r3CurrentLeft_beforeSplit = r3Rect_beforeSplit.left - flowRect.left;
                const r3CurrentTop_beforeSplit = r3Rect_beforeSplit.top - flowRect.top;
    
                const r4Rect_beforeSplit = r4Circle.getBoundingClientRect();
                const r4CurrentLeft_beforeSplit = r4Rect_beforeSplit.left - flowRect.left;
    
                // Calculate position between R3 and R4
                const betweenLeft = (r3CurrentLeft_beforeSplit + r4CurrentLeft_beforeSplit) / 2;
    
                // Create a new circle for the remaining 180 tokens between R3 and R4
                r3RemainingCircle = document.createElement('div');
                r3RemainingCircle.style.position = 'absolute';
                r3RemainingCircle.style.width = '30px'; // Smaller size to fit
                r3RemainingCircle.style.height = '30px';
                r3RemainingCircle.style.borderRadius = '50%';
                r3RemainingCircle.style.background = '#95a5a6'; // Grey color
                r3RemainingCircle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3RemainingCircle.style.display = 'flex';
                r3RemainingCircle.style.alignItems = 'center';
                r3RemainingCircle.style.justifyContent = 'center';
                r3RemainingCircle.style.color = 'white';
                r3RemainingCircle.style.fontSize = '0.65em'; // Smaller font
                r3RemainingCircle.style.fontWeight = 'bold';
                r3RemainingCircle.style.zIndex = '50';
                r3RemainingCircle.style.left = (betweenLeft + 15) + 'px';
                r3RemainingCircle.style.top = r3CurrentTop_beforeSplit + 'px';
                r3RemainingCircle.style.transform = 'translate(-50%, 0)'; // Center it
                r3RemainingCircle.innerHTML = '180';
                r3RemainingCircle.style.opacity = '0';
                r3RemainingCircle.style.transition = 'opacity 0.5s ease';
    
                flowDiagram.appendChild(r3RemainingCircle);
    
                // Fade in the remaining circle
                await sleep(100);
                r3RemainingCircle.style.opacity = '1';
    
                await sleep(500);
    
                // Step 26: Move R1, R2, R3, R4 token circles from scheduler to Model Runner
                const modelRunnerModule_iter3 = document.getElementById('modelrunner');
                const modelRunnerRect_iter3 = modelRunnerModule_iter3.getBoundingClientRect();
                const substep4_iter3 = document.getElementById('substep4');
                const substep4Rect_iter3 = substep4_iter3.getBoundingClientRect();
                const reorderBatchBottom_iter3 = substep4Rect_iter3.bottom - flowRect.top;
                const circleTopPosition_iter3 = reorderBatchBottom_iter3 + 5 + (35 / 2) - 20;
    
                // Move all four circles together (R1 and R2 from iteration 2, R3 and R4 from current)
                r1Container_iter2.style.transition = 'all 0.8s ease';
                r1Container_iter2.style.top = circleTopPosition_iter3 + 'px';

                r2Container_iter2.style.transition = 'all 0.8s ease';
                r2Container_iter2.style.top = circleTopPosition_iter3 + 'px';
    
                if (r3Circle) {
                    r3Circle.style.transition = 'all 0.8s ease';
                    r3Circle.style.top = circleTopPosition_iter3 + 'px';
                }
    
                if (r4Circle) {
                    r4Circle.style.transition = 'all 0.8s ease';
                    r4Circle.style.top = circleTopPosition_iter3 + 'px';
                }
    
                await sleep(800);

                // Update info panels when tokens exit scheduler
                // R1: Decode stage - processing 1 sampled token
                updateInfoPanel(1, { 'scheduled-tokens': '1' });
    
                // R2: Decode stage - processing 1 sampled token
                updateInfoPanel(2, { 'start-iter': 'Iter 2' });
    
                updateInfoPanel(2, { 'scheduled-tokens': '1' });
    
                // R3: Prefill stage - starts processing (limited by budget)
                updateInfoPanel(3, { 'start-iter': 'Iter 3' });
    
                document.getElementById('r3-remaining-tokens').textContent = '180'; // 280 - 100
                highlightValue('r3-remaining-tokens');
    
                updateInfoPanel(3, { 'scheduled-tokens': '100' });
    
                // R4: Prefill stage - starts processing (all tokens fit)
                updateInfoPanel(4, { 'start-iter': 'Iter 3' });
    
                updateInfoPanel(4, { 'remaining-tokens': '0' });
    
                updateInfoPanel(4, { 'scheduled-tokens': '30' });
    
                await sleep(500);
    
                // Step 27: Transform circles into horizontal bar with 4 segments
                // Calculate segment widths (R1: 1, R2: 1, R3: 100, R4: 30, total: 132)
                const r1Tokens_iter3 = 1;
                const r2Tokens_iter3 = 1;
                const r3Tokens_iter3 = 100;
                const r4Tokens_iter3 = 30;
                const totalTokens_iter3 = r1Tokens_iter3 + r2Tokens_iter3 + r3Tokens_iter3 + r4Tokens_iter3;
                const totalBarWidth_iter3 = 470;
                const minSegmentWidth_iter3 = 40;
    
                let r1Width_iter3 = Math.max((r1Tokens_iter3 / totalTokens_iter3) * totalBarWidth_iter3, minSegmentWidth_iter3);
                let r2Width_iter3 = Math.max((r2Tokens_iter3 / totalTokens_iter3) * totalBarWidth_iter3, minSegmentWidth_iter3);
                let r3Width_iter3 = (r3Tokens_iter3 / totalTokens_iter3) * totalBarWidth_iter3;
                let r4Width_iter3 = (r4Tokens_iter3 / totalTokens_iter3) * totalBarWidth_iter3;
    
                // Adjust if R1 and R2 are at minimum
                const r1r2Used = r1Width_iter3 + r2Width_iter3;
                const r3r4Available = totalBarWidth_iter3 - r1r2Used;
                const r3r4Ratio = r3Tokens_iter3 + r4Tokens_iter3;
                r3Width_iter3 = (r3Tokens_iter3 / r3r4Ratio) * r3r4Available;
                r4Width_iter3 = (r4Tokens_iter3 / r3r4Ratio) * r3r4Available;
    
                // Hide all circles (use display none for R1/R2 to ensure they don't reappear)
                r1Container_iter2.style.opacity = '0';
                r2Container_iter2.style.opacity = '0';
                if (r3Circle) r3Circle.style.opacity = '0';
                if (r4Circle) r4Circle.style.opacity = '0';

                // Also set display none after fade out to ensure R1/R2 don't show in iteration 4
                setTimeout(() => {
                    r1Container_iter2.style.display = 'none';
                    r2Container_iter2.style.display = 'none';
                }, 300);
    
                await sleep(300);
    
                // Create new container for 4-segment bar
                const barContainer_iter3 = document.createElement('div');
                barContainer_iter3.style.position = 'absolute';
                barContainer_iter3.style.left = '50%';
                barContainer_iter3.style.top = circleTopPosition_iter3 + 'px';
                barContainer_iter3.style.transform = 'translateX(-50%)';
                barContainer_iter3.style.width = totalBarWidth_iter3 + 'px';
                barContainer_iter3.style.height = '25px';
                barContainer_iter3.style.display = 'flex';
                barContainer_iter3.style.zIndex = '100';
                barContainer_iter3.innerHTML = `
                    <div style="width: ${r1Width_iter3}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R1</div>
                    <div style="width: ${r2Width_iter3}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R2</div>
                    <div style="width: ${r3Width_iter3}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R3</div>
                    <div style="width: ${r4Width_iter3}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R4</div>
                `;
                flowDiagram.appendChild(barContainer_iter3);
    
                await sleep(500);
    
                // Step 28: Show query_start_loc arrows
                const barRect_iter3 = barContainer_iter3.getBoundingClientRect();
                const barLeftEdge_iter3 = barRect_iter3.left - flowRect.left;
                const barTop_iter3 = barRect_iter3.top - flowRect.top;
                const barHeight_iter3 = 25;
    
                const queryArrows_iter3 = [];
                const arrowPositions = [
                    { offset: 0, value: '0' }, // R1 starts at 0
                    { offset: r1Width_iter3, value: '1' }, // R2 starts at 1
                    { offset: r1Width_iter3 + r2Width_iter3, value: '2' }, // R3 starts at 2
                    { offset: r1Width_iter3 + r2Width_iter3 + r3Width_iter3, value: '132' } // R4 starts at 132
                ];
    
                arrowPositions.forEach(pos => {
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.display = 'flex';
                    arrow.style.flexDirection = 'column';
                    arrow.style.alignItems = 'center';
                    arrow.style.zIndex = '100';
                    arrow.innerHTML = `
                        <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                        <div style="font-size: 0.75em; color: #000000; font-weight: bold;">${pos.value}</div>
                    `;
                    // Add 2px offset to account for the left border
                    arrow.style.left = (barLeftEdge_iter3 + pos.offset + 2) + 'px';
                    arrow.style.top = (barTop_iter3 + barHeight_iter3 + 5) + 'px';
                    flowDiagram.appendChild(arrow);
                    queryArrows_iter3.push(arrow);
                });
    
                await sleep(2000);
    
                // Remove arrows
                queryArrows_iter3.forEach(arrow => arrow.remove());

                // r5Circle already declared at function scope

                // Step 29: Transform to QKV bars with 4 segments each
                // PARALLEL: While transforming to QKV, R5 arrives at entry point and moves to scheduler
                (async () => {
                    const entryPoint = document.getElementById('entrypoint');
                    const entryRect = entryPoint.getBoundingClientRect();
                    const entryLeft = entryRect.left - flowRect.left + entryRect.width / 2;
                    const entryTop = entryRect.top - flowRect.top + entryRect.height / 2 - 20;
    
                    // Calculate R5 horizontal position (equal spacing: R4 is at 405, spacing is 75)
                    const r5Left = 480; // entryLeft (180) + 4 * spacing (75) = 480
    
                    // Create R5 square at top (same style as R2/R3/R4)
                    const r5Square = document.createElement('div');
                    r5Square.style.position = 'absolute';
                    r5Square.style.width = '35px';  // Same size as R1-R4
                    r5Square.style.height = '35px';
                    r5Square.style.background = getRequestConfig(5).color; // Darkest Teal
                    r5Square.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r5Square.style.borderRadius = '6px';
                    r5Square.style.display = 'flex';
                    r5Square.style.alignItems = 'center';
                    r5Square.style.justifyContent = 'center';
                    r5Square.style.fontWeight = 'bold';
                    r5Square.style.color = 'white';
                    r5Square.style.fontSize = '0.85em';
                    r5Square.textContent = 'R5';
                    r5Square.style.zIndex = '50';
                    r5Square.style.left = r5Left + 'px';
                    r5Square.style.top = startTop + 'px';
                    r5Square.style.transform = 'translate(-50%, 0)';
    
                    flowDiagram.appendChild(r5Square);
    
                    // Update R5 info panel
                    updateInfoPanel(5, { 'input': getRequestConfig(5).input });
    
                    await sleep(100);
    
                    // Move R5 down to entry point
                    r5Square.style.transition = 'top 1.5s ease';
                    r5Square.style.top = entryTop + 'px';
    
                    await sleep(1500);
    
                    // Transform R5 square into token circle at entry point
                    r5Circle = document.createElement('div');
                    r5Circle.style.position = 'absolute';
                    r5Circle.style.width = '35px';
                    r5Circle.style.height = '35px';
                    r5Circle.style.background = getRequestConfig(5).color; // Darkest Teal
                    r5Circle.style.borderRadius = '50%';
                    r5Circle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    r5Circle.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
                    r5Circle.style.display = 'flex';
                    r5Circle.style.alignItems = 'center';
                    r5Circle.style.justifyContent = 'center';
                    r5Circle.style.fontSize = '1.2em';
                    r5Circle.style.fontWeight = 'bold';
                    r5Circle.style.color = 'white';
                    r5Circle.style.zIndex = '70';
                    r5Circle.textContent = getRequestConfig(5).promptTokens.toString(); // R5 tokens
                    r5Circle.style.left = r5Left + 'px';
                    r5Circle.style.top = entryTop + 'px';
                    r5Circle.style.transform = 'translate(-50%, 0)';
                    r5Circle.style.opacity = '0';
    
                    flowDiagram.appendChild(r5Circle);
    
                    // Cross-fade: R5 square fades out, circle fades in
                    r5Square.style.transition = 'opacity 0.5s ease';
                    r5Square.style.opacity = '0';
                    r5Circle.style.transition = 'opacity 0.5s ease';
                    r5Circle.style.opacity = '1';
    
                    await sleep(500);
    
                    // Remove R5 square
                    r5Square.remove();
    
                    await sleep(500);
    
                    // Move R5 circle down to scheduler (maintaining horizontal position)
                    const schedulerModule_r5 = document.getElementById('scheduler');
                    const schedulerRect_r5 = schedulerModule_r5.getBoundingClientRect();
                    const schedulerTop_r5 = schedulerRect_r5.top - flowRect.top + schedulerRect_r5.height / 2 - 20;
    
                    r5Circle.style.transition = 'top 0.8s ease';
                    r5Circle.style.top = schedulerTop_r5 + 'px';
    
                    await sleep(800);
    
                    // Update R5 info panel when R5 reaches scheduler
                    updateInfoPanel(5, { 'prompt-tokens': '130' });
    
                    updateInfoPanel(5, { 'computed-tokens': '0' });
    
                    updateInfoPanel(5, { 'remaining-tokens': '130' });
    
                    updateInfoPanel(5, { 'scheduled-tokens': '0' });
    
                    updateInfoPanel(5, { 'output-tokens': '0' });
    
                    // R5 circle stays at scheduler for now
                })();
    
                const substep3_iter3 = document.getElementById('substep3');
                substep3_iter3.classList.add('active');
    
                await sleep(500);
    
                barContainer_iter3.style.opacity = '0';
    
                await sleep(300);
    
                // Create QKV bars container
                const qkvBarsContainer_iter3 = document.createElement('div');
                qkvBarsContainer_iter3.style.position = 'absolute';
                qkvBarsContainer_iter3.style.left = '50%';
                qkvBarsContainer_iter3.style.top = circleTopPosition_iter3 + 'px';
                qkvBarsContainer_iter3.style.transform = 'translateX(-50%)';
                qkvBarsContainer_iter3.style.width = totalBarWidth_iter3 + 'px';
                qkvBarsContainer_iter3.style.display = 'block';
                qkvBarsContainer_iter3.style.zIndex = '100';
                qkvBarsContainer_iter3.style.opacity = '0';
                qkvBarsContainer_iter3.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer_iter3.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter3}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter3}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter3}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter3}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter3}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter3}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter3}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter3}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter3}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter3}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter3}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter3}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvBarsContainer_iter3);
    
                barContainer_iter3.remove();
    
                await sleep(100);
    
                // Fade in QKV bars
                qkvBarsContainer_iter3.style.opacity = '1';
    
                await sleep(1500);
    
                substep3_iter3.classList.remove('active');
    
                // Step 30: Move QKV bars to Attention module
                const attentionModule_iter3 = document.getElementById('attention');
                const attentionRect_iter3 = attentionModule_iter3.getBoundingClientRect();
                const classificationSubstep_iter3 = document.getElementById('classificationSubstep');
                const classificationRect_iter3 = classificationSubstep_iter3.getBoundingClientRect();
                const classificationBottom_iter3 = classificationRect_iter3.bottom - flowRect.top;
                const qkvTargetTop_iter3 = classificationBottom_iter3 + 5;
    
                qkvBarsContainer_iter3.style.transition = 'all 0.8s ease';
                qkvBarsContainer_iter3.style.top = qkvTargetTop_iter3 + 'px';
    
                await sleep(800);
    
                // ========== ITERATION 3: Classification ==========
                // Highlight classification substep
                classificationSubstep_iter3.style.background = 'rgba(255, 193, 7, 0.3)';
                classificationSubstep_iter3.style.borderColor = '#ffc107';
    
                await sleep(300);
    
                // Get all QKV bar segments from iteration 3
                const rowDivs_iter3 = qkvBarsContainer_iter3.children;
                const qBarSegments_iter3 = [];
                for (let row of rowDivs_iter3) {
                    for (let segment of row.children) {
                        qBarSegments_iter3.push(segment);
                    }
                }
    
                const decodeColor_iter3 = '#e67e22'; // Orange for decode
                const prefillColor_iter3 = '#9b59b6'; // Purple for prefill
    
                // Get individual segments
                const qR1_iter3 = qBarSegments_iter3[0];
                const qR2_iter3 = qBarSegments_iter3[1];
                const qR3_iter3 = qBarSegments_iter3[2];
                const qR4_iter3 = qBarSegments_iter3[3];
                const kR1_iter3 = qBarSegments_iter3[4];
                const kR2_iter3 = qBarSegments_iter3[5];
                const kR3_iter3 = qBarSegments_iter3[6];
                const kR4_iter3 = qBarSegments_iter3[7];
                const vR1_iter3 = qBarSegments_iter3[8];
                const vR2_iter3 = qBarSegments_iter3[9];
                const vR3_iter3 = qBarSegments_iter3[10];
                const vR4_iter3 = qBarSegments_iter3[11];
    
                // Color R1 and R2 segments (decode) with orange
                qR1_iter3.style.transition = 'background 0.6s ease';
                qR2_iter3.style.transition = 'background 0.6s ease';
                kR1_iter3.style.transition = 'background 0.6s ease';
                kR2_iter3.style.transition = 'background 0.6s ease';
                vR1_iter3.style.transition = 'background 0.6s ease';
                vR2_iter3.style.transition = 'background 0.6s ease';
    
                qR1_iter3.style.background = decodeColor_iter3;
                qR2_iter3.style.background = decodeColor_iter3;
                kR1_iter3.style.background = decodeColor_iter3;
                kR2_iter3.style.background = decodeColor_iter3;
                vR1_iter3.style.background = decodeColor_iter3;
                vR2_iter3.style.background = decodeColor_iter3;
    
                // Color R3 and R4 segments (prefill) with purple
                qR3_iter3.style.transition = 'background 0.6s ease';
                qR4_iter3.style.transition = 'background 0.6s ease';
                kR3_iter3.style.transition = 'background 0.6s ease';
                kR4_iter3.style.transition = 'background 0.6s ease';
                vR3_iter3.style.transition = 'background 0.6s ease';
                vR4_iter3.style.transition = 'background 0.6s ease';
    
                qR3_iter3.style.background = prefillColor_iter3;
                qR4_iter3.style.background = prefillColor_iter3;
                kR3_iter3.style.background = prefillColor_iter3;
                kR4_iter3.style.background = prefillColor_iter3;
                vR3_iter3.style.background = prefillColor_iter3;
                vR4_iter3.style.background = prefillColor_iter3;
    
                await sleep(600);
    
                // Remove classification highlight
                classificationSubstep_iter3.style.background = '';
                classificationSubstep_iter3.style.borderColor = '#ddd';
    
                // ========== ITERATION 3: Move R1 and R2 segments to decode path box ==========
    
                // Get current positions and widths of R1 and R2 segments
                const qR1Rect_iter3 = qR1_iter3.getBoundingClientRect();
                const qR1CurrentLeft_iter3 = qR1Rect_iter3.left - flowRect.left;
                const qR1CurrentTop_iter3 = qR1Rect_iter3.top - flowRect.top;
                const qR1CurrentWidth_iter3 = qR1Rect_iter3.width;
                const qR2CurrentWidth_iter3 = qR2_iter3.getBoundingClientRect().width;
    
                // Create a new container for R1 and R2 bars that will move to decode path
                const r1r2Container_iter3 = document.createElement('div');
                r1r2Container_iter3.style.position = 'absolute';
                r1r2Container_iter3.style.left = qR1CurrentLeft_iter3 + 'px';
                r1r2Container_iter3.style.top = qR1CurrentTop_iter3 + 'px';
                r1r2Container_iter3.style.width = (qR1CurrentWidth_iter3 + qR2CurrentWidth_iter3) + 'px';
                r1r2Container_iter3.style.display = 'flex';
                r1r2Container_iter3.style.flexDirection = 'column';
                r1r2Container_iter3.style.gap = '0px';
                r1r2Container_iter3.style.zIndex = '100';
    
                // Clone R1 and R2 segments from all three rows
                const qR1Clone_iter3 = qR1_iter3.cloneNode(true);
                const qR2Clone_iter3 = qR2_iter3.cloneNode(true);
                const kR1Clone_iter3 = kR1_iter3.cloneNode(true);
                const kR2Clone_iter3 = kR2_iter3.cloneNode(true);
                const vR1Clone_iter3 = vR1_iter3.cloneNode(true);
                const vR2Clone_iter3 = vR2_iter3.cloneNode(true);
    
                // Make clones stretch to fill container proportionally
                const r1OriginalWidth = qR1_iter3.getBoundingClientRect().width;
                const r2OriginalWidth = qR2_iter3.getBoundingClientRect().width;
                const totalOriginalWidth = r1OriginalWidth + r2OriginalWidth;
                const r1WidthPercent = (r1OriginalWidth / totalOriginalWidth * 100) + '%';
                const r2WidthPercent = (r2OriginalWidth / totalOriginalWidth * 100) + '%';
    
                qR1Clone_iter3.style.width = r1WidthPercent;
                qR2Clone_iter3.style.width = r2WidthPercent;
                kR1Clone_iter3.style.width = r1WidthPercent;
                kR2Clone_iter3.style.width = r2WidthPercent;
                vR1Clone_iter3.style.width = r1WidthPercent;
                vR2Clone_iter3.style.width = r2WidthPercent;
    
                qR1Clone_iter3.style.flexShrink = '0';
                qR2Clone_iter3.style.flexShrink = '0';
                kR1Clone_iter3.style.flexShrink = '0';
                kR2Clone_iter3.style.flexShrink = '0';
                vR1Clone_iter3.style.flexShrink = '0';
                vR2Clone_iter3.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r1r2 = document.createElement('div');
                qRow_r1r2.style.display = 'flex';
                qRow_r1r2.style.width = '100%';
                qRow_r1r2.appendChild(qR1Clone_iter3);
                qRow_r1r2.appendChild(qR2Clone_iter3);
    
                const kRow_r1r2 = document.createElement('div');
                kRow_r1r2.style.display = 'flex';
                kRow_r1r2.style.width = '100%';
                kRow_r1r2.appendChild(kR1Clone_iter3);
                kRow_r1r2.appendChild(kR2Clone_iter3);
    
                const vRow_r1r2 = document.createElement('div');
                vRow_r1r2.style.display = 'flex';
                vRow_r1r2.style.width = '100%';
                vRow_r1r2.appendChild(vR1Clone_iter3);
                vRow_r1r2.appendChild(vR2Clone_iter3);
    
                // Append rows to container
                r1r2Container_iter3.appendChild(qRow_r1r2);
                r1r2Container_iter3.appendChild(kRow_r1r2);
                r1r2Container_iter3.appendChild(vRow_r1r2);
    
                flowDiagram.appendChild(r1r2Container_iter3);
    
                // Hide original R1 and R2 segments (prevents R3 and R4 from shifting)
                qR1_iter3.style.opacity = '0';
                qR2_iter3.style.opacity = '0';
                kR1_iter3.style.opacity = '0';
                kR2_iter3.style.opacity = '0';
                vR1_iter3.style.opacity = '0';
                vR2_iter3.style.opacity = '0';
    
                await sleep(200);
    
                // Get decode path box position
                const decodePathBox_iter3 = document.getElementById('decodePath');
                const decodePathRect_iter3 = decodePathBox_iter3.getBoundingClientRect();
                const decodePathBoxTop_iter3 = decodePathRect_iter3.top - flowRect.top;
                const decodePathBoxWidth_iter3 = decodePathRect_iter3.width;
    
                // Move and resize to decode path box
                r1r2Container_iter3.style.transition = 'all 0.6s ease';
                r1r2Container_iter3.style.left = (decodePathRect_iter3.left - flowRect.left) + 'px';
                r1r2Container_iter3.style.top = decodePathBoxTop_iter3 + 'px';
                r1r2Container_iter3.style.width = decodePathBoxWidth_iter3 + 'px';
    
                // Update info panels for R1 and R2 when entering decode path
                document.getElementById('r1-path').textContent = 'Decode';
                document.getElementById('r2-path').textContent = 'Decode';
    
                document.getElementById('r1-computed-tokens').textContent = '6'; // 4 + 2
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '2' });
    
                updateInfoPanel(1, { 'output': 'Effective prompt' });
    
                document.getElementById('r2-computed-tokens').textContent = '61'; // 60 + 1
                highlightValue('r2-computed-tokens');
    
                updateInfoPanel(2, { 'output-tokens': '1' });
    
                updateInfoPanel(2, { 'output': 'The' });
    
                await sleep(600);
    
                // ========== ITERATION 3: Move R3 and R4 segments to prefill path box ==========
    
                // Get current positions and widths of R3 and R4 segments
                const qR3Rect_iter3 = qR3_iter3.getBoundingClientRect();
                const qR3CurrentLeft_iter3 = qR3Rect_iter3.left - flowRect.left;
                const qR3CurrentTop_iter3 = qR3Rect_iter3.top - flowRect.top;
                const qR3CurrentWidth_iter3 = qR3Rect_iter3.width;
                const qR4CurrentWidth_iter3 = qR4_iter3.getBoundingClientRect().width;
    
                // Create a new container for R3 and R4 bars that will move to prefill path
                const r3r4Container_iter3 = document.createElement('div');
                r3r4Container_iter3.style.position = 'absolute';
                r3r4Container_iter3.style.left = qR3CurrentLeft_iter3 + 'px';
                r3r4Container_iter3.style.top = qR3CurrentTop_iter3 + 'px';
                r3r4Container_iter3.style.width = (qR3CurrentWidth_iter3 + qR4CurrentWidth_iter3) + 'px';
                r3r4Container_iter3.style.display = 'flex';
                r3r4Container_iter3.style.flexDirection = 'column';
                r3r4Container_iter3.style.gap = '0px';
                r3r4Container_iter3.style.zIndex = '100';
    
                // Clone R3 and R4 segments from all three rows
                const qR3Clone_iter3 = qR3_iter3.cloneNode(true);
                const qR4Clone_iter3 = qR4_iter3.cloneNode(true);
                const kR3Clone_iter3 = kR3_iter3.cloneNode(true);
                const kR4Clone_iter3 = kR4_iter3.cloneNode(true);
                const vR3Clone_iter3 = vR3_iter3.cloneNode(true);
                const vR4Clone_iter3 = vR4_iter3.cloneNode(true);
    
                // Make clones stretch to fill container proportionally
                const r3OriginalWidth = qR3_iter3.getBoundingClientRect().width;
                const r4OriginalWidth = qR4_iter3.getBoundingClientRect().width;
                const totalOriginalWidth_r3r4 = r3OriginalWidth + r4OriginalWidth;
                const r3WidthPercent = (r3OriginalWidth / totalOriginalWidth_r3r4 * 100) + '%';
                const r4WidthPercent = (r4OriginalWidth / totalOriginalWidth_r3r4 * 100) + '%';
    
                qR3Clone_iter3.style.width = r3WidthPercent;
                qR4Clone_iter3.style.width = r4WidthPercent;
                kR3Clone_iter3.style.width = r3WidthPercent;
                kR4Clone_iter3.style.width = r4WidthPercent;
                vR3Clone_iter3.style.width = r3WidthPercent;
                vR4Clone_iter3.style.width = r4WidthPercent;
    
                qR3Clone_iter3.style.flexShrink = '0';
                qR4Clone_iter3.style.flexShrink = '0';
                kR3Clone_iter3.style.flexShrink = '0';
                kR4Clone_iter3.style.flexShrink = '0';
                vR3Clone_iter3.style.flexShrink = '0';
                vR4Clone_iter3.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r3r4 = document.createElement('div');
                qRow_r3r4.style.display = 'flex';
                qRow_r3r4.style.width = '100%';
                qRow_r3r4.appendChild(qR3Clone_iter3);
                qRow_r3r4.appendChild(qR4Clone_iter3);
    
                const kRow_r3r4 = document.createElement('div');
                kRow_r3r4.style.display = 'flex';
                kRow_r3r4.style.width = '100%';
                kRow_r3r4.appendChild(kR3Clone_iter3);
                kRow_r3r4.appendChild(kR4Clone_iter3);
    
                const vRow_r3r4 = document.createElement('div');
                vRow_r3r4.style.display = 'flex';
                vRow_r3r4.style.width = '100%';
                vRow_r3r4.appendChild(vR3Clone_iter3);
                vRow_r3r4.appendChild(vR4Clone_iter3);
    
                // Append rows to container
                r3r4Container_iter3.appendChild(qRow_r3r4);
                r3r4Container_iter3.appendChild(kRow_r3r4);
                r3r4Container_iter3.appendChild(vRow_r3r4);
    
                flowDiagram.appendChild(r3r4Container_iter3);
    
                // Hide original R3 and R4 segments
                qR3_iter3.style.opacity = '0';
                qR4_iter3.style.opacity = '0';
                kR3_iter3.style.opacity = '0';
                kR4_iter3.style.opacity = '0';
                vR3_iter3.style.opacity = '0';
                vR4_iter3.style.opacity = '0';
    
                await sleep(200);
    
                // Get prefill path box position
                const prefillPathBox_iter3 = document.getElementById('prefillPath');
                const prefillPathRect_iter3 = prefillPathBox_iter3.getBoundingClientRect();
                const prefillPathBoxTop_iter3 = prefillPathRect_iter3.top - flowRect.top;
                const prefillPathBoxWidth_iter3 = prefillPathRect_iter3.width;
    
                // Move and resize to prefill path box
                r3r4Container_iter3.style.transition = 'all 0.6s ease';
                r3r4Container_iter3.style.left = (prefillPathRect_iter3.left - flowRect.left) + 'px';
                r3r4Container_iter3.style.top = prefillPathBoxTop_iter3 + 'px';
                r3r4Container_iter3.style.width = prefillPathBoxWidth_iter3 + 'px';
    
                // Update info panels for R3 and R4 when entering prefill path
                document.getElementById('r3-path').textContent = 'Prefill';
                document.getElementById('r4-path').textContent = 'Prefill';
    
                document.getElementById('r3-computed-tokens').textContent = '100'; // First 100 tokens
                highlightValue('r3-computed-tokens');
    
                document.getElementById('r4-computed-tokens').textContent = '30'; // All 30 tokens
                highlightValue('r4-computed-tokens');
    
                // Update path history
                updateInfoPanel(1, { 'path-history': 'P D D' });
                updateInfoPanel(2, { 'path-history': 'P D' });
                updateInfoPanel(3, { 'path-history': 'P' });
                updateInfoPanel(4, { 'path-history': 'P' });
    
                await sleep(600);
    
                // ========== ITERATION 3: Transform to square tokens ==========
                // Create 4 separate square tokens: R1, R2 (decode) and R3, R4 (prefill)
    
                // Get current positions of R1/R2 and R3/R4 containers
                const r1r2Rect = r1r2Container_iter3.getBoundingClientRect();
                const r1r2Left = r1r2Rect.left - flowRect.left;
                const r1r2Top = r1r2Rect.top - flowRect.top;
                const r1r2Width = r1r2Rect.width;
    
                const r3r4Rect = r3r4Container_iter3.getBoundingClientRect();
                const r3r4Left = r3r4Rect.left - flowRect.left;
                const r3r4Top = r3r4Rect.top - flowRect.top;
                const r3r4Width = r3r4Rect.width;
    
                // Hide the original containers
                r1r2Container_iter3.style.opacity = '0';
                r3r4Container_iter3.style.opacity = '0';
    
                await sleep(300);
    
                // Calculate token positions to be adjacent (tokens touching each other, no gaps)
                // For decode path: R1 at left edge, R2 immediately after R1 (40px offset)
                const tokenWidth_iter3 = 40;
                const r2OffsetInDecodeBox = tokenWidth_iter3;  // R2 positioned right after R1
    
                // For prefill path: R3 at left edge, R4 immediately after R3 (40px offset)
                const r4OffsetInPrefillBox = tokenWidth_iter3;  // R4 positioned right after R3
    
                // Create R1 square token (decode - cyan) positioned at the start of decode container
                r1Token_iter3 = document.createElement('div');
                r1Token_iter3.style.position = 'absolute';
                r1Token_iter3.style.width = '40px';
                r1Token_iter3.style.height = '40px';
                r1Token_iter3.style.borderRadius = '4px';
                r1Token_iter3.style.background = getRequestConfig(1).color; // R1 color
                r1Token_iter3.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1Token_iter3.style.display = 'flex';
                r1Token_iter3.style.alignItems = 'center';
                r1Token_iter3.style.justifyContent = 'center';
                r1Token_iter3.style.color = 'white';
                r1Token_iter3.style.fontSize = '1.2em';
                r1Token_iter3.style.fontWeight = 'bold';
                r1Token_iter3.style.zIndex = '100';
                r1Token_iter3.style.left = r1r2Left + 'px';
                r1Token_iter3.style.top = r1r2Top + 'px';
                r1Token_iter3.innerHTML = '';
                flowDiagram.appendChild(r1Token_iter3);
    
                // Create R2 square token (decode - green) positioned adjacent to R1
                r2Token_iter3 = document.createElement('div');
                r2Token_iter3.style.position = 'absolute';
                r2Token_iter3.style.width = '40px';
                r2Token_iter3.style.height = '40px';
                r2Token_iter3.style.borderRadius = '4px';
                r2Token_iter3.style.background = getRequestConfig(2).color; // R2 color
                r2Token_iter3.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2Token_iter3.style.display = 'flex';
                r2Token_iter3.style.alignItems = 'center';
                r2Token_iter3.style.justifyContent = 'center';
                r2Token_iter3.style.color = 'white';
                r2Token_iter3.style.fontSize = '1.2em';
                r2Token_iter3.style.fontWeight = 'bold';
                r2Token_iter3.style.zIndex = '100';
                r2Token_iter3.style.left = (r1r2Left + r2OffsetInDecodeBox) + 'px';
                r2Token_iter3.style.top = r1r2Top + 'px';
                r2Token_iter3.innerHTML = '';
                flowDiagram.appendChild(r2Token_iter3);
    
                // Create R3 square token (prefill - darker teal) positioned at the start of prefill container
                r3Token_iter3 = document.createElement('div');
                r3Token_iter3.style.position = 'absolute';
                r3Token_iter3.style.width = '40px';
                r3Token_iter3.style.height = '40px';
                r3Token_iter3.style.borderRadius = '4px';
                r3Token_iter3.style.background = getRequestConfig(3).color; // R3 color
                r3Token_iter3.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3Token_iter3.style.display = 'flex';
                r3Token_iter3.style.alignItems = 'center';
                r3Token_iter3.style.justifyContent = 'center';
                r3Token_iter3.style.color = 'white';
                r3Token_iter3.style.fontSize = '1.2em';
                r3Token_iter3.style.fontWeight = 'bold';
                r3Token_iter3.style.zIndex = '100';
                r3Token_iter3.style.left = r3r4Left + 'px';
                r3Token_iter3.style.top = r3r4Top + 'px';
                r3Token_iter3.innerHTML = '';
                flowDiagram.appendChild(r3Token_iter3);
    
                // Create R4 square token (prefill - darkest teal) positioned adjacent to R3
                r4Token_iter3 = document.createElement('div');
                r4Token_iter3.style.position = 'absolute';
                r4Token_iter3.style.width = '40px';
                r4Token_iter3.style.height = '40px';
                r4Token_iter3.style.borderRadius = '4px';
                r4Token_iter3.style.background = getRequestConfig(4).color; // R4 color
                r4Token_iter3.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r4Token_iter3.style.display = 'flex';
                r4Token_iter3.style.alignItems = 'center';
                r4Token_iter3.style.justifyContent = 'center';
                r4Token_iter3.style.color = 'white';
                r4Token_iter3.style.fontSize = '1.2em';
                r4Token_iter3.style.fontWeight = 'bold';
                r4Token_iter3.style.zIndex = '100';
                r4Token_iter3.style.left = (r3r4Left + r4OffsetInPrefillBox) + 'px';
                r4Token_iter3.style.top = r3r4Top + 'px';
                r4Token_iter3.innerHTML = '';
                flowDiagram.appendChild(r4Token_iter3);
    
                await sleep(400);
    
                // ========== ITERATION 3: Move to output box ==========
    
                // Get output box position
                const outputModule_iter3 = document.getElementById('output');
                const outputRect_iter3 = outputModule_iter3.getBoundingClientRect();
                const outputTop_iter3 = outputRect_iter3.top - flowRect.top + 5;
    
                // Calculate horizontal positions for all 4 tokens in output box
                // Use same spacing as R1-R4 initial positions: R1=180, R2=255, R3=330, R4=405
                const r1OutputLeft_iter3 = 180;
                const r2OutputLeft_iter3 = 255;
                const r3OutputLeft_iter3 = 330;
                const r4OutputLeft_iter3 = 405;
    
                // Move all 4 tokens together
                r1Token_iter3.style.transition = 'all 0.8s ease';
                r1Token_iter3.style.left = r1OutputLeft_iter3 + 'px';
                r1Token_iter3.style.top = outputTop_iter3 + 'px';
                r1Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r2Token_iter3.style.transition = 'all 0.8s ease';
                r2Token_iter3.style.left = r2OutputLeft_iter3 + 'px';
                r2Token_iter3.style.top = outputTop_iter3 + 'px';
                r2Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r3Token_iter3.style.transition = 'all 0.8s ease';
                r3Token_iter3.style.left = r3OutputLeft_iter3 + 'px';
                r3Token_iter3.style.top = outputTop_iter3 + 'px';
                r3Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r4Token_iter3.style.transition = 'all 0.8s ease';
                r4Token_iter3.style.left = r4OutputLeft_iter3 + 'px';
                r4Token_iter3.style.top = outputTop_iter3 + 'px';
                r4Token_iter3.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // After arriving at output box, show sampled tokens
                // R1, R2, R4 show "1" (generated 1 token each)
                // R3 shows "0" (no tokens yet - still in prefill, hasn't started generating)
                r1Token_iter3.innerHTML = '1';
                r2Token_iter3.innerHTML = '1';
                r3Token_iter3.innerHTML = '0';
                r4Token_iter3.innerHTML = '1';
    
                await sleep(500);
    
                // ========== ITERATION 3: Move back to scheduler and transform to circles ==========
    
                // Get scheduler position
                const schedulerModule_iter3 = document.getElementById('scheduler');
                const schedulerRect_iter3 = schedulerModule_iter3.getBoundingClientRect();
                const schedulerTop_iter3 = schedulerRect_iter3.top - flowRect.top + schedulerRect_iter3.height / 2 - 20;
    
                // Move all 4 tokens back to scheduler (maintain their horizontal positions)
                r1Token_iter3.style.transition = 'all 0.8s ease';
                r1Token_iter3.style.left = r1OutputLeft_iter3 + 'px';
                r1Token_iter3.style.top = schedulerTop_iter3 + 'px';
                r1Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r2Token_iter3.style.transition = 'all 0.8s ease';
                r2Token_iter3.style.left = r2OutputLeft_iter3 + 'px';
                r2Token_iter3.style.top = schedulerTop_iter3 + 'px';
                r2Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r3Token_iter3.style.transition = 'all 0.8s ease';
                r3Token_iter3.style.left = r3OutputLeft_iter3 + 'px';
                r3Token_iter3.style.top = schedulerTop_iter3 + 'px';
                r3Token_iter3.style.transform = 'translate(-50%, 0)';
    
                r4Token_iter3.style.transition = 'all 0.8s ease';
                r4Token_iter3.style.left = r4OutputLeft_iter3 + 'px';
                r4Token_iter3.style.top = schedulerTop_iter3 + 'px';
                r4Token_iter3.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // Transform all 4 tokens to circles
                r1Token_iter3.style.transition = 'all 0.6s ease';
                r1Token_iter3.style.width = '35px';
                r1Token_iter3.style.height = '35px';
                r1Token_iter3.style.borderRadius = '50%';
    
                r2Token_iter3.style.transition = 'all 0.6s ease';
                r2Token_iter3.style.width = '35px';
                r2Token_iter3.style.height = '35px';
                r2Token_iter3.style.borderRadius = '50%';
    
                r3Token_iter3.style.transition = 'all 0.6s ease';
                r3Token_iter3.style.width = '35px';
                r3Token_iter3.style.height = '35px';
                r3Token_iter3.style.borderRadius = '50%';
    
                r4Token_iter3.style.transition = 'all 0.6s ease';
                r4Token_iter3.style.width = '35px';
                r4Token_iter3.style.height = '35px';
                r4Token_iter3.style.borderRadius = '50%';
    
                await sleep(600);
    
                // Update token values for iteration 4
                // R1: 1 (decode stage - only compute 1 token)
                // R2: 1 (decode stage - only compute 1 token)
                // R3: 0 (had 0 output in iter3, still 0)
                // R4: 1 (decode stage - only compute 1 token)
                // R5: 130 (already showing 130 from iteration 3)
                r1Token_iter3.innerHTML = '1';
                r2Token_iter3.innerHTML = '1';
                r3Token_iter3.innerHTML = '0';
                r4Token_iter3.innerHTML = '1';
    
                await sleep(300);
    

    // ========== ITERATION 3 CODE ENDS ==========

    // Write outputs to state
    state.circles[5] = r5Circle;
    state.containers.r1Container = r1Token_iter3;
    state.containers.r2Container = r2Token_iter3;
    state.containers.r3Container = r3Token_iter3;
    state.containers.r4Container = r4Token_iter3;
    state.containers.r3RemainingCircle = r3RemainingCircle;
}

/**
 * Run Iteration 4
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout
 * - state.circles[5] (r5Circle from iter 3)
 * - state.containers.r1Container to r4Container (from iter 3)
 *
 * OUTPUTS (to state):
 * - state.containers.r1SquareToken_iter4
 * - state.containers.r2SquareToken_iter4
 * - state.containers.r3SquareToken_iter4
 * - state.containers.r4SquareToken_iter4
 * - state.containers.r5SquareToken_iter4
 */
/**
 * Run Iteration 7
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout
 * - Square tokens from iter 6
 *
 * OUTPUTS (to state):
 * - Final output tokens (animation complete)
 */
async function runIteration7(state) {
    // Show timeline highlight for iteration 7
    showTimelineHighlight(7);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from previous iterations (will be used if needed)
    let r5Circle = state.circles[5];
    let r1Token_iter3 = state.containers.r1Container;
    let r2Token_iter3 = state.containers.r2Container;
    let r3Token_iter3 = state.containers.r3Container;
    let r4Token_iter3 = state.containers.r4Container;

    // Previous iteration outputs (if they exist)
    let r1SquareToken_iter4 = state.containers.r1SquareToken_iter4;
    let r2SquareToken_iter4 = state.containers.r2SquareToken_iter4;
    let r3SquareToken_iter4 = state.containers.r3SquareToken_iter4;
    let r4SquareToken_iter4 = state.containers.r4SquareToken_iter4;
    let r5SquareToken_iter4 = state.containers.r5SquareToken_iter4;

    let r1SquareToken_iter5 = state.containers.r1SquareToken_iter5;
    let r2SquareToken_iter5 = state.containers.r2SquareToken_iter5;
    let r3SquareToken_iter5 = state.containers.r3SquareToken_iter5;
    let r4SquareToken_iter5 = state.containers.r4SquareToken_iter5;
    let r5SquareToken_iter5 = state.containers.r5SquareToken_iter5;

    let r1SquareToken_iter6 = state.containers.r1SquareToken_iter6;
    let r2SquareToken_iter6 = state.containers.r2SquareToken_iter6;
    let r3SquareToken_iter6 = state.containers.r3SquareToken_iter6;
    let r4SquareToken_iter6 = state.containers.r4SquareToken_iter6;
    let r5SquareToken_iter6 = state.containers.r5SquareToken_iter6;

    // ========== ITERATION 7 CODE STARTS ==========

                // ========== ITERATION 7 ==========
                // All 5 requests are in decode stage (same as iteration 6)
                // Animation stops at output box with sampled tokens

                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 7';

                await sleep(1000);
    
                // Move circles back to Model Runner
                const substep4_iter7 = document.getElementById('substep4');
                const substep4Rect_iter7 = substep4_iter7.getBoundingClientRect();
                const reorderBatchBottom_iter7 = substep4Rect_iter7.bottom - flowRect.top;
                const circleTopPosition_iter7 = reorderBatchBottom_iter7 + 5 + (35 / 2) - 20;
    
                r1SquareToken_iter6.style.transition = 'all 0.8s ease';
                r1SquareToken_iter6.style.top = circleTopPosition_iter7 + 'px';
                r2SquareToken_iter6.style.transition = 'all 0.8s ease';
                r2SquareToken_iter6.style.top = circleTopPosition_iter7 + 'px';
                r3SquareToken_iter6.style.transition = 'all 0.8s ease';
                r3SquareToken_iter6.style.top = circleTopPosition_iter7 + 'px';
                r4SquareToken_iter6.style.transition = 'all 0.8s ease';
                r4SquareToken_iter6.style.top = circleTopPosition_iter7 + 'px';
                r5SquareToken_iter6.style.transition = 'all 0.8s ease';
                r5SquareToken_iter6.style.top = circleTopPosition_iter7 + 'px';
    
                await sleep(800);
    
                // Update info panels when tokens exit scheduler for iteration 7
                // R1: Decode stage
                updateInfoPanel(1, { 'scheduled-tokens': '1' });
    
                // R2: Decode stage
                updateInfoPanel(2, { 'scheduled-tokens': '1' });
    
                // R3: Decode stage
                updateInfoPanel(3, { 'scheduled-tokens': '1' });
    
                // R4: Decode stage
                updateInfoPanel(4, { 'scheduled-tokens': '1' });
    
                // R5: Decode stage
                updateInfoPanel(5, { 'scheduled-tokens': '1' });
    
                await sleep(500);
    
                // Transform circles to horizontal bar with 5 equal segments
                const r1Tokens_iter7 = 1;
                const r2Tokens_iter7 = 1;
                const r3Tokens_iter7 = 1;
                const r4Tokens_iter7 = 1;
                const r5Tokens_iter7 = 1;
                const totalTokens_iter7 = r1Tokens_iter7 + r2Tokens_iter7 + r3Tokens_iter7 + r4Tokens_iter7 + r5Tokens_iter7;
                const totalBarWidth_iter7 = 470;
                const segmentWidth_iter7 = totalBarWidth_iter7 / totalTokens_iter7;
    
                const barContainer_iter7 = document.createElement('div');
                barContainer_iter7.style.position = 'absolute';
                barContainer_iter7.style.left = '50%';
                barContainer_iter7.style.top = circleTopPosition_iter7 + 'px';
                barContainer_iter7.style.transform = 'translateX(-50%)';
                barContainer_iter7.style.display = 'flex';
                barContainer_iter7.style.zIndex = '100';
                barContainer_iter7.style.opacity = '0';
                barContainer_iter7.style.transition = 'opacity 0.5s ease';
                barContainer_iter7.innerHTML = `
                    <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: bold;">R1</div>
                    <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: bold;">R2</div>
                    <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: bold;">R3</div>
                    <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: bold;">R4</div>
                    <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: bold;">R5</div>
                `;
                flowDiagram.appendChild(barContainer_iter7);
    
                // Hide circles
                r1SquareToken_iter6.style.opacity = '0';
                r2SquareToken_iter6.style.opacity = '0';
                r3SquareToken_iter6.style.opacity = '0';
                r4SquareToken_iter6.style.opacity = '0';
                r5SquareToken_iter6.style.opacity = '0';
    
                await sleep(100);
    
                barContainer_iter7.style.opacity = '1';
    
                await sleep(1000);
    
                // Show query_start_loc arrows
                const barRect_iter7 = barContainer_iter7.getBoundingClientRect();
                const barLeftEdge_iter7 = barRect_iter7.left - flowRect.left;
                const barTop_iter7 = barRect_iter7.top - flowRect.top;
                const barHeight_iter7 = barRect_iter7.height;
    
                const arrowPositions_iter7 = [
                    { offset: 0, value: '0' },
                    { offset: segmentWidth_iter7, value: '1' },
                    { offset: segmentWidth_iter7 * 2, value: '2' },
                    { offset: segmentWidth_iter7 * 3, value: '3' },
                    { offset: segmentWidth_iter7 * 4, value: '4' }
                ];
    
                const queryArrows_iter7 = [];
                arrowPositions_iter7.forEach(pos => {
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.zIndex = '101';
                    arrow.style.textAlign = 'center';
                    arrow.innerHTML = `
                        <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                        <div style="font-size: 0.75em; color: #000000; font-weight: bold;">${pos.value}</div>
                    `;
                    arrow.style.left = (barLeftEdge_iter7 + pos.offset + 2) + 'px';
                    arrow.style.top = (barTop_iter7 + barHeight_iter7 + 5) + 'px';
                    flowDiagram.appendChild(arrow);
                    queryArrows_iter7.push(arrow);
                });
    
                await sleep(1500);
    
                queryArrows_iter7.forEach(arrow => arrow.remove());
    
                // ========== ITERATION 7: Transform to QKV bars ==========
    
                const substep3_iter7 = document.getElementById('substep3');
                substep3_iter7.classList.add('active');
    
                await sleep(500);
    
                barContainer_iter7.style.opacity = '0';
    
                await sleep(300);
    
                // Create QKV bars container with 5 segments
                const qkvBarsContainer_iter7 = document.createElement('div');
                qkvBarsContainer_iter7.style.position = 'absolute';
                qkvBarsContainer_iter7.style.left = '50%';
                qkvBarsContainer_iter7.style.top = circleTopPosition_iter7 + 'px';
                qkvBarsContainer_iter7.style.transform = 'translateX(-50%)';
                qkvBarsContainer_iter7.style.width = totalBarWidth_iter7 + 'px';
                qkvBarsContainer_iter7.style.display = 'block';
                qkvBarsContainer_iter7.style.zIndex = '100';
                qkvBarsContainer_iter7.style.opacity = '0';
                qkvBarsContainer_iter7.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer_iter7.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter7}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvBarsContainer_iter7);
    
                barContainer_iter7.remove();
    
                await sleep(100);
    
                // Fade in QKV bars
                qkvBarsContainer_iter7.style.opacity = '1';
    
                await sleep(1500);
    
                substep3_iter7.classList.remove('active');
    
                // Move QKV bars to Attention module (below classification substep)
                const attentionModule_iter7 = document.getElementById('attention');
                const attentionRect_iter7 = attentionModule_iter7.getBoundingClientRect();
                const classificationSubstep_iter7 = document.getElementById('classificationSubstep');
                const classificationRect_iter7 = classificationSubstep_iter7.getBoundingClientRect();
                const classificationBottom_iter7 = classificationRect_iter7.bottom - flowRect.top;
                const qkvTargetTop_iter7 = classificationBottom_iter7 + 5;
    
                qkvBarsContainer_iter7.style.transition = 'all 0.8s ease';
                qkvBarsContainer_iter7.style.top = qkvTargetTop_iter7 + 'px';
    
                await sleep(800);
    
                // Classification: All decode (orange)
                classificationSubstep_iter7.style.background = 'rgba(255, 193, 7, 0.3)';
                classificationSubstep_iter7.style.borderColor = '#ffc107';
    
                const decodeColor_iter7 = '#e67e22';
    
                // Get all segments from qkvBarsContainer_iter7
                const rowDivs_iter7 = qkvBarsContainer_iter7.children;
                const allSegments_iter7 = [];
                for (let i = 0; i < rowDivs_iter7.length; i++) {
                    const row = rowDivs_iter7[i];
                    const segments = row.children;
                    for (let j = 0; j < segments.length; j++) {
                        const segment = segments[j];
                        segment.style.transition = 'background 0.6s ease';
                        segment.style.background = decodeColor_iter7;
                        allSegments_iter7.push(segment);
                    }
                }
    
                await sleep(600);
    
                classificationSubstep_iter7.style.background = '';
                classificationSubstep_iter7.style.borderColor = '#ddd';
    
                // ========== ITERATION 7: Move all segments to decode path box ==========
    
                // Get current position and width of qkvBarsContainer_iter7
                const qkvContainerRect_iter7 = qkvBarsContainer_iter7.getBoundingClientRect();
                const qkvCurrentLeft_iter7 = qkvContainerRect_iter7.left - flowRect.left;
                const qkvCurrentTop_iter7 = qkvContainerRect_iter7.top - flowRect.top;
                const qkvCurrentWidth_iter7 = qkvContainerRect_iter7.width;
    
                // Get all segments
                const allQKVSegments_iter7 = [];
                for (let i = 0; i < rowDivs_iter7.length; i++) {
                    const row = rowDivs_iter7[i];
                    const segments = row.children;
                    for (let j = 0; j < segments.length; j++) {
                        allQKVSegments_iter7.push(segments[j]);
                    }
                }
    
                // Extract individual segments
                const qR1_iter7 = allQKVSegments_iter7[0];
                const qR2_iter7 = allQKVSegments_iter7[1];
                const qR3_iter7 = allQKVSegments_iter7[2];
                const qR4_iter7 = allQKVSegments_iter7[3];
                const qR5_iter7 = allQKVSegments_iter7[4];
                const kR1_iter7 = allQKVSegments_iter7[5];
                const kR2_iter7 = allQKVSegments_iter7[6];
                const kR3_iter7 = allQKVSegments_iter7[7];
                const kR4_iter7 = allQKVSegments_iter7[8];
                const kR5_iter7 = allQKVSegments_iter7[9];
                const vR1_iter7 = allQKVSegments_iter7[10];
                const vR2_iter7 = allQKVSegments_iter7[11];
                const vR3_iter7 = allQKVSegments_iter7[12];
                const vR4_iter7 = allQKVSegments_iter7[13];
                const vR5_iter7 = allQKVSegments_iter7[14];
    
                // Create a new container for all 5 requests
                const allDecodeContainer_iter7 = document.createElement('div');
                allDecodeContainer_iter7.style.position = 'absolute';
                allDecodeContainer_iter7.style.left = qkvCurrentLeft_iter7 + 'px';
                allDecodeContainer_iter7.style.top = qkvCurrentTop_iter7 + 'px';
                allDecodeContainer_iter7.style.width = qkvCurrentWidth_iter7 + 'px';
                allDecodeContainer_iter7.style.display = 'flex';
                allDecodeContainer_iter7.style.flexDirection = 'column';
                allDecodeContainer_iter7.style.gap = '0px';
                allDecodeContainer_iter7.style.zIndex = '100';
    
                // Clone all segments
                const qR1Clone_iter7 = qR1_iter7.cloneNode(true);
                const qR2Clone_iter7 = qR2_iter7.cloneNode(true);
                const qR3Clone_iter7 = qR3_iter7.cloneNode(true);
                const qR4Clone_iter7 = qR4_iter7.cloneNode(true);
                const qR5Clone_iter7 = qR5_iter7.cloneNode(true);
                const kR1Clone_iter7 = kR1_iter7.cloneNode(true);
                const kR2Clone_iter7 = kR2_iter7.cloneNode(true);
                const kR3Clone_iter7 = kR3_iter7.cloneNode(true);
                const kR4Clone_iter7 = kR4_iter7.cloneNode(true);
                const kR5Clone_iter7 = kR5_iter7.cloneNode(true);
                const vR1Clone_iter7 = vR1_iter7.cloneNode(true);
                const vR2Clone_iter7 = vR2_iter7.cloneNode(true);
                const vR3Clone_iter7 = vR3_iter7.cloneNode(true);
                const vR4Clone_iter7 = vR4_iter7.cloneNode(true);
                const vR5Clone_iter7 = vR5_iter7.cloneNode(true);
    
                // Get original widths
                const r1OriginalWidth_iter7 = qR1_iter7.getBoundingClientRect().width;
                const r2OriginalWidth_iter7 = qR2_iter7.getBoundingClientRect().width;
                const r3OriginalWidth_iter7 = qR3_iter7.getBoundingClientRect().width;
                const r4OriginalWidth_iter7 = qR4_iter7.getBoundingClientRect().width;
                const r5OriginalWidth_iter7 = qR5_iter7.getBoundingClientRect().width;
                const totalOriginalWidth_iter7 = r1OriginalWidth_iter7 + r2OriginalWidth_iter7 + r3OriginalWidth_iter7 + r4OriginalWidth_iter7 + r5OriginalWidth_iter7;
    
                // Calculate percentage widths
                const r1WidthPercent_iter7 = (r1OriginalWidth_iter7 / totalOriginalWidth_iter7 * 100) + '%';
                const r2WidthPercent_iter7 = (r2OriginalWidth_iter7 / totalOriginalWidth_iter7 * 100) + '%';
                const r3WidthPercent_iter7 = (r3OriginalWidth_iter7 / totalOriginalWidth_iter7 * 100) + '%';
                const r4WidthPercent_iter7 = (r4OriginalWidth_iter7 / totalOriginalWidth_iter7 * 100) + '%';
                const r5WidthPercent_iter7 = (r5OriginalWidth_iter7 / totalOriginalWidth_iter7 * 100) + '%';
    
                // Set percentage widths on clones
                qR1Clone_iter7.style.width = r1WidthPercent_iter7;
                qR2Clone_iter7.style.width = r2WidthPercent_iter7;
                qR3Clone_iter7.style.width = r3WidthPercent_iter7;
                qR4Clone_iter7.style.width = r4WidthPercent_iter7;
                qR5Clone_iter7.style.width = r5WidthPercent_iter7;
                kR1Clone_iter7.style.width = r1WidthPercent_iter7;
                kR2Clone_iter7.style.width = r2WidthPercent_iter7;
                kR3Clone_iter7.style.width = r3WidthPercent_iter7;
                kR4Clone_iter7.style.width = r4WidthPercent_iter7;
                kR5Clone_iter7.style.width = r5WidthPercent_iter7;
                vR1Clone_iter7.style.width = r1WidthPercent_iter7;
                vR2Clone_iter7.style.width = r2WidthPercent_iter7;
                vR3Clone_iter7.style.width = r3WidthPercent_iter7;
                vR4Clone_iter7.style.width = r4WidthPercent_iter7;
                vR5Clone_iter7.style.width = r5WidthPercent_iter7;
    
                // Set flex-shrink to 0
                qR1Clone_iter7.style.flexShrink = '0';
                qR2Clone_iter7.style.flexShrink = '0';
                qR3Clone_iter7.style.flexShrink = '0';
                qR4Clone_iter7.style.flexShrink = '0';
                qR5Clone_iter7.style.flexShrink = '0';
                kR1Clone_iter7.style.flexShrink = '0';
                kR2Clone_iter7.style.flexShrink = '0';
                kR3Clone_iter7.style.flexShrink = '0';
                kR4Clone_iter7.style.flexShrink = '0';
                kR5Clone_iter7.style.flexShrink = '0';
                vR1Clone_iter7.style.flexShrink = '0';
                vR2Clone_iter7.style.flexShrink = '0';
                vR3Clone_iter7.style.flexShrink = '0';
                vR4Clone_iter7.style.flexShrink = '0';
                vR5Clone_iter7.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_all_iter7 = document.createElement('div');
                qRow_all_iter7.style.display = 'flex';
                qRow_all_iter7.style.width = '100%';
                qRow_all_iter7.appendChild(qR1Clone_iter7);
                qRow_all_iter7.appendChild(qR2Clone_iter7);
                qRow_all_iter7.appendChild(qR3Clone_iter7);
                qRow_all_iter7.appendChild(qR4Clone_iter7);
                qRow_all_iter7.appendChild(qR5Clone_iter7);
    
                const kRow_all_iter7 = document.createElement('div');
                kRow_all_iter7.style.display = 'flex';
                kRow_all_iter7.style.width = '100%';
                kRow_all_iter7.appendChild(kR1Clone_iter7);
                kRow_all_iter7.appendChild(kR2Clone_iter7);
                kRow_all_iter7.appendChild(kR3Clone_iter7);
                kRow_all_iter7.appendChild(kR4Clone_iter7);
                kRow_all_iter7.appendChild(kR5Clone_iter7);
    
                const vRow_all_iter7 = document.createElement('div');
                vRow_all_iter7.style.display = 'flex';
                vRow_all_iter7.style.width = '100%';
                vRow_all_iter7.appendChild(vR1Clone_iter7);
                vRow_all_iter7.appendChild(vR2Clone_iter7);
                vRow_all_iter7.appendChild(vR3Clone_iter7);
                vRow_all_iter7.appendChild(vR4Clone_iter7);
                vRow_all_iter7.appendChild(vR5Clone_iter7);
    
                // Append rows to container
                allDecodeContainer_iter7.appendChild(qRow_all_iter7);
                allDecodeContainer_iter7.appendChild(kRow_all_iter7);
                allDecodeContainer_iter7.appendChild(vRow_all_iter7);
    
                flowDiagram.appendChild(allDecodeContainer_iter7);
    
                // Hide original qkvBarsContainer_iter7
                qkvBarsContainer_iter7.style.opacity = '0';
    
                await sleep(200);
    
                // Get decode path box position
                const decodePathBox_iter7 = document.getElementById('decodePath');
                const decodePathRect_iter7 = decodePathBox_iter7.getBoundingClientRect();
                const decodePathBoxTop_iter7 = decodePathRect_iter7.top - flowRect.top;
                const decodePathBoxWidth_iter7 = decodePathRect_iter7.width;
                const decodePathBoxLeft_iter7 = decodePathRect_iter7.left - flowRect.left;
    
                // Move and resize to decode path box
                allDecodeContainer_iter7.style.transition = 'all 0.6s ease';
                allDecodeContainer_iter7.style.left = decodePathBoxLeft_iter7 + 'px';
                allDecodeContainer_iter7.style.top = decodePathBoxTop_iter7 + 'px';
                allDecodeContainer_iter7.style.width = decodePathBoxWidth_iter7 + 'px';
    
                // Update info panels when entering decode path
                document.getElementById('r1-path').textContent = 'Decode';
                document.getElementById('r2-path').textContent = 'Decode';
                document.getElementById('r3-path').textContent = 'Decode';
                document.getElementById('r4-path').textContent = 'Decode';
                document.getElementById('r5-path').textContent = 'Decode';
    
                document.getElementById('r1-computed-tokens').textContent = '10'; // 4 + 6
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '6' });
    
                updateInfoPanel(1, { 'output': 'Effective prompt engineering for large language...' });
    
                document.getElementById('r2-computed-tokens').textContent = '65'; // 60 + 5
                highlightValue('r2-computed-tokens');
    
                updateInfoPanel(2, { 'output-tokens': '5' });
    
                updateInfoPanel(2, { 'output': 'The foundation of successful domain...' });
    
                document.getElementById('r3-computed-tokens').textContent = '282'; // 280 + 2
                highlightValue('r3-computed-tokens');
    
                updateInfoPanel(3, { 'output-tokens': '2' });
    
                updateInfoPanel(3, { 'output': 'Hallucinations significantly...' });
    
                document.getElementById('r4-computed-tokens').textContent = '34'; // 30 + 4
                highlightValue('r4-computed-tokens');
    
                updateInfoPanel(4, { 'output-tokens': '4' });
    
                updateInfoPanel(4, { 'output': 'Proprietary vs. Open-Source LLMs...' });
    
                document.getElementById('r5-computed-tokens').textContent = '132'; // 130 + 2
                highlightValue('r5-computed-tokens');
    
                updateInfoPanel(5, { 'output-tokens': '2' });
    
                updateInfoPanel(5, { 'output': 'Our comprehensive...' });
    
                // Update path history
                updateInfoPanel(1, { 'path-history': 'P D D D D D D' });
                updateInfoPanel(2, { 'path-history': 'P D D D D D' });
                updateInfoPanel(3, { 'path-history': 'P E E D D' });
                updateInfoPanel(4, { 'path-history': 'P D D D D' });
                updateInfoPanel(5, { 'path-history': 'P E D D' });
    
                await sleep(600);
    
                // Transform to square tokens
                allDecodeContainer_iter7.style.opacity = '0';
                await sleep(300);
    
                const tokenWidth_iter7 = 40;
                const r1SquareToken_iter7 = document.createElement('div');
                r1SquareToken_iter7.style.position = 'absolute';
                r1SquareToken_iter7.style.width = '40px';
                r1SquareToken_iter7.style.height = '40px';
                r1SquareToken_iter7.style.borderRadius = '4px';
                r1SquareToken_iter7.style.background = getRequestConfig(1).color;
                r1SquareToken_iter7.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter7.style.display = 'flex';
                r1SquareToken_iter7.style.alignItems = 'center';
                r1SquareToken_iter7.style.justifyContent = 'center';
                r1SquareToken_iter7.style.color = 'white';
                r1SquareToken_iter7.style.fontSize = '1.2em';
                r1SquareToken_iter7.style.fontWeight = 'bold';
                r1SquareToken_iter7.style.zIndex = '100';
                r1SquareToken_iter7.style.left = decodePathBoxLeft_iter7 + 'px';
                r1SquareToken_iter7.style.top = decodePathBoxTop_iter7 + 'px';
                r1SquareToken_iter7.innerHTML = '';
                flowDiagram.appendChild(r1SquareToken_iter7);
    
                const r2SquareToken_iter7 = r1SquareToken_iter7.cloneNode(true);
                r2SquareToken_iter7.style.background = getRequestConfig(2).color;
                r2SquareToken_iter7.style.left = (decodePathBoxLeft_iter7 + tokenWidth_iter7) + 'px';
                flowDiagram.appendChild(r2SquareToken_iter7);
    
                const r3SquareToken_iter7 = r1SquareToken_iter7.cloneNode(true);
                r3SquareToken_iter7.style.background = getRequestConfig(3).color;
                r3SquareToken_iter7.style.left = (decodePathBoxLeft_iter7 + tokenWidth_iter7 * 2) + 'px';
                flowDiagram.appendChild(r3SquareToken_iter7);
    
                const r4SquareToken_iter7 = r1SquareToken_iter7.cloneNode(true);
                r4SquareToken_iter7.style.background = getRequestConfig(4).color;
                r4SquareToken_iter7.style.left = (decodePathBoxLeft_iter7 + tokenWidth_iter7 * 3) + 'px';
                flowDiagram.appendChild(r4SquareToken_iter7);
    
                const r5SquareToken_iter7 = r1SquareToken_iter7.cloneNode(true);
                r5SquareToken_iter7.style.background = getRequestConfig(5).color;
                r5SquareToken_iter7.style.left = (decodePathBoxLeft_iter7 + tokenWidth_iter7 * 4) + 'px';
                flowDiagram.appendChild(r5SquareToken_iter7);
    
                await sleep(400);
    
                // Move to output box
                const outputModule_iter7 = document.getElementById('output');
                const outputRect_iter7 = outputModule_iter7.getBoundingClientRect();
                const outputTop_iter7 = outputRect_iter7.top - flowRect.top + 5;
    
                r1SquareToken_iter7.style.transition = 'all 0.8s ease';
                r1SquareToken_iter7.style.left = '180px';
                r1SquareToken_iter7.style.top = outputTop_iter7 + 'px';
                r1SquareToken_iter7.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter7.style.transition = 'all 0.8s ease';
                r2SquareToken_iter7.style.left = '255px';
                r2SquareToken_iter7.style.top = outputTop_iter7 + 'px';
                r2SquareToken_iter7.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter7.style.transition = 'all 0.8s ease';
                r3SquareToken_iter7.style.left = '330px';
                r3SquareToken_iter7.style.top = outputTop_iter7 + 'px';
                r3SquareToken_iter7.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter7.style.transition = 'all 0.8s ease';
                r4SquareToken_iter7.style.left = '405px';
                r4SquareToken_iter7.style.top = outputTop_iter7 + 'px';
                r4SquareToken_iter7.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter7.style.transition = 'all 0.8s ease';
                r5SquareToken_iter7.style.left = '480px';
                r5SquareToken_iter7.style.top = outputTop_iter7 + 'px';
                r5SquareToken_iter7.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                r1SquareToken_iter7.innerHTML = '1';
                r2SquareToken_iter7.innerHTML = '1';
                r3SquareToken_iter7.innerHTML = '1';
                r4SquareToken_iter7.innerHTML = '1';
                r5SquareToken_iter7.innerHTML = '1';
    
                await sleep(500);
    

    // ========== ITERATION 7 CODE ENDS ==========

    // Write outputs to state
    // (Outputs depend on what this iteration creates - update as needed)
}


/**
 * Run Iteration 6
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout
 * - Square tokens from iter 5
 *
 * OUTPUTS (to state):
 * - Final square token positions
 */
async function runIteration6(state) {
    // Show timeline highlight for iteration 6
    showTimelineHighlight(6);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from previous iterations (will be used if needed)
    let r5Circle = state.circles[5];
    let r1Token_iter3 = state.containers.r1Container;
    let r2Token_iter3 = state.containers.r2Container;
    let r3Token_iter3 = state.containers.r3Container;
    let r4Token_iter3 = state.containers.r4Container;

    // Previous iteration outputs (if they exist)
    let r1SquareToken_iter4 = state.containers.r1SquareToken_iter4;
    let r2SquareToken_iter4 = state.containers.r2SquareToken_iter4;
    let r3SquareToken_iter4 = state.containers.r3SquareToken_iter4;
    let r4SquareToken_iter4 = state.containers.r4SquareToken_iter4;
    let r5SquareToken_iter4 = state.containers.r5SquareToken_iter4;

    let r1SquareToken_iter5 = state.containers.r1SquareToken_iter5;
    let r2SquareToken_iter5 = state.containers.r2SquareToken_iter5;
    let r3SquareToken_iter5 = state.containers.r3SquareToken_iter5;
    let r4SquareToken_iter5 = state.containers.r4SquareToken_iter5;
    let r5SquareToken_iter5 = state.containers.r5SquareToken_iter5;

    let r1SquareToken_iter6 = state.containers.r1SquareToken_iter6;
    let r2SquareToken_iter6 = state.containers.r2SquareToken_iter6;
    let r3SquareToken_iter6 = state.containers.r3SquareToken_iter6;
    let r4SquareToken_iter6 = state.containers.r4SquareToken_iter6;
    let r5SquareToken_iter6 = state.containers.r5SquareToken_iter6;

    // ========== ITERATION 6 CODE STARTS ==========

                // ITERATION 6: All 5 requests in decode (R1, R2, R3, R4, R5)
                // ============================================================================
    
                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 6';
    
                await sleep(500);
    
                // Circles from iteration 5 are already at scheduler
                // Move to Model Runner at the same position as iteration 5 (Reorder Batch substep)
                const substep4_iter6 = document.getElementById('substep4');
                const substep4Rect_iter6 = substep4_iter6.getBoundingClientRect();
                const reorderBatchBottom_iter6 = substep4Rect_iter6.bottom - flowRect.top;
                const circleTopPosition_iter6 = reorderBatchBottom_iter6 + 5 + (35 / 2) - 20;
    
                r1SquareToken_iter5.style.transition = 'all 0.8s ease';
                r1SquareToken_iter5.style.top = circleTopPosition_iter6 + 'px';
                r2SquareToken_iter5.style.transition = 'all 0.8s ease';
                r2SquareToken_iter5.style.top = circleTopPosition_iter6 + 'px';
                r3SquareToken_iter5.style.transition = 'all 0.8s ease';
                r3SquareToken_iter5.style.top = circleTopPosition_iter6 + 'px';
                r4SquareToken_iter5.style.transition = 'all 0.8s ease';
                r4SquareToken_iter5.style.top = circleTopPosition_iter6 + 'px';
                r5SquareToken_iter5.style.transition = 'all 0.8s ease';
                r5SquareToken_iter5.style.top = circleTopPosition_iter6 + 'px';
    
                await sleep(800);
    
                // Update info panels when tokens exit scheduler for iteration 6
                // R1: Decode stage
                updateInfoPanel(1, { 'scheduled-tokens': '1' });
    
                // R2: Decode stage
                updateInfoPanel(2, { 'scheduled-tokens': '1' });
    
                // R3: Decode stage (first decode after extend)
                updateInfoPanel(3, { 'scheduled-tokens': '1' });
    
                // R4: Decode stage
                updateInfoPanel(4, { 'scheduled-tokens': '1' });
    
                // R5: Decode stage (first decode after extend)
                updateInfoPanel(5, { 'scheduled-tokens': '1' });
    
                await sleep(500);
    
                // ========== ITERATION 6: Transform to horizontal bar with 5 segments ==========
    
                // Calculate segment widths (R1: 1, R2: 1, R3: 1, R4: 1, R5: 1, total: 5 - all decode)
                const r1Tokens_iter6 = 1;
                const r2Tokens_iter6 = 1;
                const r3Tokens_iter6 = 1;
                const r4Tokens_iter6 = 1;
                const r5Tokens_iter6 = 1;
                const totalTokens_iter6 = r1Tokens_iter6 + r2Tokens_iter6 + r3Tokens_iter6 + r4Tokens_iter6 + r5Tokens_iter6;
                const totalBarWidth_iter6 = 470;
                const minSegmentWidth_iter6 = 40;
    
                // All segments are equal width (1 token each)
                const segmentWidth_iter6 = totalBarWidth_iter6 / totalTokens_iter6;
    
                // Hide all circles
                r1SquareToken_iter5.style.opacity = '0';
                r2SquareToken_iter5.style.opacity = '0';
                r3SquareToken_iter5.style.opacity = '0';
                r4SquareToken_iter5.style.opacity = '0';
                r5SquareToken_iter5.style.opacity = '0';
    
                await sleep(300);
    
                // Create new container for 5-segment bar
                const barContainer_iter6 = document.createElement('div');
                barContainer_iter6.style.position = 'absolute';
                barContainer_iter6.style.left = '50%';
                barContainer_iter6.style.top = circleTopPosition_iter6 + 'px';
                barContainer_iter6.style.transform = 'translateX(-50%)';
                barContainer_iter6.style.width = totalBarWidth_iter6 + 'px';
                barContainer_iter6.style.height = '25px';
                barContainer_iter6.style.display = 'flex';
                barContainer_iter6.style.zIndex = '100';
                barContainer_iter6.innerHTML = `
                    <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R1</div>
                    <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R2</div>
                    <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R3</div>
                    <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R4</div>
                    <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R5</div>
                `;
                flowDiagram.appendChild(barContainer_iter6);
    
                await sleep(500);
    
                // ========== ITERATION 6: Show query_start_loc arrows ==========
    
                const barRect_iter6 = barContainer_iter6.getBoundingClientRect();
                const barLeftEdge_iter6 = barRect_iter6.left - flowRect.left;
                const barTop_iter6 = barRect_iter6.top - flowRect.top;
                const barHeight_iter6 = 25;
    
                const queryArrows_iter6 = [];
                const arrowPositions_iter6 = [
                    { offset: 0, value: '0' }, // R1 starts at 0
                    { offset: segmentWidth_iter6, value: '1' }, // R2 starts at 1
                    { offset: segmentWidth_iter6 * 2, value: '2' }, // R3 starts at 2
                    { offset: segmentWidth_iter6 * 3, value: '3' }, // R4 starts at 3
                    { offset: segmentWidth_iter6 * 4, value: '4' } // R5 starts at 4
                ];
    
                arrowPositions_iter6.forEach(pos => {
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.display = 'flex';
                    arrow.style.flexDirection = 'column';
                    arrow.style.alignItems = 'center';
                    arrow.style.zIndex = '100';
                    arrow.innerHTML = `
                        <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                        <div style="font-size: 0.75em; color: #000000; font-weight: bold;">${pos.value}</div>
                    `;
                    // Add 2px offset to account for the left border
                    arrow.style.left = (barLeftEdge_iter6 + pos.offset + 2) + 'px';
                    arrow.style.top = (barTop_iter6 + barHeight_iter6 + 5) + 'px';
                    flowDiagram.appendChild(arrow);
                    queryArrows_iter6.push(arrow);
                });
    
                await sleep(2000);
    
                // Remove arrows
                queryArrows_iter6.forEach(arrow => arrow.remove());
    
                // ========== ITERATION 6: Transform to QKV bars ==========
    
                const substep3_iter6 = document.getElementById('substep3');
                substep3_iter6.classList.add('active');
    
                await sleep(500);
    
                barContainer_iter6.style.opacity = '0';
    
                await sleep(300);
    
                // Create QKV bars container with 5 segments
                const qkvBarsContainer_iter6 = document.createElement('div');
                qkvBarsContainer_iter6.style.position = 'absolute';
                qkvBarsContainer_iter6.style.left = '50%';
                qkvBarsContainer_iter6.style.top = circleTopPosition_iter6 + 'px';
                qkvBarsContainer_iter6.style.transform = 'translateX(-50%)';
                qkvBarsContainer_iter6.style.width = totalBarWidth_iter6 + 'px';
                qkvBarsContainer_iter6.style.display = 'block';
                qkvBarsContainer_iter6.style.zIndex = '100';
                qkvBarsContainer_iter6.style.opacity = '0';
                qkvBarsContainer_iter6.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer_iter6.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${segmentWidth_iter6}px; height: 25px; background: #0e6655; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvBarsContainer_iter6);
    
                barContainer_iter6.remove();
    
                await sleep(100);
    
                // Fade in QKV bars
                qkvBarsContainer_iter6.style.opacity = '1';
    
                await sleep(1500);
    
                substep3_iter6.classList.remove('active');
    
                // Move QKV bars to Attention module (below classification substep)
                const attentionModule_iter6 = document.getElementById('attention');
                const attentionRect_iter6 = attentionModule_iter6.getBoundingClientRect();
                const classificationSubstep_iter6 = document.getElementById('classificationSubstep');
                const classificationRect_iter6 = classificationSubstep_iter6.getBoundingClientRect();
                const classificationBottom_iter6 = classificationRect_iter6.bottom - flowRect.top;
                const qkvTargetTop_iter6 = classificationBottom_iter6 + 5;
    
                qkvBarsContainer_iter6.style.transition = 'all 0.8s ease';
                qkvBarsContainer_iter6.style.top = qkvTargetTop_iter6 + 'px';
    
                await sleep(800);
    
                // Classification: All decode (orange)
                classificationSubstep_iter6.style.background = 'rgba(255, 193, 7, 0.3)';
                classificationSubstep_iter6.style.borderColor = '#ffc107';
    
                const decodeColor_iter6 = '#e67e22';
    
                // Get all segments from qkvBarsContainer_iter6
                const rowDivs_iter6 = qkvBarsContainer_iter6.children;
                const allSegments_iter6 = [];
                for (let i = 0; i < rowDivs_iter6.length; i++) {
                    const row = rowDivs_iter6[i];
                    const segments = row.children;
                    for (let j = 0; j < segments.length; j++) {
                        const segment = segments[j];
                        segment.style.transition = 'background 0.6s ease';
                        segment.style.background = decodeColor_iter6;
                        allSegments_iter6.push(segment);
                    }
                }
    
                await sleep(600);
    
                classificationSubstep_iter6.style.background = '';
                classificationSubstep_iter6.style.borderColor = '#ddd';
    
                // ========== ITERATION 6: Move all segments to decode path box (all 5 requests are decode) ==========
    
                // Get current position and width of qkvBarsContainer_iter6
                const qkvContainerRect_iter6 = qkvBarsContainer_iter6.getBoundingClientRect();
                const qkvCurrentLeft_iter6 = qkvContainerRect_iter6.left - flowRect.left;
                const qkvCurrentTop_iter6 = qkvContainerRect_iter6.top - flowRect.top;
                const qkvCurrentWidth_iter6 = qkvContainerRect_iter6.width;
    
                // Get all segments
                const allQKVSegments_iter6 = [];
                for (let i = 0; i < rowDivs_iter6.length; i++) {
                    const row = rowDivs_iter6[i];
                    const segments = row.children;
                    for (let j = 0; j < segments.length; j++) {
                        allQKVSegments_iter6.push(segments[j]);
                    }
                }
    
                // Extract individual segments (5 segments per row, 3 rows = 15 total)
                const qR1_iter6 = allQKVSegments_iter6[0];
                const qR2_iter6 = allQKVSegments_iter6[1];
                const qR3_iter6 = allQKVSegments_iter6[2];
                const qR4_iter6 = allQKVSegments_iter6[3];
                const qR5_iter6 = allQKVSegments_iter6[4];
                const kR1_iter6 = allQKVSegments_iter6[5];
                const kR2_iter6 = allQKVSegments_iter6[6];
                const kR3_iter6 = allQKVSegments_iter6[7];
                const kR4_iter6 = allQKVSegments_iter6[8];
                const kR5_iter6 = allQKVSegments_iter6[9];
                const vR1_iter6 = allQKVSegments_iter6[10];
                const vR2_iter6 = allQKVSegments_iter6[11];
                const vR3_iter6 = allQKVSegments_iter6[12];
                const vR4_iter6 = allQKVSegments_iter6[13];
                const vR5_iter6 = allQKVSegments_iter6[14];
    
                // Create a new container for all 5 requests that will move to decode path
                const allDecodeContainer_iter6 = document.createElement('div');
                allDecodeContainer_iter6.style.position = 'absolute';
                allDecodeContainer_iter6.style.left = qkvCurrentLeft_iter6 + 'px';
                allDecodeContainer_iter6.style.top = qkvCurrentTop_iter6 + 'px';
                allDecodeContainer_iter6.style.width = qkvCurrentWidth_iter6 + 'px';
                allDecodeContainer_iter6.style.display = 'flex';
                allDecodeContainer_iter6.style.flexDirection = 'column';
                allDecodeContainer_iter6.style.gap = '0px';
                allDecodeContainer_iter6.style.zIndex = '100';
    
                // Clone all segments
                const qR1Clone_iter6 = qR1_iter6.cloneNode(true);
                const qR2Clone_iter6 = qR2_iter6.cloneNode(true);
                const qR3Clone_iter6 = qR3_iter6.cloneNode(true);
                const qR4Clone_iter6 = qR4_iter6.cloneNode(true);
                const qR5Clone_iter6 = qR5_iter6.cloneNode(true);
                const kR1Clone_iter6 = kR1_iter6.cloneNode(true);
                const kR2Clone_iter6 = kR2_iter6.cloneNode(true);
                const kR3Clone_iter6 = kR3_iter6.cloneNode(true);
                const kR4Clone_iter6 = kR4_iter6.cloneNode(true);
                const kR5Clone_iter6 = kR5_iter6.cloneNode(true);
                const vR1Clone_iter6 = vR1_iter6.cloneNode(true);
                const vR2Clone_iter6 = vR2_iter6.cloneNode(true);
                const vR3Clone_iter6 = vR3_iter6.cloneNode(true);
                const vR4Clone_iter6 = vR4_iter6.cloneNode(true);
                const vR5Clone_iter6 = vR5_iter6.cloneNode(true);
    
                // Get original widths (all segments are equal width)
                const r1OriginalWidth_iter6 = qR1_iter6.getBoundingClientRect().width;
                const r2OriginalWidth_iter6 = qR2_iter6.getBoundingClientRect().width;
                const r3OriginalWidth_iter6 = qR3_iter6.getBoundingClientRect().width;
                const r4OriginalWidth_iter6 = qR4_iter6.getBoundingClientRect().width;
                const r5OriginalWidth_iter6 = qR5_iter6.getBoundingClientRect().width;
                const totalOriginalWidth_iter6 = r1OriginalWidth_iter6 + r2OriginalWidth_iter6 + r3OriginalWidth_iter6 + r4OriginalWidth_iter6 + r5OriginalWidth_iter6;
    
                // Calculate percentage widths
                const r1WidthPercent_iter6 = (r1OriginalWidth_iter6 / totalOriginalWidth_iter6 * 100) + '%';
                const r2WidthPercent_iter6 = (r2OriginalWidth_iter6 / totalOriginalWidth_iter6 * 100) + '%';
                const r3WidthPercent_iter6 = (r3OriginalWidth_iter6 / totalOriginalWidth_iter6 * 100) + '%';
                const r4WidthPercent_iter6 = (r4OriginalWidth_iter6 / totalOriginalWidth_iter6 * 100) + '%';
                const r5WidthPercent_iter6 = (r5OriginalWidth_iter6 / totalOriginalWidth_iter6 * 100) + '%';
    
                // Set percentage widths on clones
                qR1Clone_iter6.style.width = r1WidthPercent_iter6;
                qR2Clone_iter6.style.width = r2WidthPercent_iter6;
                qR3Clone_iter6.style.width = r3WidthPercent_iter6;
                qR4Clone_iter6.style.width = r4WidthPercent_iter6;
                qR5Clone_iter6.style.width = r5WidthPercent_iter6;
                kR1Clone_iter6.style.width = r1WidthPercent_iter6;
                kR2Clone_iter6.style.width = r2WidthPercent_iter6;
                kR3Clone_iter6.style.width = r3WidthPercent_iter6;
                kR4Clone_iter6.style.width = r4WidthPercent_iter6;
                kR5Clone_iter6.style.width = r5WidthPercent_iter6;
                vR1Clone_iter6.style.width = r1WidthPercent_iter6;
                vR2Clone_iter6.style.width = r2WidthPercent_iter6;
                vR3Clone_iter6.style.width = r3WidthPercent_iter6;
                vR4Clone_iter6.style.width = r4WidthPercent_iter6;
                vR5Clone_iter6.style.width = r5WidthPercent_iter6;
    
                // Set flex-shrink to 0
                qR1Clone_iter6.style.flexShrink = '0';
                qR2Clone_iter6.style.flexShrink = '0';
                qR3Clone_iter6.style.flexShrink = '0';
                qR4Clone_iter6.style.flexShrink = '0';
                qR5Clone_iter6.style.flexShrink = '0';
                kR1Clone_iter6.style.flexShrink = '0';
                kR2Clone_iter6.style.flexShrink = '0';
                kR3Clone_iter6.style.flexShrink = '0';
                kR4Clone_iter6.style.flexShrink = '0';
                kR5Clone_iter6.style.flexShrink = '0';
                vR1Clone_iter6.style.flexShrink = '0';
                vR2Clone_iter6.style.flexShrink = '0';
                vR3Clone_iter6.style.flexShrink = '0';
                vR4Clone_iter6.style.flexShrink = '0';
                vR5Clone_iter6.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_all_iter6 = document.createElement('div');
                qRow_all_iter6.style.display = 'flex';
                qRow_all_iter6.style.width = '100%';
                qRow_all_iter6.appendChild(qR1Clone_iter6);
                qRow_all_iter6.appendChild(qR2Clone_iter6);
                qRow_all_iter6.appendChild(qR3Clone_iter6);
                qRow_all_iter6.appendChild(qR4Clone_iter6);
                qRow_all_iter6.appendChild(qR5Clone_iter6);
    
                const kRow_all_iter6 = document.createElement('div');
                kRow_all_iter6.style.display = 'flex';
                kRow_all_iter6.style.width = '100%';
                kRow_all_iter6.appendChild(kR1Clone_iter6);
                kRow_all_iter6.appendChild(kR2Clone_iter6);
                kRow_all_iter6.appendChild(kR3Clone_iter6);
                kRow_all_iter6.appendChild(kR4Clone_iter6);
                kRow_all_iter6.appendChild(kR5Clone_iter6);
    
                const vRow_all_iter6 = document.createElement('div');
                vRow_all_iter6.style.display = 'flex';
                vRow_all_iter6.style.width = '100%';
                vRow_all_iter6.appendChild(vR1Clone_iter6);
                vRow_all_iter6.appendChild(vR2Clone_iter6);
                vRow_all_iter6.appendChild(vR3Clone_iter6);
                vRow_all_iter6.appendChild(vR4Clone_iter6);
                vRow_all_iter6.appendChild(vR5Clone_iter6);
    
                // Append rows to container
                allDecodeContainer_iter6.appendChild(qRow_all_iter6);
                allDecodeContainer_iter6.appendChild(kRow_all_iter6);
                allDecodeContainer_iter6.appendChild(vRow_all_iter6);
    
                flowDiagram.appendChild(allDecodeContainer_iter6);
    
                // Hide original qkvBarsContainer_iter6
                qkvBarsContainer_iter6.style.opacity = '0';
    
                await sleep(200);
    
                // Get decode path box position
                const decodePathBox_iter6 = document.getElementById('decodePath');
                const decodePathRect_iter6 = decodePathBox_iter6.getBoundingClientRect();
                const decodePathBoxTop_iter6 = decodePathRect_iter6.top - flowRect.top;
                const decodePathBoxWidth_iter6 = decodePathRect_iter6.width;
                const decodePathBoxLeft_iter6 = decodePathRect_iter6.left - flowRect.left;
    
                // Move and resize to decode path box
                allDecodeContainer_iter6.style.transition = 'all 0.6s ease';
                allDecodeContainer_iter6.style.left = decodePathBoxLeft_iter6 + 'px';
                allDecodeContainer_iter6.style.top = decodePathBoxTop_iter6 + 'px';
                allDecodeContainer_iter6.style.width = decodePathBoxWidth_iter6 + 'px';
    
                // Update info panels when entering decode path
                document.getElementById('r1-path').textContent = 'Decode';
                document.getElementById('r2-path').textContent = 'Decode';
                document.getElementById('r3-path').textContent = 'Decode';
                document.getElementById('r4-path').textContent = 'Decode';
                document.getElementById('r5-path').textContent = 'Decode';
    
                document.getElementById('r1-computed-tokens').textContent = '9'; // 4 + 5
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '5' });
    
                updateInfoPanel(1, { 'output': 'Effective prompt engineering for large' });
    
                document.getElementById('r2-computed-tokens').textContent = '64'; // 60 + 4
                highlightValue('r2-computed-tokens');
    
                updateInfoPanel(2, { 'output-tokens': '4' });
    
                updateInfoPanel(2, { 'output': 'The foundation of successful' });
    
                document.getElementById('r3-computed-tokens').textContent = '281'; // 280 + 1
                highlightValue('r3-computed-tokens');
    
                updateInfoPanel(3, { 'output-tokens': '1' });
    
                updateInfoPanel(3, { 'output': 'Hallucinations' });
    
                document.getElementById('r4-computed-tokens').textContent = '33'; // 30 + 3
                highlightValue('r4-computed-tokens');
    
                updateInfoPanel(4, { 'output-tokens': '3' });
    
                updateInfoPanel(4, { 'output': 'Proprietary vs. Open-Source' });
    
                document.getElementById('r5-computed-tokens').textContent = '131'; // 130 + 1
                highlightValue('r5-computed-tokens');
    
                updateInfoPanel(5, { 'output-tokens': '1' });
    
                updateInfoPanel(5, { 'output': 'Our' });
    
                // Update path history
                updateInfoPanel(1, { 'path-history': 'P D D D D D' });
                updateInfoPanel(2, { 'path-history': 'P D D D D' });
                updateInfoPanel(3, { 'path-history': 'P E E D' });
                updateInfoPanel(4, { 'path-history': 'P D D D' });
                updateInfoPanel(5, { 'path-history': 'P E D' });
    
                await sleep(600);
    
                // Transform to square tokens
                allDecodeContainer_iter6.style.opacity = '0';
                await sleep(300);
    
                const tokenWidth_iter6 = 40;
                r1SquareToken_iter6 = document.createElement('div');
                r1SquareToken_iter6.style.position = 'absolute';
                r1SquareToken_iter6.style.width = '40px';
                r1SquareToken_iter6.style.height = '40px';
                r1SquareToken_iter6.style.borderRadius = '4px';
                r1SquareToken_iter6.style.background = getRequestConfig(1).color;
                r1SquareToken_iter6.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter6.style.display = 'flex';
                r1SquareToken_iter6.style.alignItems = 'center';
                r1SquareToken_iter6.style.justifyContent = 'center';
                r1SquareToken_iter6.style.color = 'white';
                r1SquareToken_iter6.style.fontSize = '1.2em';
                r1SquareToken_iter6.style.fontWeight = 'bold';
                r1SquareToken_iter6.style.zIndex = '100';
                r1SquareToken_iter6.style.left = decodePathBoxLeft_iter6 + 'px';
                r1SquareToken_iter6.style.top = decodePathBoxTop_iter6 + 'px';
                r1SquareToken_iter6.innerHTML = '';
                flowDiagram.appendChild(r1SquareToken_iter6);

                r2SquareToken_iter6 = r1SquareToken_iter6.cloneNode(true);
                r2SquareToken_iter6.style.background = getRequestConfig(2).color;
                r2SquareToken_iter6.style.left = (decodePathBoxLeft_iter6 + tokenWidth_iter6) + 'px';
                flowDiagram.appendChild(r2SquareToken_iter6);

                r3SquareToken_iter6 = r1SquareToken_iter6.cloneNode(true);
                r3SquareToken_iter6.style.background = getRequestConfig(3).color;
                r3SquareToken_iter6.style.left = (decodePathBoxLeft_iter6 + tokenWidth_iter6 * 2) + 'px';
                flowDiagram.appendChild(r3SquareToken_iter6);

                r4SquareToken_iter6 = r1SquareToken_iter6.cloneNode(true);
                r4SquareToken_iter6.style.background = getRequestConfig(4).color;
                r4SquareToken_iter6.style.left = (decodePathBoxLeft_iter6 + tokenWidth_iter6 * 3) + 'px';
                flowDiagram.appendChild(r4SquareToken_iter6);

                r5SquareToken_iter6 = r1SquareToken_iter6.cloneNode(true);
                r5SquareToken_iter6.style.background = getRequestConfig(5).color;
                r5SquareToken_iter6.style.left = (decodePathBoxLeft_iter6 + tokenWidth_iter6 * 4) + 'px';
                flowDiagram.appendChild(r5SquareToken_iter6);
    
                await sleep(400);
    
                // Move to output box
                const outputModule_iter6 = document.getElementById('output');
                const outputRect_iter6 = outputModule_iter6.getBoundingClientRect();
                const outputTop_iter6 = outputRect_iter6.top - flowRect.top + 5;
    
                r1SquareToken_iter6.style.transition = 'all 0.8s ease';
                r1SquareToken_iter6.style.left = '180px';
                r1SquareToken_iter6.style.top = outputTop_iter6 + 'px';
                r1SquareToken_iter6.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter6.style.transition = 'all 0.8s ease';
                r2SquareToken_iter6.style.left = '255px';
                r2SquareToken_iter6.style.top = outputTop_iter6 + 'px';
                r2SquareToken_iter6.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter6.style.transition = 'all 0.8s ease';
                r3SquareToken_iter6.style.left = '330px';
                r3SquareToken_iter6.style.top = outputTop_iter6 + 'px';
                r3SquareToken_iter6.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter6.style.transition = 'all 0.8s ease';
                r4SquareToken_iter6.style.left = '405px';
                r4SquareToken_iter6.style.top = outputTop_iter6 + 'px';
                r4SquareToken_iter6.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter6.style.transition = 'all 0.8s ease';
                r5SquareToken_iter6.style.left = '480px';
                r5SquareToken_iter6.style.top = outputTop_iter6 + 'px';
                r5SquareToken_iter6.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                r1SquareToken_iter6.innerHTML = '1';
                r2SquareToken_iter6.innerHTML = '1';
                r3SquareToken_iter6.innerHTML = '1';
                r4SquareToken_iter6.innerHTML = '1';
                r5SquareToken_iter6.innerHTML = '1';
    
                await sleep(500);
    
                // Move to scheduler
                const schedulerModule_iter6 = document.getElementById('scheduler');
                const schedulerRect_iter6 = schedulerModule_iter6.getBoundingClientRect();
                const schedulerTop_iter6 = schedulerRect_iter6.top - flowRect.top + schedulerRect_iter6.height / 2 - 20;
    
                r1SquareToken_iter6.style.transition = 'all 0.8s ease';
                r1SquareToken_iter6.style.top = schedulerTop_iter6 + 'px';
                r2SquareToken_iter6.style.transition = 'all 0.8s ease';
                r2SquareToken_iter6.style.top = schedulerTop_iter6 + 'px';
                r3SquareToken_iter6.style.transition = 'all 0.8s ease';
                r3SquareToken_iter6.style.top = schedulerTop_iter6 + 'px';
                r4SquareToken_iter6.style.transition = 'all 0.8s ease';
                r4SquareToken_iter6.style.top = schedulerTop_iter6 + 'px';
                r5SquareToken_iter6.style.transition = 'all 0.8s ease';
                r5SquareToken_iter6.style.top = schedulerTop_iter6 + 'px';
    
                await sleep(800);
    
                // Transform to circles
                r1SquareToken_iter6.style.transition = 'all 0.6s ease';
                r1SquareToken_iter6.style.width = '35px';
                r1SquareToken_iter6.style.height = '35px';
                r1SquareToken_iter6.style.borderRadius = '50%';
                r1SquareToken_iter6.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r2SquareToken_iter6.style.transition = 'all 0.6s ease';
                r2SquareToken_iter6.style.width = '35px';
                r2SquareToken_iter6.style.height = '35px';
                r2SquareToken_iter6.style.borderRadius = '50%';
                r2SquareToken_iter6.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r3SquareToken_iter6.style.transition = 'all 0.6s ease';
                r3SquareToken_iter6.style.width = '35px';
                r3SquareToken_iter6.style.height = '35px';
                r3SquareToken_iter6.style.borderRadius = '50%';
                r3SquareToken_iter6.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r4SquareToken_iter6.style.transition = 'all 0.6s ease';
                r4SquareToken_iter6.style.width = '35px';
                r4SquareToken_iter6.style.height = '35px';
                r4SquareToken_iter6.style.borderRadius = '50%';
                r4SquareToken_iter6.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r5SquareToken_iter6.style.transition = 'all 0.6s ease';
                r5SquareToken_iter6.style.width = '35px';
                r5SquareToken_iter6.style.height = '35px';
                r5SquareToken_iter6.style.borderRadius = '50%';
                r5SquareToken_iter6.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                await sleep(600);
    

    // ========== ITERATION 6 CODE ENDS ==========

    // Write outputs to state
    state.containers.r1SquareToken_iter6 = r1SquareToken_iter6;
    state.containers.r2SquareToken_iter6 = r2SquareToken_iter6;
    state.containers.r3SquareToken_iter6 = r3SquareToken_iter6;
    state.containers.r4SquareToken_iter6 = r4SquareToken_iter6;
    state.containers.r5SquareToken_iter6 = r5SquareToken_iter6;
}


/**
 * Run Iteration 5
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout
 * - Previous iteration outputs (r1-r5 square tokens from iter 4)
 * - state.containers.r3RemainingCircle (from iter 3)
 * - state.containers.r5RemainingCircle (from iter 4)
 *
 * OUTPUTS (to state):
 * - Updates to square tokens (transitions to iter 5)
 */
async function runIteration5(state) {
    // Show timeline highlight for iteration 5
    showTimelineHighlight(5);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from previous iterations (will be used if needed)
    let r5Circle = state.circles[5];
    let r1Token_iter3 = state.containers.r1Container;
    let r2Token_iter3 = state.containers.r2Container;
    let r3Token_iter3 = state.containers.r3Container;
    let r4Token_iter3 = state.containers.r4Container;

    // Previous iteration outputs (if they exist)
    let r1SquareToken_iter4 = state.containers.r1SquareToken_iter4;
    let r2SquareToken_iter4 = state.containers.r2SquareToken_iter4;
    let r3SquareToken_iter4 = state.containers.r3SquareToken_iter4;
    let r4SquareToken_iter4 = state.containers.r4SquareToken_iter4;
    let r5SquareToken_iter4 = state.containers.r5SquareToken_iter4;

    let r1SquareToken_iter5 = state.containers.r1SquareToken_iter5;
    let r2SquareToken_iter5 = state.containers.r2SquareToken_iter5;
    let r3SquareToken_iter5 = state.containers.r3SquareToken_iter5;
    let r4SquareToken_iter5 = state.containers.r4SquareToken_iter5;
    let r5SquareToken_iter5 = state.containers.r5SquareToken_iter5;

    let r1SquareToken_iter6 = state.containers.r1SquareToken_iter6;
    let r2SquareToken_iter6 = state.containers.r2SquareToken_iter6;
    let r3SquareToken_iter6 = state.containers.r3SquareToken_iter6;
    let r4SquareToken_iter6 = state.containers.r4SquareToken_iter6;
    let r5SquareToken_iter6 = state.containers.r5SquareToken_iter6;

    // Remaining circles from previous iterations
    let r3RemainingCircle = state.containers.r3RemainingCircle; // From iteration 3
    let r5RemainingCircle = state.containers.r5RemainingCircle; // From iteration 4

    // ========== ITERATION 5 CODE STARTS ==========

                // ITERATION 5: R1 decode, R2 decode, R3 extend, R4 decode, R5 extend
                // ============================================================================
    
                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 5';
    
                await sleep(500);
    
                // ========== ITERATION 5: Update token values and remove grey circles ==========
    
                // Update token circles to show iteration 5 values
                // R1: 1 (decode stage)
                // R2: 1 (decode stage)
                // R3: 80 (extend stage - schedule 80, grey circle disappears as all prompt tokens done)
                // R4: 1 (decode stage)
                // R5: 30 (extend stage - schedule 30, grey circle disappears as all prompt tokens done)
    
                r1SquareToken_iter4.innerHTML = '1';
                r2SquareToken_iter4.innerHTML = '1';
                r3SquareToken_iter4.innerHTML = '80';
                r4SquareToken_iter4.innerHTML = '1';
                r5SquareToken_iter4.innerHTML = '30';
    
                await sleep(500);
    
                // PARALLEL: Fade out both grey circles (R3 and R5) together
                // R3's grey circle shows it finished all remaining prompt tokens
                // R5's grey circle shows it finished all remaining prompt tokens
                (async () => {
                    r3RemainingCircle.style.transition = 'opacity 0.8s ease';
                    r3RemainingCircle.style.opacity = '0';
    
                    await sleep(800);
                    r3RemainingCircle.remove();
                })();
    
                (async () => {
                    r5RemainingCircle.style.transition = 'opacity 0.8s ease';
                    r5RemainingCircle.style.opacity = '0';
    
                    await sleep(800);
                    r5RemainingCircle.remove();
                })();
    
                await sleep(800);
    
                // Update info panels for iteration 5 scheduler exit
                // R3: Extend stage (chunked continuation) - processing another 100 tokens
                updateInfoPanel(3, { 'remaining-tokens': '80' });
    
                updateInfoPanel(3, { 'scheduled-tokens': '100' });
    
                // R5: Extend stage (chunked continuation) - processing another 30 tokens (finish prompt)
                updateInfoPanel(5, { 'remaining-tokens': '0' });
    
                updateInfoPanel(5, { 'scheduled-tokens': '30' });
    
                await sleep(500);
    
                // ========== ITERATION 5: Move circles to Model Runner ==========
    
                // Get Model Runner position (Reorder Batch substep)
                const substep4_iter5 = document.getElementById('substep4');
                const substep4Rect_iter5 = substep4_iter5.getBoundingClientRect();
                const reorderBatchBottom_iter5 = substep4Rect_iter5.bottom - flowRect.top;
                const circleTopPosition_iter5 = reorderBatchBottom_iter5 + 5 + (35 / 2) - 20;
    
                // Move all 5 circles down together (only change top position)
                r1SquareToken_iter4.style.transition = 'all 0.8s ease';
                r1SquareToken_iter4.style.top = circleTopPosition_iter5 + 'px';
    
                r2SquareToken_iter4.style.transition = 'all 0.8s ease';
                r2SquareToken_iter4.style.top = circleTopPosition_iter5 + 'px';
    
                r3SquareToken_iter4.style.transition = 'all 0.8s ease';
                r3SquareToken_iter4.style.top = circleTopPosition_iter5 + 'px';
    
                r4SquareToken_iter4.style.transition = 'all 0.8s ease';
                r4SquareToken_iter4.style.top = circleTopPosition_iter5 + 'px';
    
                r5SquareToken_iter4.style.transition = 'all 0.8s ease';
                r5SquareToken_iter4.style.top = circleTopPosition_iter5 + 'px';
    
                await sleep(800);
    
                // Update info panels when tokens exit scheduler for iteration 5
                // R1: Decode stage
                updateInfoPanel(1, { 'scheduled-tokens': '1' });
    
                // R2: Decode stage
                updateInfoPanel(2, { 'scheduled-tokens': '1' });
    
                // R3: Extend stage (finish remaining 80 tokens)
                updateInfoPanel(3, { 'remaining-tokens': '0' });
    
                updateInfoPanel(3, { 'scheduled-tokens': '80' });
    
                // R4: Decode stage
                updateInfoPanel(4, { 'scheduled-tokens': '1' });
    
                // R5: Extend stage (process remaining 30 tokens - finish prompt)
                updateInfoPanel(5, { 'remaining-tokens': '0' });
    
                updateInfoPanel(5, { 'scheduled-tokens': '30' });
    
                await sleep(500);
    
                // ========== ITERATION 5: Transform to horizontal bar with 5 segments ==========
    
                // Calculate segment widths (R1: 1, R2: 1, R3: 80, R4: 1, R5: 30, total: 113)
                const r1Tokens_iter5 = 1;
                const r2Tokens_iter5 = 1;
                const r3Tokens_iter5 = 80;
                const r4Tokens_iter5 = 1;
                const r5Tokens_iter5 = 30;
                const totalTokens_iter5 = r1Tokens_iter5 + r2Tokens_iter5 + r3Tokens_iter5 + r4Tokens_iter5 + r5Tokens_iter5;
                const totalBarWidth_iter5 = 470;
                const minSegmentWidth_iter5 = 40;
    
                let r1Width_iter5 = Math.max((r1Tokens_iter5 / totalTokens_iter5) * totalBarWidth_iter5, minSegmentWidth_iter5);
                let r2Width_iter5 = Math.max((r2Tokens_iter5 / totalTokens_iter5) * totalBarWidth_iter5, minSegmentWidth_iter5);
                let r3Width_iter5 = (r3Tokens_iter5 / totalTokens_iter5) * totalBarWidth_iter5;
                let r4Width_iter5 = Math.max((r4Tokens_iter5 / totalTokens_iter5) * totalBarWidth_iter5, minSegmentWidth_iter5);
                let r5Width_iter5 = (r5Tokens_iter5 / totalTokens_iter5) * totalBarWidth_iter5;
    
                // Adjust if R1, R2, R4 are at minimum
                const r1r2r4Used_iter5 = r1Width_iter5 + r2Width_iter5 + r4Width_iter5;
                const r3r5Available_iter5 = totalBarWidth_iter5 - r1r2r4Used_iter5;
                const r3r5Ratio_iter5 = r3Tokens_iter5 + r5Tokens_iter5;
                r3Width_iter5 = (r3Tokens_iter5 / r3r5Ratio_iter5) * r3r5Available_iter5;
                r5Width_iter5 = (r5Tokens_iter5 / r3r5Ratio_iter5) * r3r5Available_iter5;
    
                // Hide all circles
                r1SquareToken_iter4.style.opacity = '0';
                r2SquareToken_iter4.style.opacity = '0';
                r3SquareToken_iter4.style.opacity = '0';
                r4SquareToken_iter4.style.opacity = '0';
                r5SquareToken_iter4.style.opacity = '0';
    
                await sleep(300);
    
                // Create new container for 5-segment bar
                const barContainer_iter5 = document.createElement('div');
                barContainer_iter5.style.position = 'absolute';
                barContainer_iter5.style.left = '50%';
                barContainer_iter5.style.top = circleTopPosition_iter5 + 'px';
                barContainer_iter5.style.transform = 'translateX(-50%)';
                barContainer_iter5.style.width = totalBarWidth_iter5 + 'px';
                barContainer_iter5.style.height = '25px';
                barContainer_iter5.style.display = 'flex';
                barContainer_iter5.style.zIndex = '100';
                barContainer_iter5.innerHTML = `
                    <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R1</div>
                    <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R2</div>
                    <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R3</div>
                    <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R4</div>
                    <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R5</div>
                `;
                flowDiagram.appendChild(barContainer_iter5);
    
                await sleep(500);
    
                // ========== ITERATION 5: Show query_start_loc arrows ==========
    
                const barRect_iter5 = barContainer_iter5.getBoundingClientRect();
                const barLeftEdge_iter5 = barRect_iter5.left - flowRect.left;
                const barTop_iter5 = barRect_iter5.top - flowRect.top;
                const barHeight_iter5 = 25;
    
                const queryArrows_iter5 = [];
                const arrowPositions_iter5 = [
                    { offset: 0, value: '0' }, // R1 starts at 0
                    { offset: r1Width_iter5, value: '1' }, // R2 starts at 1
                    { offset: r1Width_iter5 + r2Width_iter5, value: '2' }, // R3 starts at 2
                    { offset: r1Width_iter5 + r2Width_iter5 + r3Width_iter5, value: '82' }, // R4 starts at 82
                    { offset: r1Width_iter5 + r2Width_iter5 + r3Width_iter5 + r4Width_iter5, value: '83' } // R5 starts at 83
                ];
    
                arrowPositions_iter5.forEach(pos => {
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.display = 'flex';
                    arrow.style.flexDirection = 'column';
                    arrow.style.alignItems = 'center';
                    arrow.style.zIndex = '100';
                    arrow.innerHTML = `
                        <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                        <div style="font-size: 0.75em; color: #000000; font-weight: bold;">${pos.value}</div>
                    `;
                    // Add 2px offset to account for the left border
                    arrow.style.left = (barLeftEdge_iter5 + pos.offset + 2) + 'px';
                    arrow.style.top = (barTop_iter5 + barHeight_iter5 + 5) + 'px';
                    flowDiagram.appendChild(arrow);
                    queryArrows_iter5.push(arrow);
                });
    
                await sleep(2000);
    
                // Remove arrows
                queryArrows_iter5.forEach(arrow => arrow.remove());
    
                // ========== ITERATION 5: Transform to QKV bars ==========
    
                const substep3_iter5 = document.getElementById('substep3');
                substep3_iter5.classList.add('active');
    
                await sleep(500);
    
                barContainer_iter5.style.opacity = '0';
    
                await sleep(300);
    
                // Create QKV bars container with 5 segments
                const qkvBarsContainer_iter5 = document.createElement('div');
                qkvBarsContainer_iter5.style.position = 'absolute';
                qkvBarsContainer_iter5.style.left = '50%';
                qkvBarsContainer_iter5.style.top = circleTopPosition_iter5 + 'px';
                qkvBarsContainer_iter5.style.transform = 'translateX(-50%)';
                qkvBarsContainer_iter5.style.width = totalBarWidth_iter5 + 'px';
                qkvBarsContainer_iter5.style.display = 'block';
                qkvBarsContainer_iter5.style.zIndex = '100';
                qkvBarsContainer_iter5.style.opacity = '0';
                qkvBarsContainer_iter5.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer_iter5.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvBarsContainer_iter5);
    
                barContainer_iter5.remove();
    
                await sleep(100);
    
                // Fade in QKV bars
                qkvBarsContainer_iter5.style.opacity = '1';
    
                await sleep(1500);
    
                substep3_iter5.classList.remove('active');
    
                // ========== ITERATION 5: Reorder Batch - Rearrange segments to Decode > Extend > Prefill ==========
                // This happens in Model Runner box, after QKV projection
                // Highlight Reorder Batch substep
                substep4_iter5.classList.add('active');
    
                await sleep(300);
    
                // Get all segments
                const rowDivs_iter5 = qkvBarsContainer_iter5.children;
                const qBarSegments_iter5 = [];
                for (let row of rowDivs_iter5) {
                    for (let segment of row.children) {
                        qBarSegments_iter5.push(segment);
                    }
                }
    
                // Extract individual segments (5 segments per row, 3 rows = 15 total)
                const qR1_iter5 = qBarSegments_iter5[0];
                const qR2_iter5 = qBarSegments_iter5[1];
                const qR3_iter5 = qBarSegments_iter5[2];
                const qR4_iter5 = qBarSegments_iter5[3];
                const qR5_iter5 = qBarSegments_iter5[4];
                const kR1_iter5 = qBarSegments_iter5[5];
                const kR2_iter5 = qBarSegments_iter5[6];
                const kR3_iter5 = qBarSegments_iter5[7];
                const kR4_iter5 = qBarSegments_iter5[8];
                const kR5_iter5 = qBarSegments_iter5[9];
                const vR1_iter5 = qBarSegments_iter5[10];
                const vR2_iter5 = qBarSegments_iter5[11];
                const vR3_iter5 = qBarSegments_iter5[12];
                const vR4_iter5 = qBarSegments_iter5[13];
                const vR5_iter5 = qBarSegments_iter5[14];
    
                // Create new reordered QKV bars: R1, R2, R4 (decode), R3 (extend), R5 (extend)
                // Stay at same position in Model Runner
                const qkvReordered_iter5 = document.createElement('div');
                qkvReordered_iter5.style.position = 'absolute';
                qkvReordered_iter5.style.left = '50%';
                qkvReordered_iter5.style.top = circleTopPosition_iter5 + 'px';
                qkvReordered_iter5.style.transform = 'translateX(-50%)';
                qkvReordered_iter5.style.width = totalBarWidth_iter5 + 'px';
                qkvReordered_iter5.style.display = 'block';
                qkvReordered_iter5.style.zIndex = '101';
                qkvReordered_iter5.style.opacity = '0';
                qkvReordered_iter5.style.transition = 'opacity 0.6s ease';
                qkvReordered_iter5.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter5}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter5}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter5}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter5}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter5}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvReordered_iter5);
    
                await sleep(100);
    
                // Cross-fade: fade out original, fade in reordered
                qkvBarsContainer_iter5.style.transition = 'opacity 0.6s ease';
                qkvBarsContainer_iter5.style.opacity = '0';
                qkvReordered_iter5.style.opacity = '1';
    
                await sleep(600);
    
                // Remove original QKV container
                qkvBarsContainer_iter5.remove();
    
                await sleep(300);
    
                substep4_iter5.classList.remove('active');
    
                // ========== ITERATION 5: Move reordered QKV bars to Attention module ==========
    
                const attentionModule_iter5 = document.getElementById('attention');
                const attentionRect_iter5 = attentionModule_iter5.getBoundingClientRect();
                const classificationSubstep_iter5 = document.getElementById('classificationSubstep');
                const classificationRect_iter5 = classificationSubstep_iter5.getBoundingClientRect();
                const classificationBottom_iter5 = classificationRect_iter5.bottom - flowRect.top;
                const qkvTargetTop_iter5 = classificationBottom_iter5 + 5;
    
                qkvReordered_iter5.style.transition = 'all 0.8s ease';
                qkvReordered_iter5.style.top = qkvTargetTop_iter5 + 'px';
    
                await sleep(800);
    
                // ========== ITERATION 5: Classification ==========
                // Highlight classification substep
                classificationSubstep_iter5.style.background = 'rgba(255, 193, 7, 0.3)';
                classificationSubstep_iter5.style.borderColor = '#ffc107';
    
                await sleep(300);
    
                // Get all QKV bar segments from reordered container
                const rowDivs_reordered_iter5 = qkvReordered_iter5.children;
                const qBarSegments_reordered_iter5 = [];
                for (let row of rowDivs_reordered_iter5) {
                    for (let segment of row.children) {
                        qBarSegments_reordered_iter5.push(segment);
                    }
                }
    
                const decodeColor_iter5 = '#e67e22'; // Orange for decode
                const extendColor_iter5 = '#27ae60'; // Green for extend (matches extend path box)
    
                // Get individual segments (reordered: R1, R2, R4, R3, R5)
                const qR1_reordered_iter5 = qBarSegments_reordered_iter5[0];
                const qR2_reordered_iter5 = qBarSegments_reordered_iter5[1];
                const qR4_reordered_iter5 = qBarSegments_reordered_iter5[2];
                const qR3_reordered_iter5 = qBarSegments_reordered_iter5[3];
                const qR5_reordered_iter5 = qBarSegments_reordered_iter5[4];
                const kR1_reordered_iter5 = qBarSegments_reordered_iter5[5];
                const kR2_reordered_iter5 = qBarSegments_reordered_iter5[6];
                const kR4_reordered_iter5 = qBarSegments_reordered_iter5[7];
                const kR3_reordered_iter5 = qBarSegments_reordered_iter5[8];
                const kR5_reordered_iter5 = qBarSegments_reordered_iter5[9];
                const vR1_reordered_iter5 = qBarSegments_reordered_iter5[10];
                const vR2_reordered_iter5 = qBarSegments_reordered_iter5[11];
                const vR4_reordered_iter5 = qBarSegments_reordered_iter5[12];
                const vR3_reordered_iter5 = qBarSegments_reordered_iter5[13];
                const vR5_reordered_iter5 = qBarSegments_reordered_iter5[14];
    
                // Color R1, R2, R4 segments (decode) with orange
                qR1_reordered_iter5.style.transition = 'background 0.6s ease';
                qR2_reordered_iter5.style.transition = 'background 0.6s ease';
                qR4_reordered_iter5.style.transition = 'background 0.6s ease';
                kR1_reordered_iter5.style.transition = 'background 0.6s ease';
                kR2_reordered_iter5.style.transition = 'background 0.6s ease';
                kR4_reordered_iter5.style.transition = 'background 0.6s ease';
                vR1_reordered_iter5.style.transition = 'background 0.6s ease';
                vR2_reordered_iter5.style.transition = 'background 0.6s ease';
                vR4_reordered_iter5.style.transition = 'background 0.6s ease';
    
                qR1_reordered_iter5.style.background = decodeColor_iter5;
                qR2_reordered_iter5.style.background = decodeColor_iter5;
                qR4_reordered_iter5.style.background = decodeColor_iter5;
                kR1_reordered_iter5.style.background = decodeColor_iter5;
                kR2_reordered_iter5.style.background = decodeColor_iter5;
                kR4_reordered_iter5.style.background = decodeColor_iter5;
                vR1_reordered_iter5.style.background = decodeColor_iter5;
                vR2_reordered_iter5.style.background = decodeColor_iter5;
                vR4_reordered_iter5.style.background = decodeColor_iter5;
    
                // Color R3 and R5 segments (extend) with green
                qR3_reordered_iter5.style.transition = 'background 0.6s ease';
                kR3_reordered_iter5.style.transition = 'background 0.6s ease';
                vR3_reordered_iter5.style.transition = 'background 0.6s ease';
                qR5_reordered_iter5.style.transition = 'background 0.6s ease';
                kR5_reordered_iter5.style.transition = 'background 0.6s ease';
                vR5_reordered_iter5.style.transition = 'background 0.6s ease';
    
                qR3_reordered_iter5.style.background = extendColor_iter5;
                kR3_reordered_iter5.style.background = extendColor_iter5;
                vR3_reordered_iter5.style.background = extendColor_iter5;
                qR5_reordered_iter5.style.background = extendColor_iter5;
                kR5_reordered_iter5.style.background = extendColor_iter5;
                vR5_reordered_iter5.style.background = extendColor_iter5;
    
                await sleep(600);
    
                // Remove classification highlight
                classificationSubstep_iter5.style.background = '';
                classificationSubstep_iter5.style.borderColor = '#ddd';
    
                // ========== ITERATION 5: Move decode segments (R1, R2, R4) to decode path box ==========
    
                // Get current positions and widths of R1, R2, R4 segments
                const qR1Rect_iter5 = qR1_reordered_iter5.getBoundingClientRect();
                const qR1CurrentLeft_iter5 = qR1Rect_iter5.left - flowRect.left;
                const qR1CurrentTop_iter5 = qR1Rect_iter5.top - flowRect.top;
                const qR1CurrentWidth_iter5 = qR1Rect_iter5.width;
                const qR2CurrentWidth_iter5 = qR2_reordered_iter5.getBoundingClientRect().width;
                const qR4CurrentWidth_iter5 = qR4_reordered_iter5.getBoundingClientRect().width;
    
                // Create a new container for R1, R2, R4 bars that will move to decode path
                const r1r2r4Container_iter5 = document.createElement('div');
                r1r2r4Container_iter5.style.position = 'absolute';
                r1r2r4Container_iter5.style.left = qR1CurrentLeft_iter5 + 'px';
                r1r2r4Container_iter5.style.top = qR1CurrentTop_iter5 + 'px';
                r1r2r4Container_iter5.style.width = (qR1CurrentWidth_iter5 + qR2CurrentWidth_iter5 + qR4CurrentWidth_iter5) + 'px';
                r1r2r4Container_iter5.style.display = 'flex';
                r1r2r4Container_iter5.style.flexDirection = 'column';
                r1r2r4Container_iter5.style.gap = '0px';
                r1r2r4Container_iter5.style.zIndex = '100';
    
                // Clone R1, R2, R4 segments from all three rows
                const qR1Clone_iter5 = qR1_reordered_iter5.cloneNode(true);
                const qR2Clone_iter5 = qR2_reordered_iter5.cloneNode(true);
                const qR4Clone_iter5 = qR4_reordered_iter5.cloneNode(true);
                const kR1Clone_iter5 = kR1_reordered_iter5.cloneNode(true);
                const kR2Clone_iter5 = kR2_reordered_iter5.cloneNode(true);
                const kR4Clone_iter5 = kR4_reordered_iter5.cloneNode(true);
                const vR1Clone_iter5 = vR1_reordered_iter5.cloneNode(true);
                const vR2Clone_iter5 = vR2_reordered_iter5.cloneNode(true);
                const vR4Clone_iter5 = vR4_reordered_iter5.cloneNode(true);
    
                // Make clones stretch to fill container proportionally
                const r1OriginalWidth_iter5 = qR1_reordered_iter5.getBoundingClientRect().width;
                const r2OriginalWidth_iter5 = qR2_reordered_iter5.getBoundingClientRect().width;
                const r4OriginalWidth_iter5 = qR4_reordered_iter5.getBoundingClientRect().width;
                const totalOriginalWidth_decode_iter5 = r1OriginalWidth_iter5 + r2OriginalWidth_iter5 + r4OriginalWidth_iter5;
                const r1WidthPercent_iter5 = (r1OriginalWidth_iter5 / totalOriginalWidth_decode_iter5 * 100) + '%';
                const r2WidthPercent_iter5 = (r2OriginalWidth_iter5 / totalOriginalWidth_decode_iter5 * 100) + '%';
                const r4WidthPercent_iter5 = (r4OriginalWidth_iter5 / totalOriginalWidth_decode_iter5 * 100) + '%';
    
                qR1Clone_iter5.style.width = r1WidthPercent_iter5;
                qR2Clone_iter5.style.width = r2WidthPercent_iter5;
                qR4Clone_iter5.style.width = r4WidthPercent_iter5;
                kR1Clone_iter5.style.width = r1WidthPercent_iter5;
                kR2Clone_iter5.style.width = r2WidthPercent_iter5;
                kR4Clone_iter5.style.width = r4WidthPercent_iter5;
                vR1Clone_iter5.style.width = r1WidthPercent_iter5;
                vR2Clone_iter5.style.width = r2WidthPercent_iter5;
                vR4Clone_iter5.style.width = r4WidthPercent_iter5;
    
                qR1Clone_iter5.style.flexShrink = '0';
                qR2Clone_iter5.style.flexShrink = '0';
                qR4Clone_iter5.style.flexShrink = '0';
                kR1Clone_iter5.style.flexShrink = '0';
                kR2Clone_iter5.style.flexShrink = '0';
                kR4Clone_iter5.style.flexShrink = '0';
                vR1Clone_iter5.style.flexShrink = '0';
                vR2Clone_iter5.style.flexShrink = '0';
                vR4Clone_iter5.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r1r2r4_iter5 = document.createElement('div');
                qRow_r1r2r4_iter5.style.display = 'flex';
                qRow_r1r2r4_iter5.style.width = '100%';
                qRow_r1r2r4_iter5.appendChild(qR1Clone_iter5);
                qRow_r1r2r4_iter5.appendChild(qR2Clone_iter5);
                qRow_r1r2r4_iter5.appendChild(qR4Clone_iter5);
    
                const kRow_r1r2r4_iter5 = document.createElement('div');
                kRow_r1r2r4_iter5.style.display = 'flex';
                kRow_r1r2r4_iter5.style.width = '100%';
                kRow_r1r2r4_iter5.appendChild(kR1Clone_iter5);
                kRow_r1r2r4_iter5.appendChild(kR2Clone_iter5);
                kRow_r1r2r4_iter5.appendChild(kR4Clone_iter5);
    
                const vRow_r1r2r4_iter5 = document.createElement('div');
                vRow_r1r2r4_iter5.style.display = 'flex';
                vRow_r1r2r4_iter5.style.width = '100%';
                vRow_r1r2r4_iter5.appendChild(vR1Clone_iter5);
                vRow_r1r2r4_iter5.appendChild(vR2Clone_iter5);
                vRow_r1r2r4_iter5.appendChild(vR4Clone_iter5);
    
                // Append rows to container
                r1r2r4Container_iter5.appendChild(qRow_r1r2r4_iter5);
                r1r2r4Container_iter5.appendChild(kRow_r1r2r4_iter5);
                r1r2r4Container_iter5.appendChild(vRow_r1r2r4_iter5);
    
                flowDiagram.appendChild(r1r2r4Container_iter5);
    
                // Hide original R1, R2, R4 segments (prevents R3 and R5 from shifting)
                qR1_reordered_iter5.style.opacity = '0';
                qR2_reordered_iter5.style.opacity = '0';
                qR4_reordered_iter5.style.opacity = '0';
                kR1_reordered_iter5.style.opacity = '0';
                kR2_reordered_iter5.style.opacity = '0';
                kR4_reordered_iter5.style.opacity = '0';
                vR1_reordered_iter5.style.opacity = '0';
                vR2_reordered_iter5.style.opacity = '0';
                vR4_reordered_iter5.style.opacity = '0';
    
                await sleep(200);
    
                // Get decode path box position
                const decodePathBox_iter5 = document.getElementById('decodePath');
                const decodePathRect_iter5 = decodePathBox_iter5.getBoundingClientRect();
                const decodePathBoxTop_iter5 = decodePathRect_iter5.top - flowRect.top;
                const decodePathBoxWidth_iter5 = decodePathRect_iter5.width;
    
                // Move and resize to decode path box
                r1r2r4Container_iter5.style.transition = 'all 0.6s ease';
                r1r2r4Container_iter5.style.left = (decodePathRect_iter5.left - flowRect.left) + 'px';
                r1r2r4Container_iter5.style.top = decodePathBoxTop_iter5 + 'px';
                r1r2r4Container_iter5.style.width = decodePathBoxWidth_iter5 + 'px';
    
                // Update info panels for R1, R2, R4 when entering decode path
                document.getElementById('r1-path').textContent = 'Decode';
                document.getElementById('r2-path').textContent = 'Decode';
                document.getElementById('r4-path').textContent = 'Decode';
    
                document.getElementById('r1-computed-tokens').textContent = '8'; // 4 + 4
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '4' });
    
                updateInfoPanel(1, { 'output': 'Effective prompt engineering for' });
    
                document.getElementById('r2-computed-tokens').textContent = '63'; // 60 + 3
                highlightValue('r2-computed-tokens');
    
                updateInfoPanel(2, { 'output-tokens': '3' });
    
                updateInfoPanel(2, { 'output': 'The foundation of' });
    
                document.getElementById('r4-computed-tokens').textContent = '32'; // 30 + 2
                highlightValue('r4-computed-tokens');
    
                updateInfoPanel(4, { 'output-tokens': '2' });
    
                updateInfoPanel(4, { 'output': 'Proprietary vs.' });
    
                await sleep(600);
    
                // ========== ITERATION 5: Move extend segments (R3, R5) to extend path box ==========
    
                // Get current positions and widths of R3 and R5 segments
                const qR3Rect_iter5 = qR3_reordered_iter5.getBoundingClientRect();
                const qR3CurrentLeft_iter5 = qR3Rect_iter5.left - flowRect.left;
                const qR3CurrentTop_iter5 = qR3Rect_iter5.top - flowRect.top;
                const qR3CurrentWidth_iter5 = qR3Rect_iter5.width;
                const qR5CurrentWidth_iter5 = qR5_reordered_iter5.getBoundingClientRect().width;
    
                // Create a new container for R3 and R5 bars that will move to extend path
                const r3r5Container_iter5 = document.createElement('div');
                r3r5Container_iter5.style.position = 'absolute';
                r3r5Container_iter5.style.left = qR3CurrentLeft_iter5 + 'px';
                r3r5Container_iter5.style.top = qR3CurrentTop_iter5 + 'px';
                r3r5Container_iter5.style.width = (qR3CurrentWidth_iter5 + qR5CurrentWidth_iter5) + 'px';
                r3r5Container_iter5.style.display = 'flex';
                r3r5Container_iter5.style.flexDirection = 'column';
                r3r5Container_iter5.style.gap = '0px';
                r3r5Container_iter5.style.zIndex = '100';
    
                // Clone R3 and R5 segments from all three rows
                const qR3Clone_iter5 = qR3_reordered_iter5.cloneNode(true);
                const qR5Clone_iter5 = qR5_reordered_iter5.cloneNode(true);
                const kR3Clone_iter5 = kR3_reordered_iter5.cloneNode(true);
                const kR5Clone_iter5 = kR5_reordered_iter5.cloneNode(true);
                const vR3Clone_iter5 = vR3_reordered_iter5.cloneNode(true);
                const vR5Clone_iter5 = vR5_reordered_iter5.cloneNode(true);
    
                // Make clones stretch to fill container proportionally
                const r3OriginalWidth_iter5 = qR3_reordered_iter5.getBoundingClientRect().width;
                const r5OriginalWidth_iter5 = qR5_reordered_iter5.getBoundingClientRect().width;
                const totalOriginalWidth_extend_iter5 = r3OriginalWidth_iter5 + r5OriginalWidth_iter5;
                const r3WidthPercent_iter5 = (r3OriginalWidth_iter5 / totalOriginalWidth_extend_iter5 * 100) + '%';
                const r5WidthPercent_iter5 = (r5OriginalWidth_iter5 / totalOriginalWidth_extend_iter5 * 100) + '%';
    
                qR3Clone_iter5.style.width = r3WidthPercent_iter5;
                qR5Clone_iter5.style.width = r5WidthPercent_iter5;
                kR3Clone_iter5.style.width = r3WidthPercent_iter5;
                kR5Clone_iter5.style.width = r5WidthPercent_iter5;
                vR3Clone_iter5.style.width = r3WidthPercent_iter5;
                vR5Clone_iter5.style.width = r5WidthPercent_iter5;
    
                qR3Clone_iter5.style.flexShrink = '0';
                qR5Clone_iter5.style.flexShrink = '0';
                kR3Clone_iter5.style.flexShrink = '0';
                kR5Clone_iter5.style.flexShrink = '0';
                vR3Clone_iter5.style.flexShrink = '0';
                vR5Clone_iter5.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r3r5_iter5 = document.createElement('div');
                qRow_r3r5_iter5.style.display = 'flex';
                qRow_r3r5_iter5.style.width = '100%';
                qRow_r3r5_iter5.appendChild(qR3Clone_iter5);
                qRow_r3r5_iter5.appendChild(qR5Clone_iter5);
    
                const kRow_r3r5_iter5 = document.createElement('div');
                kRow_r3r5_iter5.style.display = 'flex';
                kRow_r3r5_iter5.style.width = '100%';
                kRow_r3r5_iter5.appendChild(kR3Clone_iter5);
                kRow_r3r5_iter5.appendChild(kR5Clone_iter5);
    
                const vRow_r3r5_iter5 = document.createElement('div');
                vRow_r3r5_iter5.style.display = 'flex';
                vRow_r3r5_iter5.style.width = '100%';
                vRow_r3r5_iter5.appendChild(vR3Clone_iter5);
                vRow_r3r5_iter5.appendChild(vR5Clone_iter5);
    
                // Append rows to container
                r3r5Container_iter5.appendChild(qRow_r3r5_iter5);
                r3r5Container_iter5.appendChild(kRow_r3r5_iter5);
                r3r5Container_iter5.appendChild(vRow_r3r5_iter5);
    
                flowDiagram.appendChild(r3r5Container_iter5);
    
                // Hide original R3 and R5 segments
                qR3_reordered_iter5.style.opacity = '0';
                kR3_reordered_iter5.style.opacity = '0';
                vR3_reordered_iter5.style.opacity = '0';
                qR5_reordered_iter5.style.opacity = '0';
                kR5_reordered_iter5.style.opacity = '0';
                vR5_reordered_iter5.style.opacity = '0';
    
                await sleep(200);
    
                // Get extend path box position
                const extendPathBox_iter5 = document.getElementById('extendPath');
                const extendPathRect_iter5 = extendPathBox_iter5.getBoundingClientRect();
                const extendPathBoxTop_iter5 = extendPathRect_iter5.top - flowRect.top;
                const extendPathBoxWidth_iter5 = extendPathRect_iter5.width;
    
                // Move and resize to extend path box
                r3r5Container_iter5.style.transition = 'all 0.6s ease';
                r3r5Container_iter5.style.left = (extendPathRect_iter5.left - flowRect.left) + 'px';
                r3r5Container_iter5.style.top = extendPathBoxTop_iter5 + 'px';
                r3r5Container_iter5.style.width = extendPathBoxWidth_iter5 + 'px';
    
                // Update info panels for R3 and R5 when entering extend path
                document.getElementById('r3-path').textContent = 'Extend';
                document.getElementById('r5-path').textContent = 'Extend';
    
                document.getElementById('r3-computed-tokens').textContent = '280'; // 100 + 100 + 80 (all prompt)
                highlightValue('r3-computed-tokens');
    
                document.getElementById('r5-computed-tokens').textContent = '130'; // 100 + 30 (all prompt)
                highlightValue('r5-computed-tokens');
    
                // Update path history
                updateInfoPanel(1, { 'path-history': 'P D D D D' });
                updateInfoPanel(2, { 'path-history': 'P D D D' });
                updateInfoPanel(3, { 'path-history': 'P E E' });
                updateInfoPanel(4, { 'path-history': 'P D D' });
                updateInfoPanel(5, { 'path-history': 'P E' });
    
                await sleep(600);
    
                // ========== ITERATION 5: Transform to square tokens ==========
    
                // Get current positions of containers
                const r1r2r4Rect_iter5 = r1r2r4Container_iter5.getBoundingClientRect();
                const r1r2r4Left_iter5 = r1r2r4Rect_iter5.left - flowRect.left;
                const r1r2r4Top_iter5 = r1r2r4Rect_iter5.top - flowRect.top;
                const r1r2r4Width_iter5 = r1r2r4Rect_iter5.width;
    
                const r3r5Rect_iter5 = r3r5Container_iter5.getBoundingClientRect();
                const r3r5Left_iter5 = r3r5Rect_iter5.left - flowRect.left;
                const r3r5Top_iter5 = r3r5Rect_iter5.top - flowRect.top;
                const r3r5Width_iter5 = r3r5Rect_iter5.width;
    
                // Hide the original containers
                r1r2r4Container_iter5.style.opacity = '0';
                r3r5Container_iter5.style.opacity = '0';
    
                await sleep(300);
    
                // Calculate token positions to be adjacent (tokens touching each other, no gaps)
                // For decode path: R1 at left edge, R2 immediately after R1 (40px offset), R4 immediately after R2 (80px offset)
                const tokenWidth = 40;
                const r2OffsetInDecodeBox_iter5 = tokenWidth;  // R2 positioned right after R1
                const r4OffsetInDecodeBox_iter5 = tokenWidth * 2;  // R4 positioned right after R2
    
                // For extend path: R3 at left edge, R5 immediately after R3 (40px offset)
                const r5OffsetInExtendBox_iter5 = tokenWidth;  // R5 positioned right after R3
    
                // Create R1 square token (decode - cyan) positioned at the start of decode container
                r1SquareToken_iter5 = document.createElement('div');
                r1SquareToken_iter5.style.position = 'absolute';
                r1SquareToken_iter5.style.width = '40px';
                r1SquareToken_iter5.style.height = '40px';
                r1SquareToken_iter5.style.borderRadius = '4px';
                r1SquareToken_iter5.style.background = getRequestConfig(1).color; // R1 color
                r1SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter5.style.display = 'flex';
                r1SquareToken_iter5.style.alignItems = 'center';
                r1SquareToken_iter5.style.justifyContent = 'center';
                r1SquareToken_iter5.style.color = 'white';
                r1SquareToken_iter5.style.fontSize = '1.2em';
                r1SquareToken_iter5.style.fontWeight = 'bold';
                r1SquareToken_iter5.style.zIndex = '100';
                r1SquareToken_iter5.style.left = r1r2r4Left_iter5 + 'px';
                r1SquareToken_iter5.style.top = r1r2r4Top_iter5 + 'px';
                r1SquareToken_iter5.innerHTML = '';
                flowDiagram.appendChild(r1SquareToken_iter5);
    
                // Create R2 square token (decode - green) positioned adjacent to R1
                r2SquareToken_iter5 = document.createElement('div');
                r2SquareToken_iter5.style.position = 'absolute';
                r2SquareToken_iter5.style.width = '40px';
                r2SquareToken_iter5.style.height = '40px';
                r2SquareToken_iter5.style.borderRadius = '4px';
                r2SquareToken_iter5.style.background = getRequestConfig(2).color; // R2 color
                r2SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2SquareToken_iter5.style.display = 'flex';
                r2SquareToken_iter5.style.alignItems = 'center';
                r2SquareToken_iter5.style.justifyContent = 'center';
                r2SquareToken_iter5.style.color = 'white';
                r2SquareToken_iter5.style.fontSize = '1.2em';
                r2SquareToken_iter5.style.fontWeight = 'bold';
                r2SquareToken_iter5.style.zIndex = '100';
                r2SquareToken_iter5.style.left = (r1r2r4Left_iter5 + r2OffsetInDecodeBox_iter5) + 'px';
                r2SquareToken_iter5.style.top = r1r2r4Top_iter5 + 'px';
                r2SquareToken_iter5.innerHTML = '';
                flowDiagram.appendChild(r2SquareToken_iter5);
    
                // Create R3 square token (extend - darker teal) positioned at the start of extend container
                r3SquareToken_iter5 = document.createElement('div');
                r3SquareToken_iter5.style.position = 'absolute';
                r3SquareToken_iter5.style.width = '40px';
                r3SquareToken_iter5.style.height = '40px';
                r3SquareToken_iter5.style.borderRadius = '4px';
                r3SquareToken_iter5.style.background = getRequestConfig(3).color; // R3 color
                r3SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3SquareToken_iter5.style.display = 'flex';
                r3SquareToken_iter5.style.alignItems = 'center';
                r3SquareToken_iter5.style.justifyContent = 'center';
                r3SquareToken_iter5.style.color = 'white';
                r3SquareToken_iter5.style.fontSize = '1.2em';
                r3SquareToken_iter5.style.fontWeight = 'bold';
                r3SquareToken_iter5.style.zIndex = '100';
                r3SquareToken_iter5.style.left = r3r5Left_iter5 + 'px';
                r3SquareToken_iter5.style.top = r3r5Top_iter5 + 'px';
                r3SquareToken_iter5.innerHTML = '';
                flowDiagram.appendChild(r3SquareToken_iter5);
    
                // Create R4 square token (decode - darkest teal) positioned adjacent to R2 in decode container
                r4SquareToken_iter5 = document.createElement('div');
                r4SquareToken_iter5.style.position = 'absolute';
                r4SquareToken_iter5.style.width = '40px';
                r4SquareToken_iter5.style.height = '40px';
                r4SquareToken_iter5.style.borderRadius = '4px';
                r4SquareToken_iter5.style.background = getRequestConfig(4).color; // R4 color
                r4SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r4SquareToken_iter5.style.display = 'flex';
                r4SquareToken_iter5.style.alignItems = 'center';
                r4SquareToken_iter5.style.justifyContent = 'center';
                r4SquareToken_iter5.style.color = 'white';
                r4SquareToken_iter5.style.fontSize = '1.2em';
                r4SquareToken_iter5.style.fontWeight = 'bold';
                r4SquareToken_iter5.style.zIndex = '100';
                r4SquareToken_iter5.style.left = (r1r2r4Left_iter5 + r4OffsetInDecodeBox_iter5) + 'px';
                r4SquareToken_iter5.style.top = r1r2r4Top_iter5 + 'px';
                r4SquareToken_iter5.innerHTML = '';
                flowDiagram.appendChild(r4SquareToken_iter5);
    
                // Create R5 square token (extend - very darkest teal) positioned adjacent to R3 in extend container
                r5SquareToken_iter5 = document.createElement('div');
                r5SquareToken_iter5.style.position = 'absolute';
                r5SquareToken_iter5.style.width = '40px';
                r5SquareToken_iter5.style.height = '40px';
                r5SquareToken_iter5.style.borderRadius = '4px';
                r5SquareToken_iter5.style.background = getRequestConfig(5).color; // R5 color (darkest)
                r5SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r5SquareToken_iter5.style.display = 'flex';
                r5SquareToken_iter5.style.alignItems = 'center';
                r5SquareToken_iter5.style.justifyContent = 'center';
                r5SquareToken_iter5.style.color = 'white';
                r5SquareToken_iter5.style.fontSize = '1.2em';
                r5SquareToken_iter5.style.fontWeight = 'bold';
                r5SquareToken_iter5.style.zIndex = '100';
                r5SquareToken_iter5.style.left = (r3r5Left_iter5 + r5OffsetInExtendBox_iter5) + 'px';
                r5SquareToken_iter5.style.top = r3r5Top_iter5 + 'px';
                r5SquareToken_iter5.innerHTML = '';
                flowDiagram.appendChild(r5SquareToken_iter5);
    
                await sleep(400);
    
                // ========== ITERATION 5: Move to output box ==========
    
                // Get output box position
                const outputModule_iter5 = document.getElementById('output');
                const outputRect_iter5 = outputModule_iter5.getBoundingClientRect();
                const outputTop_iter5 = outputRect_iter5.top - flowRect.top + 5;
    
                // Calculate horizontal positions for all 5 tokens in output box
                const r1OutputLeft_iter5 = 180;
                const r2OutputLeft_iter5 = 255;
                const r3OutputLeft_iter5 = 330;
                const r4OutputLeft_iter5 = 405;
                const r5OutputLeft_iter5 = 480;
    
                // Move all 5 tokens together
                r1SquareToken_iter5.style.transition = 'all 0.8s ease';
                r1SquareToken_iter5.style.left = r1OutputLeft_iter5 + 'px';
                r1SquareToken_iter5.style.top = outputTop_iter5 + 'px';
                r1SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter5.style.transition = 'all 0.8s ease';
                r2SquareToken_iter5.style.left = r2OutputLeft_iter5 + 'px';
                r2SquareToken_iter5.style.top = outputTop_iter5 + 'px';
                r2SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter5.style.transition = 'all 0.8s ease';
                r3SquareToken_iter5.style.left = r3OutputLeft_iter5 + 'px';
                r3SquareToken_iter5.style.top = outputTop_iter5 + 'px';
                r3SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter5.style.transition = 'all 0.8s ease';
                r4SquareToken_iter5.style.left = r4OutputLeft_iter5 + 'px';
                r4SquareToken_iter5.style.top = outputTop_iter5 + 'px';
                r4SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter5.style.transition = 'all 0.8s ease';
                r5SquareToken_iter5.style.left = r5OutputLeft_iter5 + 'px';
                r5SquareToken_iter5.style.top = outputTop_iter5 + 'px';
                r5SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // After arriving at output box, show sampled tokens
                // All requests show "1" (all generated 1 token)
                r1SquareToken_iter5.innerHTML = '1';
                r2SquareToken_iter5.innerHTML = '1';
                r3SquareToken_iter5.innerHTML = '1';
                r4SquareToken_iter5.innerHTML = '1';
                r5SquareToken_iter5.innerHTML = '1';
    
                await sleep(500);
    
                // ========== ITERATION 5: Move back to scheduler and transform to circles ==========
    
                // Get scheduler position
                const schedulerModule_iter5 = document.getElementById('scheduler');
                const schedulerRect_iter5 = schedulerModule_iter5.getBoundingClientRect();
                const schedulerTop_iter5 = schedulerRect_iter5.top - flowRect.top + schedulerRect_iter5.height / 2 - 20;
    
                // Move all 5 tokens back to scheduler (maintain their horizontal positions)
                r1SquareToken_iter5.style.transition = 'all 0.8s ease';
                r1SquareToken_iter5.style.left = r1OutputLeft_iter5 + 'px';
                r1SquareToken_iter5.style.top = schedulerTop_iter5 + 'px';
                r1SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter5.style.transition = 'all 0.8s ease';
                r2SquareToken_iter5.style.left = r2OutputLeft_iter5 + 'px';
                r2SquareToken_iter5.style.top = schedulerTop_iter5 + 'px';
                r2SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter5.style.transition = 'all 0.8s ease';
                r3SquareToken_iter5.style.left = r3OutputLeft_iter5 + 'px';
                r3SquareToken_iter5.style.top = schedulerTop_iter5 + 'px';
                r3SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter5.style.transition = 'all 0.8s ease';
                r4SquareToken_iter5.style.left = r4OutputLeft_iter5 + 'px';
                r4SquareToken_iter5.style.top = schedulerTop_iter5 + 'px';
                r4SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter5.style.transition = 'all 0.8s ease';
                r5SquareToken_iter5.style.left = r5OutputLeft_iter5 + 'px';
                r5SquareToken_iter5.style.top = schedulerTop_iter5 + 'px';
                r5SquareToken_iter5.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // Transform all 5 tokens to circles
                r1SquareToken_iter5.style.transition = 'all 0.6s ease';
                r1SquareToken_iter5.style.width = '35px';
                r1SquareToken_iter5.style.height = '35px';
                r1SquareToken_iter5.style.borderRadius = '50%';
                r1SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter5.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r2SquareToken_iter5.style.transition = 'all 0.6s ease';
                r2SquareToken_iter5.style.width = '35px';
                r2SquareToken_iter5.style.height = '35px';
                r2SquareToken_iter5.style.borderRadius = '50%';
                r2SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2SquareToken_iter5.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r3SquareToken_iter5.style.transition = 'all 0.6s ease';
                r3SquareToken_iter5.style.width = '35px';
                r3SquareToken_iter5.style.height = '35px';
                r3SquareToken_iter5.style.borderRadius = '50%';
                r3SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3SquareToken_iter5.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r4SquareToken_iter5.style.transition = 'all 0.6s ease';
                r4SquareToken_iter5.style.width = '35px';
                r4SquareToken_iter5.style.height = '35px';
                r4SquareToken_iter5.style.borderRadius = '50%';
                r4SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r4SquareToken_iter5.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r5SquareToken_iter5.style.transition = 'all 0.6s ease';
                r5SquareToken_iter5.style.width = '35px';
                r5SquareToken_iter5.style.height = '35px';
                r5SquareToken_iter5.style.borderRadius = '50%';
                r5SquareToken_iter5.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r5SquareToken_iter5.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                await sleep(600);
    

    // ========== ITERATION 5 CODE ENDS ==========

    // Write outputs to state
    state.containers.r1SquareToken_iter5 = r1SquareToken_iter5;
    state.containers.r2SquareToken_iter5 = r2SquareToken_iter5;
    state.containers.r3SquareToken_iter5 = r3SquareToken_iter5;
    state.containers.r4SquareToken_iter5 = r4SquareToken_iter5;
    state.containers.r5SquareToken_iter5 = r5SquareToken_iter5;
}


/**
 * Run Iteration 4: R1/R2 decode, R3 extend, R4 decode, R5 prefill
 * @param {Object} state - Animation state object
 *
 * INPUTS (from state):
 * - state.flowDiagram
 * - state.flowRect
 * - state.layout
 * - state.circles[5] (r5Circle from iter 3)
 * - state.containers.r1Container to r4Container (from iter 3)
 * - state.containers.r3RemainingCircle (remaining tokens from iter 3)
 *
 * OUTPUTS (to state):
 * - state.containers.r1SquareToken_iter4
 * - state.containers.r2SquareToken_iter4
 * - state.containers.r3SquareToken_iter4
 * - state.containers.r4SquareToken_iter4
 * - state.containers.r5SquareToken_iter4
 * - state.containers.r5RemainingCircle (R5 remaining tokens circle)
 */
async function runIteration4(state) {
    // Show timeline highlight for iteration 4
    showTimelineHighlight(4);

    // Extract from state
    const flowDiagram = state.flowDiagram;
    const flowRect = state.flowRect;
    const entryLeft = state.layout.entryLeft;
    const entryTop = state.layout.entryTop;
    const startTop = state.layout.startTop;
    const schedulerTop = state.layout.schedulerTop;

    // Get inputs from previous iterations
    let r5Circle = state.circles[5];
    let r1Token_iter3 = state.containers.r1Container;
    let r2Token_iter3 = state.containers.r2Container;
    let r3Token_iter3 = state.containers.r3Container;
    let r4Token_iter3 = state.containers.r4Container;

    // Local variables
    let r3RemainingCircle = state.containers.r3RemainingCircle; // Get from iteration 3
    let r5RemainingCircle = null; // Created in this iteration
    let r1SquareToken_iter4 = null;
    let r2SquareToken_iter4 = null;
    let r3SquareToken_iter4 = null;
    let r4SquareToken_iter4 = null;
    let r5SquareToken_iter4 = null;

    // ========== ITERATION 4 CODE STARTS ==========

                // ITERATION 4: R1 decode, R2 decode, R3 extend, R4 decode, R5 prefill
                // ============================================================================
    
                // Update iteration step title
                document.getElementById('iterationStepTitle').textContent = 'Iteration step: 4';
    
                await sleep(500);
    
                // ========== ITERATION 4: Split R3 and R5 tokens - scheduler can only schedule 100 tokens ==========
    
                // Split R3: has 180 tokens, schedule 100, leave 80 remaining
                // Update the existing 180 grey circle (r3RemainingCircle from iteration 3) to show 80
                r3Token_iter3.innerHTML = '100';
                r3RemainingCircle.innerHTML = '80';
    
                await sleep(500);
    
                // Split R5: has 130 tokens, schedule 100, leave 30 remaining
                // Follow the same pattern as R3 in iteration 3
    
                // Update R5 circle to show 100 (scheduled tokens)
                r5Circle.innerHTML = '100';
    
                await sleep(300);
    
                // Get R5 current position to place 30 circle beside it
                const r5Rect_iter4 = r5Circle.getBoundingClientRect();
                const r5CurrentLeft_iter4 = r5Rect_iter4.left - flowRect.left;
                const r5CurrentTop_iter4 = r5Rect_iter4.top - flowRect.top;
    
                // Create a new circle for the remaining 30 tokens beside R5
                r5RemainingCircle = document.createElement('div');
                r5RemainingCircle.style.position = 'absolute';
                r5RemainingCircle.style.width = '30px'; // Smaller size to fit
                r5RemainingCircle.style.height = '30px';
                r5RemainingCircle.style.borderRadius = '50%';
                r5RemainingCircle.style.background = '#95a5a6'; // Grey color
                r5RemainingCircle.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r5RemainingCircle.style.display = 'flex';
                r5RemainingCircle.style.alignItems = 'center';
                r5RemainingCircle.style.justifyContent = 'center';
                r5RemainingCircle.style.color = 'white';
                r5RemainingCircle.style.fontSize = '0.65em'; // Smaller font
                r5RemainingCircle.style.fontWeight = 'bold';
                r5RemainingCircle.style.zIndex = '50';
                r5RemainingCircle.style.left = (r5CurrentLeft_iter4 + 50) + 'px';
                r5RemainingCircle.style.top = r5CurrentTop_iter4 + 'px';
                r5RemainingCircle.style.transform = 'translate(-50%, 0)'; // Center it
                r5RemainingCircle.innerHTML = '30';
                r5RemainingCircle.style.opacity = '0';
                r5RemainingCircle.style.transition = 'opacity 0.5s ease';
    
                flowDiagram.appendChild(r5RemainingCircle);
    
                // Fade in the remaining circle
                await sleep(100);
                r5RemainingCircle.style.opacity = '1';
    
                await sleep(500);
    
                // Step: Move 5 token circles from scheduler to Model Runner
                // Follow iteration 3 pattern: only move DOWN (change top position only)
                const modelRunnerModule_iter4 = document.getElementById('modelrunner');
                const modelRunnerRect_iter4 = modelRunnerModule_iter4.getBoundingClientRect();
                const substep4_iter4 = document.getElementById('substep4');
                const substep4Rect_iter4 = substep4_iter4.getBoundingClientRect();
                const reorderBatchBottom_iter4 = substep4Rect_iter4.bottom - flowRect.top;
                const circleTopPosition_iter4 = reorderBatchBottom_iter4 + 5 + (35 / 2) - 20;
    
                // Move all 5 circles down together (only change top position)
                r1Token_iter3.style.transition = 'all 0.8s ease';
                r1Token_iter3.style.top = circleTopPosition_iter4 + 'px';
    
                r2Token_iter3.style.transition = 'all 0.8s ease';
                r2Token_iter3.style.top = circleTopPosition_iter4 + 'px';
    
                r3Token_iter3.style.transition = 'all 0.8s ease';
                r3Token_iter3.style.top = circleTopPosition_iter4 + 'px';
    
                r4Token_iter3.style.transition = 'all 0.8s ease';
                r4Token_iter3.style.top = circleTopPosition_iter4 + 'px';
    
                if (r5Circle) {
                    r5Circle.style.transition = 'all 0.8s ease';
                    r5Circle.style.top = circleTopPosition_iter4 + 'px';
                }
    
                await sleep(800);
    
                // Update info panels when tokens exit scheduler
                // R5: Prefill stage - starts processing (limited by budget)
                updateInfoPanel(5, { 'start-iter': 'Iter 4' });
    
                document.getElementById('r5-remaining-tokens').textContent = '30'; // 130 - 100
                highlightValue('r5-remaining-tokens');
    
                updateInfoPanel(5, { 'scheduled-tokens': '100' });
    
                await sleep(500);
    
                // Step: Transform circles into horizontal bar with 5 segments
                // Calculate segment widths (R1: 1, R2: 1, R3: 100, R4: 1, R5: 100, total: 203)
                const r1Tokens_iter4 = 1;
                const r2Tokens_iter4 = 1;
                const r3Tokens_iter4 = 100;
                const r4Tokens_iter4 = 1;
                const r5Tokens_iter4 = 100;
                const totalTokens_iter4 = r1Tokens_iter4 + r2Tokens_iter4 + r3Tokens_iter4 + r4Tokens_iter4 + r5Tokens_iter4;
                const totalBarWidth_iter4 = 470;
                const minSegmentWidth_iter4 = 40;
    
                let r1Width_iter4 = Math.max((r1Tokens_iter4 / totalTokens_iter4) * totalBarWidth_iter4, minSegmentWidth_iter4);
                let r2Width_iter4 = Math.max((r2Tokens_iter4 / totalTokens_iter4) * totalBarWidth_iter4, minSegmentWidth_iter4);
                let r3Width_iter4 = (r3Tokens_iter4 / totalTokens_iter4) * totalBarWidth_iter4;
                let r4Width_iter4 = Math.max((r4Tokens_iter4 / totalTokens_iter4) * totalBarWidth_iter4, minSegmentWidth_iter4);
                let r5Width_iter4 = (r5Tokens_iter4 / totalTokens_iter4) * totalBarWidth_iter4;
    
                // Adjust if R1, R2, R4 are at minimum
                const r1r2r4Used = r1Width_iter4 + r2Width_iter4 + r4Width_iter4;
                const r3r5Available = totalBarWidth_iter4 - r1r2r4Used;
                const r3r5Ratio = r3Tokens_iter4 + r5Tokens_iter4;
                r3Width_iter4 = (r3Tokens_iter4 / r3r5Ratio) * r3r5Available;
                r5Width_iter4 = (r5Tokens_iter4 / r3r5Ratio) * r3r5Available;
    
                // Hide all circles
                r1Token_iter3.style.opacity = '0';
                r2Token_iter3.style.opacity = '0';
                r3Token_iter3.style.opacity = '0';
                r4Token_iter3.style.opacity = '0';
                if (r5Circle) r5Circle.style.opacity = '0';
    
                await sleep(300);
    
                // Create new container for 5-segment bar
                const barContainer_iter4 = document.createElement('div');
                barContainer_iter4.style.position = 'absolute';
                barContainer_iter4.style.left = '50%';
                barContainer_iter4.style.top = circleTopPosition_iter4 + 'px';
                barContainer_iter4.style.transform = 'translateX(-50%)';
                barContainer_iter4.style.width = totalBarWidth_iter4 + 'px';
                barContainer_iter4.style.height = '25px';
                barContainer_iter4.style.display = 'flex';
                barContainer_iter4.style.zIndex = '100';
                barContainer_iter4.innerHTML = `
                    <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R1</div>
                    <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R2</div>
                    <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R3</div>
                    <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R4</div>
                    <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">R5</div>
                `;
                flowDiagram.appendChild(barContainer_iter4);
    
                await sleep(500);
    
                // Step: Show query_start_loc arrows
                const barRect_iter4 = barContainer_iter4.getBoundingClientRect();
                const barLeftEdge_iter4 = barRect_iter4.left - flowRect.left;
                const barTop_iter4 = barRect_iter4.top - flowRect.top;
                const barHeight_iter4 = 25;
    
                const queryArrows_iter4 = [];
                const arrowPositions_iter4 = [
                    { offset: 0, value: '0' }, // R1 starts at 0
                    { offset: r1Width_iter4, value: '1' }, // R2 starts at 1
                    { offset: r1Width_iter4 + r2Width_iter4, value: '2' }, // R3 starts at 2
                    { offset: r1Width_iter4 + r2Width_iter4 + r3Width_iter4, value: '102' }, // R4 starts at 102
                    { offset: r1Width_iter4 + r2Width_iter4 + r3Width_iter4 + r4Width_iter4, value: '103' } // R5 starts at 103
                ];
    
                arrowPositions_iter4.forEach(pos => {
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.display = 'flex';
                    arrow.style.flexDirection = 'column';
                    arrow.style.alignItems = 'center';
                    arrow.style.zIndex = '100';
                    arrow.innerHTML = `
                        <div style="font-size: 1.2em; color: #000000; margin-bottom: 2px;">↑</div>
                        <div style="font-size: 0.75em; color: #000000; font-weight: bold;">${pos.value}</div>
                    `;
                    // Add 2px offset to account for the left border
                    arrow.style.left = (barLeftEdge_iter4 + pos.offset + 2) + 'px';
                    arrow.style.top = (barTop_iter4 + barHeight_iter4 + 5) + 'px';
                    flowDiagram.appendChild(arrow);
                    queryArrows_iter4.push(arrow);
                });
    
                await sleep(2000);
    
                // Remove arrows
                queryArrows_iter4.forEach(arrow => arrow.remove());
    
                // Step: Transform to QKV bars with 5 segments each
                const substep3_iter4 = document.getElementById('substep3');
                substep3_iter4.classList.add('active');
    
                await sleep(500);
    
                barContainer_iter4.style.opacity = '0';
    
                await sleep(300);
    
                // Create QKV bars container with 5 segments
                const qkvBarsContainer_iter4 = document.createElement('div');
                qkvBarsContainer_iter4.style.position = 'absolute';
                qkvBarsContainer_iter4.style.left = '50%';
                qkvBarsContainer_iter4.style.top = circleTopPosition_iter4 + 'px';
                qkvBarsContainer_iter4.style.transform = 'translateX(-50%)';
                qkvBarsContainer_iter4.style.width = totalBarWidth_iter4 + 'px';
                qkvBarsContainer_iter4.style.display = 'block';
                qkvBarsContainer_iter4.style.zIndex = '100';
                qkvBarsContainer_iter4.style.opacity = '0';
                qkvBarsContainer_iter4.style.transition = 'opacity 0.5s ease';
                qkvBarsContainer_iter4.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvBarsContainer_iter4);
    
                barContainer_iter4.remove();
    
                await sleep(100);
    
                // Fade in QKV bars
                qkvBarsContainer_iter4.style.opacity = '1';
    
                await sleep(1500);
    
                substep3_iter4.classList.remove('active');
    
                // Step: Reorder Batch - Rearrange segments to Decode > Extend > Prefill
                // This happens in Model Runner box, after QKV projection
                // Highlight Reorder Batch substep
                substep4_iter4.classList.add('active');
    
                await sleep(300);
    
                // Get all segments
                const rowDivs_iter4 = qkvBarsContainer_iter4.children;
                const qBarSegments_iter4 = [];
                for (let row of rowDivs_iter4) {
                    for (let segment of row.children) {
                        qBarSegments_iter4.push(segment);
                    }
                }
    
                // Extract individual segments (5 segments per row, 3 rows = 15 total)
                const qR1_iter4 = qBarSegments_iter4[0];
                const qR2_iter4 = qBarSegments_iter4[1];
                const qR3_iter4 = qBarSegments_iter4[2];
                const qR4_iter4 = qBarSegments_iter4[3];
                const qR5_iter4 = qBarSegments_iter4[4];
                const kR1_iter4 = qBarSegments_iter4[5];
                const kR2_iter4 = qBarSegments_iter4[6];
                const kR3_iter4 = qBarSegments_iter4[7];
                const kR4_iter4 = qBarSegments_iter4[8];
                const kR5_iter4 = qBarSegments_iter4[9];
                const vR1_iter4 = qBarSegments_iter4[10];
                const vR2_iter4 = qBarSegments_iter4[11];
                const vR3_iter4 = qBarSegments_iter4[12];
                const vR4_iter4 = qBarSegments_iter4[13];
                const vR5_iter4 = qBarSegments_iter4[14];
    
                // Create new reordered QKV bars: R1, R2, R4 (decode), R3 (extend), R5 (prefill)
                // Stay at same position in Model Runner
                const qkvReordered_iter4 = document.createElement('div');
                qkvReordered_iter4.style.position = 'absolute';
                qkvReordered_iter4.style.left = '50%';
                qkvReordered_iter4.style.top = circleTopPosition_iter4 + 'px';
                qkvReordered_iter4.style.transform = 'translateX(-50%)';
                qkvReordered_iter4.style.width = totalBarWidth_iter4 + 'px';
                qkvReordered_iter4.style.display = 'block';
                qkvReordered_iter4.style.zIndex = '101';
                qkvReordered_iter4.style.opacity = '0';
                qkvReordered_iter4.style.transition = 'opacity 0.6s ease';
                qkvReordered_iter4.innerHTML = `
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">Q<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">K<sub>R5</sub></div>
                    </div>
                    <div style="display: flex;">
                        <div style="width: ${r1Width_iter4}px; height: 25px; background: #26d0ce; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 4px 0 0 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R1</sub></div>
                        <div style="width: ${r2Width_iter4}px; height: 25px; background: #1abc9c; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R2</sub></div>
                        <div style="width: ${r4Width_iter4}px; height: 25px; background: #138d75; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R4</sub></div>
                        <div style="width: ${r3Width_iter4}px; height: 25px; background: #16a085; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R3</sub></div>
                        <div style="width: ${r5Width_iter4}px; height: 25px; background: #117a65; border: 2px solid rgba(255, 255, 255, 0.8); border-left: none; border-radius: 0 4px 4px 0; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em;">V<sub>R5</sub></div>
                    </div>
                `;
                flowDiagram.appendChild(qkvReordered_iter4);
    
                await sleep(100);
    
                // Cross-fade: fade out original, fade in reordered
                qkvBarsContainer_iter4.style.transition = 'opacity 0.6s ease';
                qkvBarsContainer_iter4.style.opacity = '0';
                qkvReordered_iter4.style.opacity = '1';
    
                await sleep(600);
    
                // Remove original QKV container
                qkvBarsContainer_iter4.remove();
    
                await sleep(300);
    
                substep4_iter4.classList.remove('active');
    
                // Step: Move reordered QKV bars to Attention module
                const attentionModule_iter4 = document.getElementById('attention');
                const attentionRect_iter4 = attentionModule_iter4.getBoundingClientRect();
                const classificationSubstep_iter4 = document.getElementById('classificationSubstep');
                const classificationRect_iter4 = classificationSubstep_iter4.getBoundingClientRect();
                const classificationBottom_iter4 = classificationRect_iter4.bottom - flowRect.top;
                const qkvTargetTop_iter4 = classificationBottom_iter4 + 5;
    
                qkvReordered_iter4.style.transition = 'all 0.8s ease';
                qkvReordered_iter4.style.top = qkvTargetTop_iter4 + 'px';
    
                await sleep(800);
    
                // ========== ITERATION 4: Classification ==========
                // Highlight classification substep
                classificationSubstep_iter4.style.background = 'rgba(255, 193, 7, 0.3)';
                classificationSubstep_iter4.style.borderColor = '#ffc107';
    
                await sleep(300);
    
                // Get all QKV bar segments from reordered container
                const rowDivs_reordered_iter4 = qkvReordered_iter4.children;
                const qBarSegments_reordered_iter4 = [];
                for (let row of rowDivs_reordered_iter4) {
                    for (let segment of row.children) {
                        qBarSegments_reordered_iter4.push(segment);
                    }
                }
    
                const decodeColor_iter4 = '#e67e22'; // Orange for decode
                const extendColor_iter4 = '#27ae60'; // Green for extend (matches extend path box)
                const prefillColor_iter4 = '#9b59b6'; // Purple for prefill
    
                // Get individual segments (reordered: R1, R2, R4, R3, R5)
                const qR1_reordered = qBarSegments_reordered_iter4[0];
                const qR2_reordered = qBarSegments_reordered_iter4[1];
                const qR4_reordered = qBarSegments_reordered_iter4[2];
                const qR3_reordered = qBarSegments_reordered_iter4[3];
                const qR5_reordered = qBarSegments_reordered_iter4[4];
                const kR1_reordered = qBarSegments_reordered_iter4[5];
                const kR2_reordered = qBarSegments_reordered_iter4[6];
                const kR4_reordered = qBarSegments_reordered_iter4[7];
                const kR3_reordered = qBarSegments_reordered_iter4[8];
                const kR5_reordered = qBarSegments_reordered_iter4[9];
                const vR1_reordered = qBarSegments_reordered_iter4[10];
                const vR2_reordered = qBarSegments_reordered_iter4[11];
                const vR4_reordered = qBarSegments_reordered_iter4[12];
                const vR3_reordered = qBarSegments_reordered_iter4[13];
                const vR5_reordered = qBarSegments_reordered_iter4[14];
    
                // Color R1, R2, R4 segments (decode) with orange
                qR1_reordered.style.transition = 'background 0.6s ease';
                qR2_reordered.style.transition = 'background 0.6s ease';
                qR4_reordered.style.transition = 'background 0.6s ease';
                kR1_reordered.style.transition = 'background 0.6s ease';
                kR2_reordered.style.transition = 'background 0.6s ease';
                kR4_reordered.style.transition = 'background 0.6s ease';
                vR1_reordered.style.transition = 'background 0.6s ease';
                vR2_reordered.style.transition = 'background 0.6s ease';
                vR4_reordered.style.transition = 'background 0.6s ease';
    
                qR1_reordered.style.background = decodeColor_iter4;
                qR2_reordered.style.background = decodeColor_iter4;
                qR4_reordered.style.background = decodeColor_iter4;
                kR1_reordered.style.background = decodeColor_iter4;
                kR2_reordered.style.background = decodeColor_iter4;
                kR4_reordered.style.background = decodeColor_iter4;
                vR1_reordered.style.background = decodeColor_iter4;
                vR2_reordered.style.background = decodeColor_iter4;
                vR4_reordered.style.background = decodeColor_iter4;
    
                // Color R3 segments (extend) with blue
                qR3_reordered.style.transition = 'background 0.6s ease';
                kR3_reordered.style.transition = 'background 0.6s ease';
                vR3_reordered.style.transition = 'background 0.6s ease';
    
                qR3_reordered.style.background = extendColor_iter4;
                kR3_reordered.style.background = extendColor_iter4;
                vR3_reordered.style.background = extendColor_iter4;
    
                // Color R5 segments (prefill) with purple
                qR5_reordered.style.transition = 'background 0.6s ease';
                kR5_reordered.style.transition = 'background 0.6s ease';
                vR5_reordered.style.transition = 'background 0.6s ease';
    
                qR5_reordered.style.background = prefillColor_iter4;
                kR5_reordered.style.background = prefillColor_iter4;
                vR5_reordered.style.background = prefillColor_iter4;
    
                await sleep(600);
    
                // Remove classification highlight
                classificationSubstep_iter4.style.background = '';
                classificationSubstep_iter4.style.borderColor = '#ddd';
    
                // ========== ITERATION 4: Move decode segments (R1, R2, R4) to decode path box ==========
    
                // Get current positions and widths of R1, R2, R4 segments
                const qR1Rect_iter4 = qR1_reordered.getBoundingClientRect();
                const qR1CurrentLeft_iter4 = qR1Rect_iter4.left - flowRect.left;
                const qR1CurrentTop_iter4 = qR1Rect_iter4.top - flowRect.top;
                const qR1CurrentWidth_iter4 = qR1Rect_iter4.width;
                const qR2CurrentWidth_iter4 = qR2_reordered.getBoundingClientRect().width;
                const qR4CurrentWidth_iter4 = qR4_reordered.getBoundingClientRect().width;
    
                // Create a new container for R1, R2, R4 bars that will move to decode path
                const r1r2r4Container_iter4 = document.createElement('div');
                r1r2r4Container_iter4.style.position = 'absolute';
                r1r2r4Container_iter4.style.left = qR1CurrentLeft_iter4 + 'px';
                r1r2r4Container_iter4.style.top = qR1CurrentTop_iter4 + 'px';
                r1r2r4Container_iter4.style.width = (qR1CurrentWidth_iter4 + qR2CurrentWidth_iter4 + qR4CurrentWidth_iter4) + 'px';
                r1r2r4Container_iter4.style.display = 'flex';
                r1r2r4Container_iter4.style.flexDirection = 'column';
                r1r2r4Container_iter4.style.gap = '0px';
                r1r2r4Container_iter4.style.zIndex = '100';
    
                // Clone R1, R2, R4 segments from all three rows
                const qR1Clone_iter4 = qR1_reordered.cloneNode(true);
                const qR2Clone_iter4 = qR2_reordered.cloneNode(true);
                const qR4Clone_iter4 = qR4_reordered.cloneNode(true);
                const kR1Clone_iter4 = kR1_reordered.cloneNode(true);
                const kR2Clone_iter4 = kR2_reordered.cloneNode(true);
                const kR4Clone_iter4 = kR4_reordered.cloneNode(true);
                const vR1Clone_iter4 = vR1_reordered.cloneNode(true);
                const vR2Clone_iter4 = vR2_reordered.cloneNode(true);
                const vR4Clone_iter4 = vR4_reordered.cloneNode(true);
    
                // Make clones stretch to fill container proportionally
                const r1OriginalWidth_iter4 = qR1_reordered.getBoundingClientRect().width;
                const r2OriginalWidth_iter4 = qR2_reordered.getBoundingClientRect().width;
                const r4OriginalWidth_iter4 = qR4_reordered.getBoundingClientRect().width;
                const totalOriginalWidth_decode = r1OriginalWidth_iter4 + r2OriginalWidth_iter4 + r4OriginalWidth_iter4;
                const r1WidthPercent_iter4 = (r1OriginalWidth_iter4 / totalOriginalWidth_decode * 100) + '%';
                const r2WidthPercent_iter4 = (r2OriginalWidth_iter4 / totalOriginalWidth_decode * 100) + '%';
                const r4WidthPercent_iter4 = (r4OriginalWidth_iter4 / totalOriginalWidth_decode * 100) + '%';
    
                qR1Clone_iter4.style.width = r1WidthPercent_iter4;
                qR2Clone_iter4.style.width = r2WidthPercent_iter4;
                qR4Clone_iter4.style.width = r4WidthPercent_iter4;
                kR1Clone_iter4.style.width = r1WidthPercent_iter4;
                kR2Clone_iter4.style.width = r2WidthPercent_iter4;
                kR4Clone_iter4.style.width = r4WidthPercent_iter4;
                vR1Clone_iter4.style.width = r1WidthPercent_iter4;
                vR2Clone_iter4.style.width = r2WidthPercent_iter4;
                vR4Clone_iter4.style.width = r4WidthPercent_iter4;
    
                qR1Clone_iter4.style.flexShrink = '0';
                qR2Clone_iter4.style.flexShrink = '0';
                qR4Clone_iter4.style.flexShrink = '0';
                kR1Clone_iter4.style.flexShrink = '0';
                kR2Clone_iter4.style.flexShrink = '0';
                kR4Clone_iter4.style.flexShrink = '0';
                vR1Clone_iter4.style.flexShrink = '0';
                vR2Clone_iter4.style.flexShrink = '0';
                vR4Clone_iter4.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r1r2r4 = document.createElement('div');
                qRow_r1r2r4.style.display = 'flex';
                qRow_r1r2r4.style.width = '100%';
                qRow_r1r2r4.appendChild(qR1Clone_iter4);
                qRow_r1r2r4.appendChild(qR2Clone_iter4);
                qRow_r1r2r4.appendChild(qR4Clone_iter4);
    
                const kRow_r1r2r4 = document.createElement('div');
                kRow_r1r2r4.style.display = 'flex';
                kRow_r1r2r4.style.width = '100%';
                kRow_r1r2r4.appendChild(kR1Clone_iter4);
                kRow_r1r2r4.appendChild(kR2Clone_iter4);
                kRow_r1r2r4.appendChild(kR4Clone_iter4);
    
                const vRow_r1r2r4 = document.createElement('div');
                vRow_r1r2r4.style.display = 'flex';
                vRow_r1r2r4.style.width = '100%';
                vRow_r1r2r4.appendChild(vR1Clone_iter4);
                vRow_r1r2r4.appendChild(vR2Clone_iter4);
                vRow_r1r2r4.appendChild(vR4Clone_iter4);
    
                // Append rows to container
                r1r2r4Container_iter4.appendChild(qRow_r1r2r4);
                r1r2r4Container_iter4.appendChild(kRow_r1r2r4);
                r1r2r4Container_iter4.appendChild(vRow_r1r2r4);
    
                flowDiagram.appendChild(r1r2r4Container_iter4);
    
                // Hide original R1, R2, R4 segments (prevents R3 and R5 from shifting)
                qR1_reordered.style.opacity = '0';
                qR2_reordered.style.opacity = '0';
                qR4_reordered.style.opacity = '0';
                kR1_reordered.style.opacity = '0';
                kR2_reordered.style.opacity = '0';
                kR4_reordered.style.opacity = '0';
                vR1_reordered.style.opacity = '0';
                vR2_reordered.style.opacity = '0';
                vR4_reordered.style.opacity = '0';
    
                await sleep(200);
    
                // Get decode path box position
                const decodePathBox_iter4 = document.getElementById('decodePath');
                const decodePathRect_iter4 = decodePathBox_iter4.getBoundingClientRect();
                const decodePathBoxTop_iter4 = decodePathRect_iter4.top - flowRect.top;
                const decodePathBoxWidth_iter4 = decodePathRect_iter4.width;
    
                // Move and resize to decode path box
                r1r2r4Container_iter4.style.transition = 'all 0.6s ease';
                r1r2r4Container_iter4.style.left = (decodePathRect_iter4.left - flowRect.left) + 'px';
                r1r2r4Container_iter4.style.top = decodePathBoxTop_iter4 + 'px';
                r1r2r4Container_iter4.style.width = decodePathBoxWidth_iter4 + 'px';
    
                // Update info panels for R1, R2, R4 when entering decode path
                document.getElementById('r1-path').textContent = 'Decode';
                document.getElementById('r2-path').textContent = 'Decode';
                document.getElementById('r4-path').textContent = 'Decode';
    
                document.getElementById('r1-computed-tokens').textContent = '7'; // 4 + 3
                highlightValue('r1-computed-tokens');
    
                updateInfoPanel(1, { 'output-tokens': '3' });
    
                updateInfoPanel(1, { 'output': 'Effective prompt engineering' });
    
                document.getElementById('r2-computed-tokens').textContent = '62'; // 60 + 2
                highlightValue('r2-computed-tokens');
    
                updateInfoPanel(2, { 'output-tokens': '2' });
    
                updateInfoPanel(2, { 'output': 'The foundation' });
    
                document.getElementById('r4-computed-tokens').textContent = '31'; // 30 + 1
                highlightValue('r4-computed-tokens');
    
                updateInfoPanel(4, { 'output-tokens': '1' });
    
                updateInfoPanel(4, { 'output': 'Proprietary' });
    
                await sleep(600);
    
                // ========== ITERATION 4: Move extend segment (R3) to extend path box ==========
    
                // Get current position and width of R3 segment
                const qR3Rect_iter4 = qR3_reordered.getBoundingClientRect();
                const qR3CurrentLeft_iter4 = qR3Rect_iter4.left - flowRect.left;
                const qR3CurrentTop_iter4 = qR3Rect_iter4.top - flowRect.top;
                const qR3CurrentWidth_iter4 = qR3Rect_iter4.width;
    
                // Create a new container for R3 bars that will move to extend path
                const r3Container_iter4 = document.createElement('div');
                r3Container_iter4.style.position = 'absolute';
                r3Container_iter4.style.left = qR3CurrentLeft_iter4 + 'px';
                r3Container_iter4.style.top = qR3CurrentTop_iter4 + 'px';
                r3Container_iter4.style.width = qR3CurrentWidth_iter4 + 'px';
                r3Container_iter4.style.display = 'flex';
                r3Container_iter4.style.flexDirection = 'column';
                r3Container_iter4.style.gap = '0px';
                r3Container_iter4.style.zIndex = '100';
    
                // Clone R3 segments from all three rows
                const qR3Clone_iter4 = qR3_reordered.cloneNode(true);
                const kR3Clone_iter4 = kR3_reordered.cloneNode(true);
                const vR3Clone_iter4 = vR3_reordered.cloneNode(true);
    
                qR3Clone_iter4.style.width = '100%';
                kR3Clone_iter4.style.width = '100%';
                vR3Clone_iter4.style.width = '100%';
    
                qR3Clone_iter4.style.flexShrink = '0';
                kR3Clone_iter4.style.flexShrink = '0';
                vR3Clone_iter4.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r3 = document.createElement('div');
                qRow_r3.style.display = 'flex';
                qRow_r3.style.width = '100%';
                qRow_r3.appendChild(qR3Clone_iter4);
    
                const kRow_r3 = document.createElement('div');
                kRow_r3.style.display = 'flex';
                kRow_r3.style.width = '100%';
                kRow_r3.appendChild(kR3Clone_iter4);
    
                const vRow_r3 = document.createElement('div');
                vRow_r3.style.display = 'flex';
                vRow_r3.style.width = '100%';
                vRow_r3.appendChild(vR3Clone_iter4);
    
                // Append rows to container
                r3Container_iter4.appendChild(qRow_r3);
                r3Container_iter4.appendChild(kRow_r3);
                r3Container_iter4.appendChild(vRow_r3);
    
                flowDiagram.appendChild(r3Container_iter4);
    
                // Hide original R3 segments
                qR3_reordered.style.opacity = '0';
                kR3_reordered.style.opacity = '0';
                vR3_reordered.style.opacity = '0';
    
                await sleep(200);
    
                // Get extend path box position
                const extendPathBox_iter4 = document.getElementById('extendPath');
                const extendPathRect_iter4 = extendPathBox_iter4.getBoundingClientRect();
                const extendPathBoxTop_iter4 = extendPathRect_iter4.top - flowRect.top;
                const extendPathBoxWidth_iter4 = extendPathRect_iter4.width;
    
                // Move and resize to extend path box
                r3Container_iter4.style.transition = 'all 0.6s ease';
                r3Container_iter4.style.left = (extendPathRect_iter4.left - flowRect.left) + 'px';
                r3Container_iter4.style.top = extendPathBoxTop_iter4 + 'px';
                r3Container_iter4.style.width = extendPathBoxWidth_iter4 + 'px';
    
                // Update info panel for R3 when entering extend path
                document.getElementById('r3-path').textContent = 'Extend';
    
                document.getElementById('r3-computed-tokens').textContent = '200'; // 100 + 100
                highlightValue('r3-computed-tokens');
    
                await sleep(600);
    
                // ========== ITERATION 4: Move prefill segment (R5) to prefill path box ==========
    
                // Get current position and width of R5 segment
                const qR5Rect_iter4 = qR5_reordered.getBoundingClientRect();
                const qR5CurrentLeft_iter4 = qR5Rect_iter4.left - flowRect.left;
                const qR5CurrentTop_iter4 = qR5Rect_iter4.top - flowRect.top;
                const qR5CurrentWidth_iter4 = qR5Rect_iter4.width;
    
                // Create a new container for R5 bars that will move to prefill path
                const r5Container_iter4 = document.createElement('div');
                r5Container_iter4.style.position = 'absolute';
                r5Container_iter4.style.left = qR5CurrentLeft_iter4 + 'px';
                r5Container_iter4.style.top = qR5CurrentTop_iter4 + 'px';
                r5Container_iter4.style.width = qR5CurrentWidth_iter4 + 'px';
                r5Container_iter4.style.display = 'flex';
                r5Container_iter4.style.flexDirection = 'column';
                r5Container_iter4.style.gap = '0px';
                r5Container_iter4.style.zIndex = '100';
    
                // Clone R5 segments from all three rows
                const qR5Clone_iter4 = qR5_reordered.cloneNode(true);
                const kR5Clone_iter4 = kR5_reordered.cloneNode(true);
                const vR5Clone_iter4 = vR5_reordered.cloneNode(true);
    
                qR5Clone_iter4.style.width = '100%';
                kR5Clone_iter4.style.width = '100%';
                vR5Clone_iter4.style.width = '100%';
    
                qR5Clone_iter4.style.flexShrink = '0';
                kR5Clone_iter4.style.flexShrink = '0';
                vR5Clone_iter4.style.flexShrink = '0';
    
                // Create row containers for the clones
                const qRow_r5 = document.createElement('div');
                qRow_r5.style.display = 'flex';
                qRow_r5.style.width = '100%';
                qRow_r5.appendChild(qR5Clone_iter4);
    
                const kRow_r5 = document.createElement('div');
                kRow_r5.style.display = 'flex';
                kRow_r5.style.width = '100%';
                kRow_r5.appendChild(kR5Clone_iter4);
    
                const vRow_r5 = document.createElement('div');
                vRow_r5.style.display = 'flex';
                vRow_r5.style.width = '100%';
                vRow_r5.appendChild(vR5Clone_iter4);
    
                // Append rows to container
                r5Container_iter4.appendChild(qRow_r5);
                r5Container_iter4.appendChild(kRow_r5);
                r5Container_iter4.appendChild(vRow_r5);
    
                flowDiagram.appendChild(r5Container_iter4);
    
                // Hide original R5 segments
                qR5_reordered.style.opacity = '0';
                kR5_reordered.style.opacity = '0';
                vR5_reordered.style.opacity = '0';
    
                await sleep(200);
    
                // Get prefill path box position
                const prefillPathBox_iter4 = document.getElementById('prefillPath');
                const prefillPathRect_iter4 = prefillPathBox_iter4.getBoundingClientRect();
                const prefillPathBoxTop_iter4 = prefillPathRect_iter4.top - flowRect.top;
                const prefillPathBoxWidth_iter4 = prefillPathRect_iter4.width;
    
                // Move and resize to prefill path box
                r5Container_iter4.style.transition = 'all 0.6s ease';
                r5Container_iter4.style.left = (prefillPathRect_iter4.left - flowRect.left) + 'px';
                r5Container_iter4.style.top = prefillPathBoxTop_iter4 + 'px';
                r5Container_iter4.style.width = prefillPathBoxWidth_iter4 + 'px';
    
                // Update info panel for R5 when entering prefill path
                document.getElementById('r5-path').textContent = 'Prefill';
    
                document.getElementById('r5-computed-tokens').textContent = '100'; // First 100 tokens
                highlightValue('r5-computed-tokens');
    
                // Update path history
                updateInfoPanel(1, { 'path-history': 'P D D D' });
                updateInfoPanel(2, { 'path-history': 'P D D' });
                updateInfoPanel(3, { 'path-history': 'P E' });
                updateInfoPanel(4, { 'path-history': 'P D' });
                updateInfoPanel(5, { 'path-history': 'P' });
    
                await sleep(600);
    
                // ========== ITERATION 4: Transform to square tokens ==========
                // Create 5 separate square tokens: R1, R2, R4 (decode), R3 (extend), R5 (prefill)
    
                // Get current positions of the three path box containers
                const r1r2r4Rect_iter4 = r1r2r4Container_iter4.getBoundingClientRect();
                const r1r2r4Left_iter4 = r1r2r4Rect_iter4.left - flowRect.left;
                const r1r2r4Top_iter4 = r1r2r4Rect_iter4.top - flowRect.top;
                const r1r2r4Width_iter4 = r1r2r4Rect_iter4.width;
    
                const r3Rect_iter4_output = r3Container_iter4.getBoundingClientRect();
                const r3Left_iter4_output = r3Rect_iter4_output.left - flowRect.left;
                const r3Top_iter4_output = r3Rect_iter4_output.top - flowRect.top;
    
                const r5Rect_iter4_output = r5Container_iter4.getBoundingClientRect();
                const r5Left_iter4_output = r5Rect_iter4_output.left - flowRect.left;
                const r5Top_iter4_output = r5Rect_iter4_output.top - flowRect.top;
    
                // Hide the original containers
                r1r2r4Container_iter4.style.opacity = '0';
                r3Container_iter4.style.opacity = '0';
                r5Container_iter4.style.opacity = '0';
    
                await sleep(300);
    
                // Calculate token positions to be adjacent (tokens touching each other, no gaps)
                // For decode path: R1 at left edge, R2 immediately after R1 (40px offset), R4 immediately after R2 (80px offset)
                const tokenWidth_iter4 = 40;
                const r2OffsetInDecodeBox_iter4 = tokenWidth_iter4;  // R2 positioned right after R1
                const r4OffsetInDecodeBox_iter4 = tokenWidth_iter4 * 2;  // R4 positioned right after R2
    
                // Create R1 square token (decode - cyan) positioned at the start of decode container
                r1SquareToken_iter4 = document.createElement('div');
                r1SquareToken_iter4.style.position = 'absolute';
                r1SquareToken_iter4.style.width = '40px';
                r1SquareToken_iter4.style.height = '40px';
                r1SquareToken_iter4.style.borderRadius = '4px';
                r1SquareToken_iter4.style.background = getRequestConfig(1).color; // R1 color
                r1SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter4.style.display = 'flex';
                r1SquareToken_iter4.style.alignItems = 'center';
                r1SquareToken_iter4.style.justifyContent = 'center';
                r1SquareToken_iter4.style.color = 'white';
                r1SquareToken_iter4.style.fontSize = '1.2em';
                r1SquareToken_iter4.style.fontWeight = 'bold';
                r1SquareToken_iter4.style.zIndex = '100';
                r1SquareToken_iter4.style.left = r1r2r4Left_iter4 + 'px';
                r1SquareToken_iter4.style.top = r1r2r4Top_iter4 + 'px';
                r1SquareToken_iter4.innerHTML = '';
                flowDiagram.appendChild(r1SquareToken_iter4);
    
                // Create R2 square token (decode - green) positioned adjacent to R1
                r2SquareToken_iter4 = document.createElement('div');
                r2SquareToken_iter4.style.position = 'absolute';
                r2SquareToken_iter4.style.width = '40px';
                r2SquareToken_iter4.style.height = '40px';
                r2SquareToken_iter4.style.borderRadius = '4px';
                r2SquareToken_iter4.style.background = getRequestConfig(2).color; // R2 color
                r2SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2SquareToken_iter4.style.display = 'flex';
                r2SquareToken_iter4.style.alignItems = 'center';
                r2SquareToken_iter4.style.justifyContent = 'center';
                r2SquareToken_iter4.style.color = 'white';
                r2SquareToken_iter4.style.fontSize = '1.2em';
                r2SquareToken_iter4.style.fontWeight = 'bold';
                r2SquareToken_iter4.style.zIndex = '100';
                r2SquareToken_iter4.style.left = (r1r2r4Left_iter4 + r2OffsetInDecodeBox_iter4) + 'px';
                r2SquareToken_iter4.style.top = r1r2r4Top_iter4 + 'px';
                r2SquareToken_iter4.innerHTML = '';
                flowDiagram.appendChild(r2SquareToken_iter4);
    
                // Create R3 square token (extend - darker teal) positioned at the start of extend container
                r3SquareToken_iter4 = document.createElement('div');
                r3SquareToken_iter4.style.position = 'absolute';
                r3SquareToken_iter4.style.width = '40px';
                r3SquareToken_iter4.style.height = '40px';
                r3SquareToken_iter4.style.borderRadius = '4px';
                r3SquareToken_iter4.style.background = getRequestConfig(3).color; // R3 color
                r3SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3SquareToken_iter4.style.display = 'flex';
                r3SquareToken_iter4.style.alignItems = 'center';
                r3SquareToken_iter4.style.justifyContent = 'center';
                r3SquareToken_iter4.style.color = 'white';
                r3SquareToken_iter4.style.fontSize = '1.2em';
                r3SquareToken_iter4.style.fontWeight = 'bold';
                r3SquareToken_iter4.style.zIndex = '100';
                r3SquareToken_iter4.style.left = r3Left_iter4_output + 'px';
                r3SquareToken_iter4.style.top = r3Top_iter4_output + 'px';
                r3SquareToken_iter4.innerHTML = '';
                flowDiagram.appendChild(r3SquareToken_iter4);
    
                // Create R4 square token (decode - darkest teal) positioned adjacent to R2 in decode container
                r4SquareToken_iter4 = document.createElement('div');
                r4SquareToken_iter4.style.position = 'absolute';
                r4SquareToken_iter4.style.width = '40px';
                r4SquareToken_iter4.style.height = '40px';
                r4SquareToken_iter4.style.borderRadius = '4px';
                r4SquareToken_iter4.style.background = getRequestConfig(4).color; // R4 color
                r4SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r4SquareToken_iter4.style.display = 'flex';
                r4SquareToken_iter4.style.alignItems = 'center';
                r4SquareToken_iter4.style.justifyContent = 'center';
                r4SquareToken_iter4.style.color = 'white';
                r4SquareToken_iter4.style.fontSize = '1.2em';
                r4SquareToken_iter4.style.fontWeight = 'bold';
                r4SquareToken_iter4.style.zIndex = '100';
                r4SquareToken_iter4.style.left = (r1r2r4Left_iter4 + r4OffsetInDecodeBox_iter4) + 'px';
                r4SquareToken_iter4.style.top = r1r2r4Top_iter4 + 'px';
                r4SquareToken_iter4.innerHTML = '';
                flowDiagram.appendChild(r4SquareToken_iter4);
    
                // Create R5 square token (prefill - very darkest teal) positioned at the start of prefill container
                r5SquareToken_iter4 = document.createElement('div');
                r5SquareToken_iter4.style.position = 'absolute';
                r5SquareToken_iter4.style.width = '40px';
                r5SquareToken_iter4.style.height = '40px';
                r5SquareToken_iter4.style.borderRadius = '4px';
                r5SquareToken_iter4.style.background = getRequestConfig(5).color; // R5 color (darkest)
                r5SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r5SquareToken_iter4.style.display = 'flex';
                r5SquareToken_iter4.style.alignItems = 'center';
                r5SquareToken_iter4.style.justifyContent = 'center';
                r5SquareToken_iter4.style.color = 'white';
                r5SquareToken_iter4.style.fontSize = '1.2em';
                r5SquareToken_iter4.style.fontWeight = 'bold';
                r5SquareToken_iter4.style.zIndex = '100';
                r5SquareToken_iter4.style.left = r5Left_iter4_output + 'px';
                r5SquareToken_iter4.style.top = r5Top_iter4_output + 'px';
                r5SquareToken_iter4.innerHTML = '';
                flowDiagram.appendChild(r5SquareToken_iter4);
    
                await sleep(400);
    
                // ========== ITERATION 4: Move to output box ==========
    
                // Get output box position
                const outputModule_iter4 = document.getElementById('output');
                const outputRect_iter4 = outputModule_iter4.getBoundingClientRect();
                const outputTop_iter4 = outputRect_iter4.top - flowRect.top + 5;
    
                // Calculate horizontal positions for all 5 tokens in output box
                // Use same spacing pattern: R1=180, R2=255, R3=330, R4=405, R5=480
                const r1OutputLeft_iter4 = 180;
                const r2OutputLeft_iter4 = 255;
                const r3OutputLeft_iter4 = 330;
                const r4OutputLeft_iter4 = 405;
                const r5OutputLeft_iter4 = 480;
    
                // Move all 5 tokens together
                r1SquareToken_iter4.style.transition = 'all 0.8s ease';
                r1SquareToken_iter4.style.left = r1OutputLeft_iter4 + 'px';
                r1SquareToken_iter4.style.top = outputTop_iter4 + 'px';
                r1SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter4.style.transition = 'all 0.8s ease';
                r2SquareToken_iter4.style.left = r2OutputLeft_iter4 + 'px';
                r2SquareToken_iter4.style.top = outputTop_iter4 + 'px';
                r2SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter4.style.transition = 'all 0.8s ease';
                r3SquareToken_iter4.style.left = r3OutputLeft_iter4 + 'px';
                r3SquareToken_iter4.style.top = outputTop_iter4 + 'px';
                r3SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter4.style.transition = 'all 0.8s ease';
                r4SquareToken_iter4.style.left = r4OutputLeft_iter4 + 'px';
                r4SquareToken_iter4.style.top = outputTop_iter4 + 'px';
                r4SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter4.style.transition = 'all 0.8s ease';
                r5SquareToken_iter4.style.left = r5OutputLeft_iter4 + 'px';
                r5SquareToken_iter4.style.top = outputTop_iter4 + 'px';
                r5SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // After arriving at output box, show sampled tokens
                // R1, R2, R4 show "1" (decode stages - generated 1 token each)
                // R3 shows "0" (extend stage - still has prompt tokens, no output yet)
                // R5 shows "0" (prefill stage - still has prompt tokens, no output yet)
                r1SquareToken_iter4.innerHTML = '1';
                r2SquareToken_iter4.innerHTML = '1';
                r3SquareToken_iter4.innerHTML = '0';
                r4SquareToken_iter4.innerHTML = '1';
                r5SquareToken_iter4.innerHTML = '0';
    
                await sleep(500);
    
                // ========== ITERATION 4: Move back to scheduler and transform to circles ==========
    
                // Get scheduler position
                const schedulerModule_iter4 = document.getElementById('scheduler');
                const schedulerRect_iter4 = schedulerModule_iter4.getBoundingClientRect();
                const schedulerTop_iter4 = schedulerRect_iter4.top - flowRect.top + schedulerRect_iter4.height / 2 - 20;
    
                // Move all 5 tokens back to scheduler (maintain their horizontal positions)
                r1SquareToken_iter4.style.transition = 'all 0.8s ease';
                r1SquareToken_iter4.style.left = r1OutputLeft_iter4 + 'px';
                r1SquareToken_iter4.style.top = schedulerTop_iter4 + 'px';
                r1SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r2SquareToken_iter4.style.transition = 'all 0.8s ease';
                r2SquareToken_iter4.style.left = r2OutputLeft_iter4 + 'px';
                r2SquareToken_iter4.style.top = schedulerTop_iter4 + 'px';
                r2SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r3SquareToken_iter4.style.transition = 'all 0.8s ease';
                r3SquareToken_iter4.style.left = r3OutputLeft_iter4 + 'px';
                r3SquareToken_iter4.style.top = schedulerTop_iter4 + 'px';
                r3SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r4SquareToken_iter4.style.transition = 'all 0.8s ease';
                r4SquareToken_iter4.style.left = r4OutputLeft_iter4 + 'px';
                r4SquareToken_iter4.style.top = schedulerTop_iter4 + 'px';
                r4SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                r5SquareToken_iter4.style.transition = 'all 0.8s ease';
                r5SquareToken_iter4.style.left = r5OutputLeft_iter4 + 'px';
                r5SquareToken_iter4.style.top = schedulerTop_iter4 + 'px';
                r5SquareToken_iter4.style.transform = 'translate(-50%, 0)';
    
                await sleep(800);
    
                // Transform all 5 tokens to circles
                r1SquareToken_iter4.style.transition = 'all 0.6s ease';
                r1SquareToken_iter4.style.width = '35px';
                r1SquareToken_iter4.style.height = '35px';
                r1SquareToken_iter4.style.borderRadius = '50%';
                r1SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r1SquareToken_iter4.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r2SquareToken_iter4.style.transition = 'all 0.6s ease';
                r2SquareToken_iter4.style.width = '35px';
                r2SquareToken_iter4.style.height = '35px';
                r2SquareToken_iter4.style.borderRadius = '50%';
                r2SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r2SquareToken_iter4.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r3SquareToken_iter4.style.transition = 'all 0.6s ease';
                r3SquareToken_iter4.style.width = '35px';
                r3SquareToken_iter4.style.height = '35px';
                r3SquareToken_iter4.style.borderRadius = '50%';
                r3SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r3SquareToken_iter4.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r4SquareToken_iter4.style.transition = 'all 0.6s ease';
                r4SquareToken_iter4.style.width = '35px';
                r4SquareToken_iter4.style.height = '35px';
                r4SquareToken_iter4.style.borderRadius = '50%';
                r4SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r4SquareToken_iter4.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                r5SquareToken_iter4.style.transition = 'all 0.6s ease';
                r5SquareToken_iter4.style.width = '35px';
                r5SquareToken_iter4.style.height = '35px';
                r5SquareToken_iter4.style.borderRadius = '50%';
                r5SquareToken_iter4.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                r5SquareToken_iter4.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.3)';
    
                await sleep(600);


    // ========== ITERATION 4 CODE ENDS ==========

    // Write outputs to state
    state.containers.r1SquareToken_iter4 = r1SquareToken_iter4;
    state.containers.r2SquareToken_iter4 = r2SquareToken_iter4;
    state.containers.r3SquareToken_iter4 = r3SquareToken_iter4;
    state.containers.r4SquareToken_iter4 = r4SquareToken_iter4;
    state.containers.r5SquareToken_iter4 = r5SquareToken_iter4;
    state.containers.r5RemainingCircle = r5RemainingCircle; // R5 remaining tokens circle
}


        async function startAnimation() {
            // Declare button/dropdown references at function level to avoid temporal dead zone
            let startBtn, pauseBtn, startIterationSelect;

            // If called while paused (user clicked "Stop & Restart"), stop current animation
            if (isRunning && isPaused) {
                isRunning = false;
                isPaused = false;
                if (pausePromiseResolve) {
                    pausePromiseResolve(); // Resolve the pause promise to exit the animation
                    pausePromiseResolve = null;
                }
                // Wait a moment for the animation to fully stop (use raw setTimeout, not sleep)
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            if (isRunning) return;

            // Clean up any previous animation elements before starting
            cleanupAnimationElements();

            // Hide timeline highlight at start
            hideTimelineHighlight();

            isRunning = true;
            isPaused = false;
            iteration = 0;
            cumulativeOutput = [];
            pathHistory = [];

            // Get button/dropdown references
            startBtn = document.getElementById('startBtn');
            pauseBtn = document.getElementById('pauseBtn');
            startIterationSelect = document.getElementById('startIterationSelect');

            startBtn.disabled = true;
            startBtn.textContent = '▶️ Start';
            pauseBtn.disabled = false;
            pauseBtn.textContent = '⏸️ Pause';
            startIterationSelect.disabled = true;

            // Initialize request state
            REQUESTS_CONFIG.forEach(req => {
                requestState[req.id] = {
                    startIteration: null,
                    pathHistory: [],
                    outputWordIndex: 0,
                    circle: null,
                    square: null,
                    currentTokens: 0
                };
            });

            try {
                // Multi-request animation - no need for old single-request input info

                // Common variables needed across all iterations
                const flowDiagram = document.querySelector('.flow-diagram');
                const flowRect = flowDiagram.getBoundingClientRect();
                const entryModule = document.getElementById('entrypoint');
                const entryRect = entryModule.getBoundingClientRect();
                const entryLeft = 180; // Use same horizontal position as test case
                const entryTop = entryRect.top - flowRect.top + entryRect.height / 2 - 20;
                const startTop = 10;

                // Scheduler position (needed by multiple iterations)
                const schedulerModule = document.getElementById('scheduler');
                const schedulerRect = schedulerModule.getBoundingClientRect();
                const schedulerTop = schedulerRect.top - flowRect.top + schedulerRect.height / 2 - 20;

                // Initialize animation state
                const state = initializeAnimationState();

                // ============================================================================
                // Loop-based iteration execution
                // ============================================================================

                // Array of iteration functions (index 0 unused, indices 1-7 for iterations 1-7)
                const iterationFunctions = [
                    null,            // Index 0 (unused)
                    runIteration1,   // Index 1
                    runIteration2,   // Index 2
                    runIteration3,   // Index 3
                    runIteration4,   // Index 4
                    runIteration5,   // Index 5
                    runIteration6,   // Index 6
                    runIteration7    // Index 7
                ];

                // Get starting iteration from dropdown (startIterationSelect already declared above)
                const startFromIteration = parseInt(startIterationSelect.value);
                const endAtIteration = 7;

                console.log(`Starting animation from iteration ${startFromIteration}`);

                // Initialize visual state if starting from iteration 2+
                if (startFromIteration > 1) {
                    console.log(`Initializing visual state for iteration ${startFromIteration}`);
                    await initializeVisualStateForIteration(startFromIteration, state);
                }

                // Run iterations from selected start to end
                for (let i = startFromIteration; i <= endAtIteration; i++) {
                    console.log(`Running iteration ${i}...`);
                    await iterationFunctions[i](state);
                }

            // Final cleanup regardless of starting iteration
            isRunning = false;
            isPaused = false;
            pausePromiseResolve = null;

            // Hide timeline highlight on completion
            hideTimelineHighlight();

            // Use already declared variables (no const redeclaration)
            startBtn.disabled = false;
            startBtn.textContent = '▶️ Start';
            pauseBtn.disabled = true;
            pauseBtn.textContent = '⏸️ Pause';
            startIterationSelect.disabled = false;

        } catch (error) {
            // Animation was stopped via reset or user clicked "Stop & Restart"
            if (error.message === 'Animation stopped') {
                console.log('Animation stopped by user');
            } else {
                console.error('Animation error:', error);
            }

            // Hide timeline highlight on error
            hideTimelineHighlight();

            // Reset button states (use already declared variables)
            isRunning = false;
            isPaused = false;
            pausePromiseResolve = null;

            startBtn.disabled = false;
            startBtn.textContent = '▶️ Start';
            pauseBtn.disabled = true;
            pauseBtn.textContent = '⏸️ Pause';
            startIterationSelect.disabled = false;
        }
    }

        async function startAnimationOld() {
            for (let i = 0; i < maxIterations; i++) {
                iteration = i + 1;
                await runIteration(i);

                if (i < maxIterations - 1) {
                    // Animation between iterations
                    const loopTiming = TIMING.iter2plus.loop;
                    await sleep(loopTiming);

                    // Get positions for animation
                    const qkvBars = document.getElementById('qkvBars');
                    const flowDiagram = document.querySelector('.flow-diagram');
                    const flowRect = flowDiagram.getBoundingClientRect();
                    const schedulerModule = document.getElementById('scheduler');
                    const schedulerRect = schedulerModule.getBoundingClientRect();
                    const schedulerLeft = schedulerRect.left - flowRect.left + schedulerRect.width / 2;
                    const schedulerTop = schedulerRect.top - flowRect.top + schedulerRect.height / 2;

                    // Move the sampled token rectangle (qkvBars) to scheduler position
                    qkvBars.style.transition = `all ${getTransition(i + 1, 'loop')} ease`;
                    qkvBars.style.left = schedulerLeft + 'px';
                    qkvBars.style.top = schedulerTop + 'px';
                    qkvBars.style.transform = 'translate(-50%, -50%)';

                    await sleep(loopTiming);

                    // Transform rectangle (qkvBars) into circle shape with next iteration's token count
                    qkvBars.style.transition = `all ${getTransition(i + 1, 'loop')} ease`;
                    qkvBars.style.width = '40px';
                    qkvBars.style.height = '40px';
                    qkvBars.style.borderRadius = '50%';
                    qkvBars.style.padding = '0';
                    qkvBars.style.display = 'flex';
                    qkvBars.style.alignItems = 'center';
                    qkvBars.style.justifyContent = 'center';
                    qkvBars.innerHTML = exampleData[i + 1].scheduled;
                    qkvBars.style.fontSize = '1.2em';
                    qkvBars.style.fontWeight = 'bold';
                    qkvBars.style.background = '#667eea';
                    qkvBars.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                    qkvBars.style.color = 'white';

                    await sleep(loopTiming);

                    // qkvBars circle will stay visible and be used in next iteration
                    // No need to reset or hide it - it becomes the input circle for next iteration
                }
            }

            // Show completion
            document.getElementById('completionMessage').classList.add('show');
            await sleep(3000);
            document.getElementById('completionMessage').classList.remove('show');

            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            isPaused = false;
            pausePromiseResolve = null;
        }

        async function runIteration(index) {
            const data = exampleData[index];
            const token = document.getElementById('requestToken');

            const inputBarContainer = document.getElementById('inputBarContainer');
            const inputBar = document.getElementById('inputBar');
            const flowDiagram = document.querySelector('.flow-diagram');
            const flowRect = flowDiagram.getBoundingClientRect();

            // Get scheduler position (all iterations start here or go through here)
            const schedulerModule = document.getElementById('scheduler');
            const schedulerRect = schedulerModule.getBoundingClientRect();
            const schedulerLeft = schedulerRect.left - flowRect.left + schedulerRect.width / 2;
            const schedulerTop = schedulerRect.top - flowRect.top + schedulerRect.height / 2;

            // Only go through Entry Point on first iteration
            if (index === 0) {
                // Step 0: Start from top (above entry point), centered
                token.textContent = data.text;
                token.className = 'request-token text show';
                token.style.left = '50%';
                token.style.top = '10px';
                token.style.transform = 'translate(-50%, 0)';
                await sleep(100);

                // Step 1: Move straight down to Entry Point
                moveTokenTo(token, 'entrypoint');
                await sleep(1000);

                // Transform text into circle at Entry Point
                const entryModule = document.getElementById('entrypoint');
                const entryRect = entryModule.getBoundingClientRect();
                const entryLeft = entryRect.left - flowRect.left + entryRect.width / 2;
                const entryTop = entryRect.top - flowRect.top + entryRect.height / 2;

                // Position circle at entry point
                inputBarContainer.style.left = entryLeft + 'px';
                inputBarContainer.style.top = entryTop + 'px';
                inputBar.textContent = '250'; // Show total prompt tokens

                // Cross-fade: token fades out, circle fades in
                token.style.transition = 'opacity 0.5s ease';
                token.style.opacity = '0';
                inputBarContainer.style.transition = 'opacity 0.5s ease';
                inputBarContainer.style.opacity = '1';

                await sleep(500);

                // Hide token
                token.style.display = 'none';
                token.classList.remove('show');
                token.textContent = '';

                await sleep(500);

                // Move circle to Scheduler center first
                inputBarContainer.style.transition = 'all 0.8s ease';
                inputBarContainer.style.left = schedulerLeft + 'px';
                inputBarContainer.style.top = schedulerTop + 'px';
                inputBarContainer.style.transform = 'translate(-50%, -50%)';

                await sleep(800);

                // PART 1 COMPLETE: Move circle to right side of scheduler and darken color
                const schedulerRightX = schedulerRect.left - flowRect.left + schedulerRect.width - 40;
                inputBarContainer.style.transition = 'all 0.6s ease';
                inputBarContainer.style.left = schedulerRightX + 'px';
                inputBarContainer.style.transform = 'translate(-50%, -50%)';

                // Change to darker blue
                inputBar.style.transition = 'background 0.6s ease';
                inputBar.style.background = 'linear-gradient(135deg, #4a5dc7 0%, #3d4fb3 100%)';

                await sleep(1000); // Pause to show Part 1 complete

                // PART 2 STARTS: Create new token with "100" in the center
                // Keep the "250" token visible on the right, but prepare to update it
                const remainingTokensContainer = document.getElementById('remainingTokensContainer');
                const remainingTokensBar = document.getElementById('remainingTokensBar');

                // Copy the position and style from inputBarContainer to remainingTokensContainer
                // Reuse schedulerRightX from above
                remainingTokensContainer.style.left = schedulerRightX + 'px';
                remainingTokensContainer.style.top = schedulerTop + 'px';
                remainingTokensContainer.style.transform = 'translate(-50%, -50%)';
                remainingTokensBar.textContent = '250';
                remainingTokensBar.style.background = 'linear-gradient(135deg, #4a5dc7 0%, #3d4fb3 100%)';
                remainingTokensContainer.style.opacity = '1';

                // Fade out the original "250" token on the right
                inputBarContainer.style.transition = 'opacity 0.5s ease';
                inputBarContainer.style.opacity = '0';

                await sleep(500);

                // Reset position to center and change to "100" (instant, no transition)
                inputBarContainer.style.transition = 'none';
                inputBarContainer.style.left = schedulerLeft + 'px';
                inputBarContainer.style.transform = 'translate(-50%, -50%)';
                inputBar.textContent = data.scheduled; // Show scheduled amount (100)
                inputBar.style.background = ''; // Reset to default color

                // Small delay before starting simultaneous animations
                await sleep(100);

                // SIMULTANEOUS: Fade in "100" token AND change "250" to "150"
                inputBarContainer.style.transition = 'opacity 0.5s ease';
                inputBarContainer.style.opacity = '1';

                remainingTokensBar.style.transition = 'all 0.5s ease';
                remainingTokensBar.textContent = '150';

                await sleep(500);
            } else {
                // For subsequent iterations, qkvBars circle is already at scheduler from previous iteration's loop
                // Just ensure it's visible and properly configured (should already be set from loop animation)

                // Update remaining tokens counter if it exists and we're still in extend phase
                if (index === 1) {
                    // Iteration 2: Update from 150 to 50 (150 - 100)
                    const remainingTokensBar = document.getElementById('remainingTokensBar');
                    remainingTokensBar.style.transition = 'all 0.5s ease';
                    remainingTokensBar.textContent = '50';
                    await sleep(500);
                } else if (index === 2) {
                    // Iteration 3: All remaining tokens (50) are being processed, so hide the dark blue token
                    const remainingTokensContainer = document.getElementById('remainingTokensContainer');
                    remainingTokensContainer.style.transition = 'opacity 0.5s ease';
                    remainingTokensContainer.style.opacity = '0';
                    await sleep(500);
                }

                await sleep(getTiming(index, 'scheduler'));
            }

            // Step 2: Scheduler - Circle is at scheduler

            // Update info panel when reaching scheduler
            // Calculate cumulative computed tokens based on scheduled tokens from all previous iterations
            let computedTokens = 0;
            for (let j = 0; j <= index; j++) {
                computedTokens += exampleData[j].scheduled;
            }
            const tokenBudget = 100; // Reset each iteration (max_num_scheduled_tokens)

            // Remaining tokens = prompt tokens that haven't been computed yet
            // Only counts input/prompt tokens, not decode output tokens
            // Useful for tracking chunked prefill scenarios
            const promptTokens = 250;
            const computedPromptTokens = Math.min(computedTokens, promptTokens);
            const remainingPromptTokens = promptTokens - computedPromptTokens;

            document.getElementById('currentIteration').textContent = iteration;
            highlightValue('currentIteration');

            document.getElementById('tokenBudget').textContent = tokenBudget;

            document.getElementById('scheduledTokens').textContent = data.scheduled;
            highlightValue('scheduledTokens');

            document.getElementById('computedTokens').textContent = computedTokens;
            highlightValue('computedTokens');

            document.getElementById('remainingTokens').textContent = remainingPromptTokens;
            highlightValue('remainingTokens');

            await sleep(getTiming(index, 'schedulerInfo'));

            // Step 3: Move circle to Model Runner position (below Reorder Batch substep box, inside Model Runner)
            // Calculate position below the fourth substep box (Reorder Batch) but inside Model Runner
            const substep4 = document.getElementById('substep4');
            const substep4Rect = substep4.getBoundingClientRect();

            // Position is relative to flow diagram, not model runner
            const circleTop = substep4Rect.bottom - flowRect.top + 5; // 5px gap below substep

            // For iteration 1, use inputBarContainer; for subsequent iterations, use qkvBars (already a circle)
            if (index === 0) {
                inputBarContainer.style.transition = 'all 0.8s ease';
                inputBarContainer.style.left = '50%';
                inputBarContainer.style.top = circleTop + 'px';
                inputBarContainer.style.transform = 'translate(-50%, 0)'; // Center horizontally only

                await sleep(800);

                // Reset token for next use
                token.style.display = '';
                token.style.opacity = '1';

                // Sub-step 1: Prepare inputs - Transform circle to horizontal bar
                document.getElementById('substep1').classList.add('active');

                // Transform the container itself, not just the inner element
                inputBarContainer.style.transition = 'all 0.6s ease';
                inputBarContainer.style.width = '470px';
                inputBarContainer.style.height = '25px';
                inputBarContainer.style.transform = 'translateX(-50%)';

                inputBar.style.transition = 'all 0.6s ease';
                inputBar.style.width = '470px';
                inputBar.style.height = '25px';
                inputBar.style.borderRadius = '4px';
                inputBar.style.fontSize = '0.9em';
                inputBar.textContent = 'input_ids array; position_ids array';

                await sleep(800);
                document.getElementById('substep1').classList.remove('active');
            } else {
                // For subsequent iterations, move qkvBars circle to Model Runner
                const qkvBars = document.getElementById('qkvBars');

                qkvBars.style.transition = `all ${getTransition(index, 'moveToModel')} ease`;
                qkvBars.style.left = '50%';
                qkvBars.style.top = circleTop + 'px';
                qkvBars.style.transform = 'translate(-50%, 0)';

                await sleep(getTiming(index, 'moveToModel'));

                // Reset token for next use
                token.style.display = '';
                token.style.opacity = '1';

                // Sub-step 1: Prepare inputs - Transform qkvBars circle to horizontal bar
                document.getElementById('substep1').classList.add('active');

                qkvBars.style.transition = `all ${getTransition(index, 'barTransform')} ease`;
                qkvBars.style.width = '470px';
                qkvBars.style.height = '25px';
                qkvBars.style.borderRadius = '4px';
                qkvBars.style.fontSize = '0.9em';
                qkvBars.innerHTML = 'input_ids array; position_ids array';

                await sleep(getTiming(index, 'barTransform'));
                document.getElementById('substep1').classList.remove('active');
            }

            // Sub-step 2: Compute query_start_loc
            document.getElementById('substep2').classList.add('active');

            // Show query_start_loc arrow pointing to the start of horizontal bar
            const queryStartArrow = document.getElementById('queryStartArrow');
            const queryStartLabel = document.getElementById('queryStartLabel');

            // Update label with current query_start_loc value
            queryStartLabel.textContent = 'query_start_loc: ' + data.query_start_loc;

            // Position arrow below the horizontal bar
            const barHeight = 25; // Height of horizontal bar
            let barLeftEdge;

            if (index === 0) {
                const inputBarRect = inputBarContainer.getBoundingClientRect();
                barLeftEdge = inputBarRect.left - flowRect.left;
            } else {
                const qkvBars = document.getElementById('qkvBars');
                const qkvBarsRect = qkvBars.getBoundingClientRect();
                barLeftEdge = qkvBarsRect.left - flowRect.left;
            }

            const arrowOffset = 0; // Offset from left edge
            queryStartArrow.style.left = (barLeftEdge + arrowOffset) + 'px';
            queryStartArrow.style.top = (circleTop + barHeight + 5) + 'px';
            queryStartArrow.classList.add('show');

            await sleep(getTiming(index, 'queryArrow'));

            // Hide query_start_loc arrow
            queryStartArrow.classList.remove('show');

            // Sub-step 3: QKV projection - Horizontal bar transforms into QKV bars
            document.getElementById('substep2').classList.remove('active');
            document.getElementById('substep3').classList.add('active');

            await sleep(getTiming(index, 'beforeQKV'));

            if (index === 0) {
                // For iteration 1: cross-fade from inputBarContainer to QKV bars
                const qkvBars = document.getElementById('qkvBars');
                qkvBars.style.top = circleTop + 'px';

                inputBarContainer.style.transition = 'opacity 0.6s ease';
                inputBarContainer.style.opacity = '0';

                qkvBars.style.transition = 'opacity 0.6s ease';
                qkvBars.classList.add('show');

                await sleep(800);
                await sleep(500);

                // Hide input circle container
                inputBarContainer.style.opacity = '0';
                inputBar.style.opacity = '1';
            } else {
                // For subsequent iterations: qkvBars horizontal bar transforms to QKV bars structure
                const qkvBars = document.getElementById('qkvBars');

                // Transform horizontal bar into stacked QKV bars
                qkvBars.style.transition = `all ${getTransition(index, 'qkvTransform')} ease`;
                qkvBars.innerHTML = `
                    <div class="qkv-single-bar q" style="background: #ff6b9d; width: 470px;">Q</div>
                    <div class="qkv-single-bar k" style="background: #ffa726; width: 470px;">K</div>
                    <div class="qkv-single-bar v" style="background: #66bb6a; width: 470px;">V</div>
                `;
                qkvBars.style.display = 'flex';
                qkvBars.style.flexDirection = 'column';
                qkvBars.style.gap = '0px';
                qkvBars.style.fontSize = '0.7em';
                qkvBars.style.fontWeight = 'normal';
                qkvBars.style.background = 'transparent';
                qkvBars.style.border = 'none';
                qkvBars.style.padding = '0';
                qkvBars.style.width = 'auto';
                qkvBars.style.height = 'auto';
                qkvBars.style.color = 'white';
                qkvBars.classList.add('show');

                await sleep(getTiming(index, 'qkvTransform'));
                await sleep(getTiming(index, 'qkvTransform'));
            }

            // Clear all substep highlights
            document.getElementById('substep3').classList.remove('active');

            await sleep(getTiming(index, 'afterQKV'));

            // Step 4: Move QKV bars down into Attention Backend with smooth transition
            const attentionModule = document.getElementById('attention');
            const attentionRect = attentionModule.getBoundingClientRect();
            const classificationSubstep = document.getElementById('classificationSubstep');
            const classificationRect = classificationSubstep.getBoundingClientRect();

            const attentionLeft = attentionRect.left - flowRect.left + attentionRect.width / 2;
            const attentionTop = attentionRect.top - flowRect.top + attentionRect.height / 2;

            // Calculate classification substep position
            const classificationLeft = classificationRect.left - flowRect.left + classificationRect.width / 2;
            const classificationTop = classificationRect.top - flowRect.top + classificationRect.height / 2;

            // Enable smooth position transition for movement
            qkvBars.style.transition = `all ${getTransition(index, 'moveToAttention')} ease`;

            // Move QKV bars to position below classification substep
            // Position top of QKV bars just below the classification substep
            const classificationBottom = classificationRect.bottom - flowRect.top;
            const gap = 10; // Gap between classification substep and QKV bars

            qkvBars.style.left = classificationLeft + 'px'; // Center horizontally
            qkvBars.style.top = (classificationBottom + gap) + 'px'; // Position top below classification
            qkvBars.style.transform = 'translateX(-50%)'; // Ensure proper centering

            await sleep(getTiming(index, 'moveToAttention'));

            // Highlight classification substep
            classificationSubstep.classList.add('active');

            await sleep(getTiming(index, 'classification'));

            // Change QKV bar colors based on request type
            const qBar = document.querySelector('.qkv-single-bar.q');
            const kBar = document.querySelector('.qkv-single-bar.k');
            const vBar = document.querySelector('.qkv-single-bar.v');

            // Get path-specific color
            let pathColor;
            if (data.path === 'prefill') {
                pathColor = '#9b59b6'; // Purple
            } else if (data.path === 'extend') {
                pathColor = '#27ae60'; // Green
            } else { // decode
                pathColor = '#e67e22'; // Orange
            }

            // Apply color change with transition
            const colorTransitionTime = getTransition(index, 'colorChange');
            qBar.style.transition = `background ${colorTransitionTime} ease`;
            kBar.style.transition = `background ${colorTransitionTime} ease`;
            vBar.style.transition = `background ${colorTransitionTime} ease`;

            qBar.style.background = pathColor;
            kBar.style.background = pathColor;
            vBar.style.background = pathColor;

            await sleep(getTiming(index, 'colorChange'));

            // Remove classification highlight
            classificationSubstep.classList.remove('active');

            // Get the target path box element
            const pathId = data.path === 'prefill' ? 'prefillPath' :
                          data.path === 'extend' ? 'extendPath' : 'decodePath';
            const pathBox = document.getElementById(pathId);
            const pathBoxRect = pathBox.getBoundingClientRect();

            // Calculate path box position - align top of QKV bars with top of path box
            const pathBoxLeft = pathBoxRect.left - flowRect.left + pathBoxRect.width / 2;
            const pathBoxTop = pathBoxRect.top - flowRect.top; // Top edge of path box
            const pathBoxWidth = pathBoxRect.width;

            // Shrink QKV bars width to match path box width and move to path box
            const pathBoxTransitionTime = getTransition(index, 'pathBox');
            qBar.style.transition = `all ${pathBoxTransitionTime} ease`;
            kBar.style.transition = `all ${pathBoxTransitionTime} ease`;
            vBar.style.transition = `all ${pathBoxTransitionTime} ease`;
            qkvBars.style.transition = `all ${pathBoxTransitionTime} ease`;

            qBar.style.width = pathBoxWidth + 'px';
            kBar.style.width = pathBoxWidth + 'px';
            vBar.style.width = pathBoxWidth + 'px';

            qkvBars.style.left = pathBoxLeft + 'px';
            qkvBars.style.top = pathBoxTop + 'px'; // Align top edge
            qkvBars.style.transform = 'translateX(-50%)';

            // Highlight the path box
            pathBox.classList.add('active');

            await sleep(getTiming(index, 'pathBox'));

            // Remove path box highlight
            pathBox.classList.remove('active');

            await sleep(getTiming(index, 'afterPathBox'));

            // Transform QKV bars into output token
            // Hide individual QKV bars and show output text in the container
            qBar.style.opacity = '0';
            kBar.style.opacity = '0';
            vBar.style.opacity = '0';

            await sleep(getTiming(index, 'hideQKV'));

            // Update path info when reaching attention backend
            document.getElementById('currentPath').textContent = data.path.toUpperCase();
            document.getElementById('currentPath').style.color = getPathColor(data.path);
            highlightValue('currentPath');

            // Add to path history
            const pathLetter = data.path === 'prefill' ? 'P' : (data.path === 'extend' ? 'E' : 'D');
            pathHistory.push(pathLetter);

            // Build path history HTML with the latest path bolded and colored
            const pathHistoryHTML = pathHistory.map((letter, idx) => {
                if (idx === pathHistory.length - 1) {
                    // Latest path - bold and colored (match path box colors)
                    let color = '#9b59b6'; // Purple for P (Prefill)
                    if (letter === 'D') color = '#e67e22'; // Orange for D (Decode)
                    if (letter === 'E') color = '#27ae60'; // Green for E (Extend)
                    return `<span style="font-weight: bold; color: ${color};">${letter}</span>`;
                } else {
                    // Previous paths - normal
                    return letter;
                }
            }).join(' ');

            document.getElementById('pathHistory').innerHTML = pathHistoryHTML;
            highlightValue('pathHistory');

            // Transform the QKV bars container into a square output token
            // First, hide the bars by changing display before transforming
            qkvBars.style.flexDirection = 'row';  // Change from column to row
            qkvBars.style.gap = '0';
            qkvBars.style.borderRadius = '4px';  // Square corners
            qkvBars.style.padding = '12px';
            qkvBars.style.fontWeight = 'bold';
            qkvBars.style.fontSize = '0.9em';
            qkvBars.style.display = 'flex';
            qkvBars.style.alignItems = 'center';
            qkvBars.style.justifyContent = 'center';
            qkvBars.innerHTML = data.output;  // Just the output text

            // Use red color for EOS token, green for regular tokens
            if (data.output === '<EOS>') {
                qkvBars.style.background = '#e74c3c';
                qkvBars.style.border = '2px solid #c0392b';
                qkvBars.style.color = '#fff';
                qkvBars.style.width = '80px';
            } else {
                qkvBars.style.background = '#43e97b';
                qkvBars.style.border = '2px solid #2ecc71';
                qkvBars.style.color = '#000';
                qkvBars.style.width = '40px';  // Square dimensions
            }
            qkvBars.style.height = '40px';

            await sleep(getTiming(index, 'beforeOutput'));

            // Move the square token to the output box
            const outputModule = document.getElementById('output');
            const outputRect = outputModule.getBoundingClientRect();
            const outputLeft = outputRect.left - flowRect.left + outputRect.width / 2;
            const outputTop = outputRect.top - flowRect.top + outputRect.height / 2;

            qkvBars.style.transition = `all ${getTransition(index, 'moveToOutput')} ease`;
            qkvBars.style.left = outputLeft + 'px';
            qkvBars.style.top = outputTop + 'px';
            qkvBars.style.transform = 'translate(-50%, -50%)';

            await sleep(getTiming(index, 'moveToOutput'));

            // Update cumulative output (skip empty output from prefill and EOS)
            if (data.output !== '' && data.output !== '<EOS>') {
                cumulativeOutput.push(data.output);
                document.getElementById('outputTokenCount').textContent = cumulativeOutput.length;
                highlightValue('outputTokenCount');
                document.getElementById('outputText').textContent = '"' + cumulativeOutput.join(' ') + '"';
                highlightValue('outputText');
            }

            // Transform qkvBars to sampled token rectangle
            // For Prefill/Extend: 0 sampled tokens, For Decode: 1 sampled token, For EOS: keep as is
            if (data.output !== '<EOS>') {
                qkvBars.style.transition = `all ${getTransition(index, 'sampledToken')} ease`;
                qkvBars.style.width = '160px';  // Wider rectangle
                qkvBars.style.height = '40px';
                qkvBars.style.padding = '8px 12px';

                // Check if this is Prefill or Extend path (empty output)
                // Exception: Iteration 3 (index 2) is Extend but generates 1 sampled token
                if (index === 2) {
                    qkvBars.innerHTML = '1 sampled token';
                } else if (data.path === 'prefill' || data.path === 'extend') {
                    qkvBars.innerHTML = '0 sampled tokens';
                } else {
                    qkvBars.innerHTML = '1 sampled token';
                }

                qkvBars.style.fontSize = '0.8em';
                qkvBars.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                qkvBars.style.border = '2px solid #667eea';
                qkvBars.style.color = 'white';

                await sleep(getTiming(index, 'sampledToken'));
            } else {
                // For EOS token, just pause
                await sleep(getTiming(index, 'sampledToken'));
            }

            // Show sampling check
            document.getElementById('samplingCheck').textContent = data.sampling;
            highlightValue('samplingCheck');

            // Highlight sampling check based on stop condition
            const samplingElem = document.getElementById('samplingCheck');
            if (data.sampling.includes('EOS')) {
                samplingElem.style.color = '#e74c3c'; // Red for stop
                await sleep(getTiming(index, 'sampling'));
            } else {
                samplingElem.style.color = '#43e97b'; // Green for continue
                await sleep(getTiming(index, 'sampling'));
            }

            // Keep the sampled token rectangle visible (will be used for loop animation if not EOS)

            // Reset token display for next iteration
            token.style.display = '';
            token.style.opacity = '1';
        }

        function moveTokenTo(token, moduleId) {
            const module = document.getElementById(moduleId);
            const rect = module.getBoundingClientRect();
            const containerRect = module.parentElement.getBoundingClientRect();

            const left = rect.left - containerRect.left + rect.width / 2;
            const top = rect.top - containerRect.top + rect.height / 2;

            // Enable smooth transition for position changes
            token.style.transition = 'all 0.8s ease';

            token.style.left = left + 'px';
            token.style.top = top + 'px';
            token.style.transform = 'translate(-50%, -50%)';
        }

        function highlightPath(pathType) {
            document.querySelectorAll('.path-box').forEach(box => {
                box.classList.remove('active');
            });

            const pathId = pathType === 'prefill' ? 'prefillPath' :
                          pathType === 'extend' ? 'extendPath' : 'decodePath';
            document.getElementById(pathId).classList.add('active');
        }

        function clearPathHighlight() {
            document.querySelectorAll('.path-box').forEach(box => {
                box.classList.remove('active');
            });
        }

        function getPathColor(path) {
            return path === 'prefill' ? '#9b59b6' :
                   path === 'extend' ? '#27ae60' : '#e67e22';
        }

        async function sleep(ms) {
            await new Promise(resolve => setTimeout(resolve, ms));

            // Check if animation was stopped
            if (!isRunning) {
                throw new Error('Animation stopped');
            }

            // Check if paused after sleep
            if (isPaused) {
                await new Promise(resolve => {
                    pausePromiseResolve = resolve;
                });
            }

            // Check again after resume
            if (!isRunning) {
                throw new Error('Animation stopped');
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            const startBtn = document.getElementById('startBtn');
            const startIterationSelect = document.getElementById('startIterationSelect');

            if (isPaused) {
                // When paused: enable dropdown and start button for user to change iteration
                pauseBtn.textContent = '▶️ Resume';
                startBtn.disabled = false;
                startBtn.textContent = '⏹️ Stop & Restart';
                startIterationSelect.disabled = false;
            } else {
                // When resuming: disable dropdown and start button again
                pauseBtn.textContent = '⏸️ Pause';
                startBtn.disabled = true;
                startBtn.textContent = '▶️ Start';
                startIterationSelect.disabled = true;

                // Resume animation if it was paused
                if (pausePromiseResolve) {
                    pausePromiseResolve();
                    pausePromiseResolve = null;
                }
            }
        }

        // Add keyboard listener for spacebar to pause/resume
        document.addEventListener('keydown', function(event) {
            // Check if spacebar is pressed and animation is running
            if (event.code === 'Space' && isRunning) {
                event.preventDefault(); // Prevent page scroll
                togglePause();
            }
        });

        // ============================================
        // TIMELINE HIGHLIGHT - WINDOW RESIZE HANDLER (Phase 5)
        // ============================================

        /**
         * Handle window resize - reposition timeline highlight if visible
         */
        window.addEventListener('resize', function() {
            // Only reposition if a step is currently highlighted
            if (currentHighlightStep !== null) {
                // Recalculate and update position for current step
                showTimelineHighlight(currentHighlightStep);
            }
        });

        // Test animation function for multiple requests entering together
        async function testRequestsAnimation() {
            // Get entry point and flow diagram positions
            const entryModule = document.getElementById('entrypoint');
            const flowDiagram = document.querySelector('.flow-diagram');
            const flowRect = flowDiagram.getBoundingClientRect();
            const entryRect = entryModule.getBoundingClientRect();

            // Calculate entry point center position relative to flow diagram
            // const entryLeft = entryRect.left - flowRect.left + entryRect.width / 2;
            const entryLeft = 180
            const entryTop = entryRect.top - flowRect.top + entryRect.height / 2;

            // Starting position at the top of the flow diagram (inside the scene)
            const startTop = 10;

            // Spacing configuration
            const spacing = 75; // Larger spacing between requests

            // Get all request squares
            const r1Square = document.getElementById('testR1');
            const r2Square = document.getElementById('testR2');
            const r3Square = document.getElementById('testR3');
            const r4Square = document.getElementById('testR4');
            const r5Square = document.getElementById('testR5');

            // Position R1 at entry point (keep at original position)
            r1Square.style.transition = 'none';
            r1Square.style.left = entryLeft + 'px';
            r1Square.style.top = startTop + 'px';
            r1Square.style.transform = 'translate(-50%, 0)';
            r1Square.style.opacity = '1';

            // Position R2-R5 to the right with spacing
            const otherSquares = [r2Square, r3Square, r4Square, r5Square];
            otherSquares.forEach((square, index) => {
                square.style.transition = 'none';
                square.style.left = (entryLeft + ((index + 1) * spacing)) + 'px';
                square.style.top = startTop + 'px';
                square.style.transform = 'translate(-50%, 0)';
                square.style.opacity = '1';
            });

            await sleep(500);

            // Animate R1 sliding down to entry point
            r1Square.style.transition = 'top 1.5s ease';
            r1Square.style.top = entryTop + 'px';

            await sleep(1500);

            // Transform R1 square into a circle token at entry point
            const inputBarContainer = document.getElementById('inputBarContainer');
            const inputBar = document.getElementById('inputBar');

            // Position circle at entry point
            inputBarContainer.style.transition = 'none';
            inputBarContainer.style.left = entryLeft + 'px';
            inputBarContainer.style.top = entryTop + 'px';
            inputBarContainer.style.transform = 'translate(-50%, -50%)';
            inputBar.textContent = getRequestConfig(1).promptTokens.toString(); // R1 prompt tokens
            inputBar.style.background = getRequestConfig(1).color; // R1 color

            // Cross-fade: R1 square fades out, circle fades in
            r1Square.style.transition = 'opacity 0.5s ease';
            r1Square.style.opacity = '0';
            inputBarContainer.style.transition = 'opacity 0.5s ease';
            inputBarContainer.style.opacity = '1';

            await sleep(500);

            // Now continue with the existing animation flow for iteration 1
            // Get scheduler position
            const schedulerModule = document.getElementById('scheduler');
            const schedulerRect = schedulerModule.getBoundingClientRect();
            const schedulerLeft = schedulerRect.left - flowRect.left + schedulerRect.width / 2;
            const schedulerTop = schedulerRect.top - flowRect.top + schedulerRect.height / 2;

            await sleep(500);

            // Move circle to Scheduler
            inputBarContainer.style.transition = 'all 0.8s ease';
            inputBarContainer.style.left = schedulerLeft + 'px';
            inputBarContainer.style.top = schedulerTop + 'px';
            inputBarContainer.style.transform = 'translate(-50%, -50%)';

            await sleep(800);

            // Now run the rest of iteration 1 using the existing animation logic
            // We'll call runIteration(0) to execute iteration 1
            await runIteration(0);

            // Animation complete - reset
            await sleep(1000);

            // Reset R1 square position
            r1Square.style.transition = 'none';
            r1Square.style.opacity = '0';
            r1Square.style.top = startTop + 'px';
        }
    </script>
</body>
</html>